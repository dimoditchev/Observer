<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Model xmi:id="_nx1tkML5EeaSH8bbL43htA" name="RootElement">
    <eAnnotations xmi:id="_IbhgEML7EeaSH8bbL43htA" source="UMLRT_Default_top">
      <details xmi:id="_IbjVQML7EeaSH8bbL43htA" key="top_name" value="Parcer_Router"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Class" xmi:id="_9X86YML5EeaSH8bbL43htA" name="Parcer_Router" isActive="true">
      <ownedAttribute xmi:id="_o9z8AML6EeaSH8bbL43htA" name="gen" visibility="protected" type="_GuPUUML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_sW4woML6EeaSH8bbL43htA" name="top" visibility="protected" type="_IuNA8ML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_uWG2YML6EeaSH8bbL43htA" name="right" visibility="protected" type="_IuNA8ML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_wW-h8ML6EeaSH8bbL43htA" name="left" visibility="protected" type="_IuNA8ML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_zY9sQML6EeaSH8bbL43htA" name="bin1" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_YaaZIMMQEeaSH8bbL43htA" value="1"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_YaWHsMMQEeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_bKsIYMMQEeaSH8bbL43htA" name="bin2" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_ex4RgMMQEeaSH8bbL43htA" name="bin3" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_gzot4MMQEeaSH8bbL43htA" name="bin0" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_huNQgKorEeiDp6I37tg_Bw" name="observer" type="_htzA4KorEeiDp6I37tg_Bw" aggregation="composite"/>
      <ownedConnector xmi:id="_9hn-UML6EeaSH8bbL43htA" name="RTConnector1">
        <end xmi:id="_9hsPwML6EeaSH8bbL43htA" partWithPort="_o9z8AML6EeaSH8bbL43htA" role="_a5ynoML6EeaSH8bbL43htA"/>
        <end xmi:id="_9hs20ML6EeaSH8bbL43htA" partWithPort="_sW4woML6EeaSH8bbL43htA" role="_ejuiwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_-P5ZkML6EeaSH8bbL43htA" name="RTConnector2">
        <end xmi:id="_-P8c4ML6EeaSH8bbL43htA" partWithPort="_sW4woML6EeaSH8bbL43htA" role="_gvpnwML6EeaSH8bbL43htA"/>
        <end xmi:id="_-P8c4cL6EeaSH8bbL43htA" partWithPort="_uWG2YML6EeaSH8bbL43htA" role="_ejuiwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_-9PnwML6EeaSH8bbL43htA" name="RTConnector3">
        <end xmi:id="_-9SEAML6EeaSH8bbL43htA" partWithPort="_sW4woML6EeaSH8bbL43htA" role="_ieg9UML6EeaSH8bbL43htA"/>
        <end xmi:id="_-9SrEML6EeaSH8bbL43htA" partWithPort="_wW-h8ML6EeaSH8bbL43htA" role="_ejuiwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_0KAiIMMPEeaSH8bbL43htA" name="RTConnector4">
        <end xmi:id="_0KCXUMMPEeaSH8bbL43htA" partWithPort="_uWG2YML6EeaSH8bbL43htA" role="_gvpnwML6EeaSH8bbL43htA"/>
        <end xmi:id="_0KCXUcMPEeaSH8bbL43htA" partWithPort="_ex4RgMMQEeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_02AFcMMPEeaSH8bbL43htA" name="RTConnector5">
        <end xmi:id="_02B6oMMPEeaSH8bbL43htA" partWithPort="_uWG2YML6EeaSH8bbL43htA" role="_ieg9UML6EeaSH8bbL43htA"/>
        <end xmi:id="_02B6ocMPEeaSH8bbL43htA" partWithPort="_bKsIYMMQEeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_13afIMMPEeaSH8bbL43htA" name="RTConnector6">
        <end xmi:id="_13btQMMPEeaSH8bbL43htA" partWithPort="_wW-h8ML6EeaSH8bbL43htA" role="_gvpnwML6EeaSH8bbL43htA"/>
        <end xmi:id="_13cUUMMPEeaSH8bbL43htA" partWithPort="_zY9sQML6EeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_2pVrUMMPEeaSH8bbL43htA" name="RTConnector7">
        <end xmi:id="_2pXggMMPEeaSH8bbL43htA" partWithPort="_wW-h8ML6EeaSH8bbL43htA" role="_ieg9UML6EeaSH8bbL43htA"/>
        <end xmi:id="_2pXggcMPEeaSH8bbL43htA" partWithPort="_gzot4MMQEeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_GuPUUML6EeaSH8bbL43htA" name="Gen" classifierBehavior="_sgJk4ML7EeaSH8bbL43htA" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_a5ynoML6EeaSH8bbL43htA" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ihPrwML7EeaSH8bbL43htA" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_TGKoYML8EeaSH8bbL43htA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_37GIwML8EeaSH8bbL43htA" name="parcel" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_48hwkML8EeaSH8bbL43htA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_48kM0ML8EeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_zN4IcMYtEeaYV5cb1Zesag" name="delay">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_9chtwMYtEeaYV5cb1Zesag" value="8"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_h6A34KorEeiDp6I37tg_Bw" name="observation" visibility="protected" type="_htzA1KorEeiDp6I37tg_Bw" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_h6CGAKorEeiDp6I37tg_Bw" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_h6CGAaorEeiDp6I37tg_Bw" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_sgJk4ML7EeaSH8bbL43htA" name="GenStateMachine" isReentrant="false">
        <region xmi:id="_sgSu0ML7EeaSH8bbL43htA" name="Region">
          <transition xmi:id="_sgjNgML7EeaSH8bbL43htA" name="Initial" source="_sgYOYML7EeaSH8bbL43htA" target="_sgeVAML7EeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_6ZnPEML7EeaSH8bbL43htA">
              <language>C++</language>
              <body>srand(time(0));
timer.informEvery(UMLRTTimespec(4,0));
Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo5&quot;,(char *)&quot;GENERATING&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_yYjisML7EeaSH8bbL43htA" name="GENERATING__GENERATING__37" source="_sgeVAML7EeaSH8bbL43htA" target="_sgeVAML7EeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_I7aroML8EeaSH8bbL43htA" name="generation">
              <language>C++</language>
              <body>    int random = rand() % 4;
    parcel = Parcel();
    parcel.number = random;
    parcel.stage = 0; // 0 for &quot;top&quot;, 1 for &quot;left&quot;, 2 for &quot;right&quot;
    parcel.level = 2;
    enter.transmit(parcel).send();
    log.show(&quot;generating a parcel %d on stage %d\n&quot;, random, parcel.stage);

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::GENERATING__GENERATING__37&quot;,(char *)&quot;GENERATING&quot;,(char *)&quot;GENERATING&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_1e0JAML7EeaSH8bbL43htA" port="_ihPrwML7EeaSH8bbL43htA">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
            <trigger xmi:id="_h7W7sqorEeiDp6I37tg_Bw" event="_h7W7saorEeiDp6I37tg_Bw" port="_h6A34KorEeiDp6I37tg_Bw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_sgYOYML7EeaSH8bbL43htA" name="Pseudo5"/>
          <subvertex xmi:type="uml:State" xmi:id="_sgeVAML7EeaSH8bbL43htA" name="GENERATING">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_h7JgUKorEeiDp6I37tg_Bw" name="GENERATING__33">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::GENERATING&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_h7KHYKorEeiDp6I37tg_Bw" name="GENERATING__34">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::GENERATING&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_h7GdAKorEeiDp6I37tg_Bw" name="Observation__sendEvent" specification="_h6DUIKorEeiDp6I37tg_Bw">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_h6DUIKorEeiDp6I37tg_Bw" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_h7GdAKorEeiDp6I37tg_Bw">
        <ownedParameter xmi:id="_h6D7MKorEeiDp6I37tg_Bw" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6Ko4KorEeiDp6I37tg_Bw" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6UZ4KorEeiDp6I37tg_Bw" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6c8wKorEeiDp6I37tg_Bw" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6dj0KorEeiDp6I37tg_Bw" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6mGsKorEeiDp6I37tg_Bw" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6wewKorEeiDp6I37tg_Bw" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6yT8KorEeiDp6I37tg_Bw" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6yT8aorEeiDp6I37tg_Bw" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h6y7AKorEeiDp6I37tg_Bw" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h68sAKorEeiDp6I37tg_Bw" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_IuNA8ML6EeaSH8bbL43htA" name="Stage" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ejuiwML6EeaSH8bbL43htA" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_gvpnwML6EeaSH8bbL43htA" name="right" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ieg9UML6EeaSH8bbL43htA" name="left" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_Ko_yUML9EeaSH8bbL43htA" name="parcel" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_Ko_yUcL9EeaSH8bbL43htA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_Ko_yUsL9EeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_QkCwQMMEEeaSH8bbL43htA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_8dMHMMM5EeahHehXumVB-w" name="chute1" visibility="protected" type="_jvOOEMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_ANvnsMM6EeahHehXumVB-w" name="chute2" visibility="protected" type="_jvOOEMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_Dpq8AMM6EeahHehXumVB-w" name="sensor" visibility="protected" type="_AJLGMMM5EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_KElJ8MM6EeahHehXumVB-w" name="switcher" visibility="protected" type="_O_UbEMM5EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedConnector xmi:id="_GmpDcMM6EeahHehXumVB-w" name="RTConnector1">
        <end xmi:id="_GmrfsMM6EeahHehXumVB-w" partWithPort="_8dMHMMM5EeahHehXumVB-w" role="_v-KQIMM4EeahHehXumVB-w"/>
        <end xmi:id="_GmrfscM6EeahHehXumVB-w" partWithPort="_Dpq8AMM6EeahHehXumVB-w" role="_CHUN4MM5EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_JFiHwMM6EeahHehXumVB-w" name="RTConnector2">
        <end xmi:id="_JFkkAMM6EeahHehXumVB-w" partWithPort="_8dMHMMM5EeahHehXumVB-w" role="_sK7PEMM4EeahHehXumVB-w"/>
        <end xmi:id="_JFkkAcM6EeahHehXumVB-w" partWithPort="_ANvnsMM6EeahHehXumVB-w" role="_p1u5UMM4EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_Ni2AkMM6EeahHehXumVB-w" name="RTConnector3">
        <end xmi:id="_Ni31wMM6EeahHehXumVB-w" partWithPort="_Dpq8AMM6EeahHehXumVB-w" role="_m5dgAMM5EeahHehXumVB-w"/>
        <end xmi:id="_Ni31wcM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_gMZLEMM5EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_Q2rv4MM6EeahHehXumVB-w" name="RTConnector4">
        <end xmi:id="_Q2uMIMM6EeahHehXumVB-w" role="_ejuiwML6EeaSH8bbL43htA"/>
        <end xmi:id="_Q2uMIcM6EeahHehXumVB-w" partWithPort="_8dMHMMM5EeahHehXumVB-w" role="_p1u5UMM4EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_TMcGUMM6EeahHehXumVB-w" name="RTConnector5">
        <end xmi:id="_TMfJoMM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_0cp_QMM5EeahHehXumVB-w"/>
        <end xmi:id="_TMfwsMM6EeahHehXumVB-w" role="_gvpnwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_T-SaAMM6EeahHehXumVB-w" name="RTConnector6">
        <end xmi:id="_T-VdUMM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_3tk9cMM5EeahHehXumVB-w"/>
        <end xmi:id="_T-WEYMM6EeahHehXumVB-w" role="_ieg9UML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_fBuSQMM6EeahHehXumVB-w" name="RTConnector7">
        <end xmi:id="_fBwHcMM6EeahHehXumVB-w" partWithPort="_ANvnsMM6EeahHehXumVB-w" role="_sK7PEMM4EeahHehXumVB-w"/>
        <end xmi:id="_fBwHccM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_VxKF0MM6EeahHehXumVB-w"/>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_LOPUwML6EeaSH8bbL43htA" name="Bin" classifierBehavior="_SAHMAMMMEeaSH8bbL43htA" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_l2PuIML6EeaSH8bbL43htA" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_K51lgMMPEeaSH8bbL43htA" value="1"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_K5yiMMMPEeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_LhdrYML9EeaSH8bbL43htA" name="parcels" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_LhdrYcL9EeaSH8bbL43htA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_LhdrYsL9EeaSH8bbL43htA" value="*"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_P-w_UMMMEeaSH8bbL43htA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_h2BvwKorEeiDp6I37tg_Bw" name="observation" visibility="protected" type="_htzA1KorEeiDp6I37tg_Bw" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_h2Dk8KorEeiDp6I37tg_Bw" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_h2Dk8aorEeiDp6I37tg_Bw" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_SAHMAMMMEeaSH8bbL43htA" name="BinStateMachine" isReentrant="false">
        <region xmi:id="_SAKPUMMMEeaSH8bbL43htA" name="Region">
          <transition xmi:id="_SAPH0cMMEeaSH8bbL43htA" name="Initial" source="_SAMEgMMMEeaSH8bbL43htA" target="_SAN5sMMMEeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_JNwIoMX4EeaYV5cb1Zesag">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo3&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_YPSEAMMMEeaSH8bbL43htA" name="IDLE__IDLE__20" source="_SAN5sMMMEeaSH8bbL43htA" target="_SAN5sMMMEeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mJFFYMMMEeaSH8bbL43htA">
              <language>C++</language>
              <body>    log.show(&quot;%s received Parcel (%d)\n&quot;, getName(), p.number);

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::IDLE__IDLE__20&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_bX4MoMMMEeaSH8bbL43htA" event="_SR6HoMMBEeaSH8bbL43htA" port="_l2PuIML6EeaSH8bbL43htA"/>
            <trigger xmi:id="_h4Vc4KorEeiDp6I37tg_Bw" event="_h4U10qorEeiDp6I37tg_Bw" port="_h2BvwKorEeiDp6I37tg_Bw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_SAMEgMMMEeaSH8bbL43htA" name="Pseudo3"/>
          <subvertex xmi:type="uml:State" xmi:id="_SAN5sMMMEeaSH8bbL43htA" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_h4MS8KorEeiDp6I37tg_Bw" name="IDLE__16">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_h4M6AKorEeiDp6I37tg_Bw" name="IDLE__17">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_h4JPoKorEeiDp6I37tg_Bw" name="Observation__sendEvent" specification="_h2GoQKorEeiDp6I37tg_Bw">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_h2GoQKorEeiDp6I37tg_Bw" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_h4JPoKorEeiDp6I37tg_Bw">
        <ownedParameter xmi:id="_h2HPUKorEeiDp6I37tg_Bw" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h2S1gKorEeiDp6I37tg_Bw" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h2ebsKorEeiDp6I37tg_Bw" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h2xWoKorEeiDp6I37tg_Bw" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h2zL0KorEeiDp6I37tg_Bw" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h2-yAKorEeiDp6I37tg_Bw" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h3JKEKorEeiDp6I37tg_Bw" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h3JxIKorEeiDp6I37tg_Bw" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h3JxIaorEeiDp6I37tg_Bw" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h3KYMKorEeiDp6I37tg_Bw" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h3UJMKorEeiDp6I37tg_Bw" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_QrBtkML6EeaSH8bbL43htA" name="transmission">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_Qq5xwML6EeaSH8bbL43htA" name="transmission">
        <interfaceRealization xmi:id="_QrQXEML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrKQcML6EeaSH8bbL43htA" contract="_QrKQcML6EeaSH8bbL43htA"/>
        <interfaceRealization xmi:id="_QreZgML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrZhAML6EeaSH8bbL43htA" contract="_QrZhAML6EeaSH8bbL43htA"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_QrKQcML6EeaSH8bbL43htA" name="transmission"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_QrSzUML6EeaSH8bbL43htA" name="transmission~">
        <ownedOperation xmi:id="_PIeRgMMBEeaSH8bbL43htA" name="transmit">
          <ownedParameter xmi:id="_QFxAMMMBEeaSH8bbL43htA" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_QrXr0ML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrSzUML6EeaSH8bbL43htA"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_QrY58ML6EeaSH8bbL43htA" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_QrZhAML6EeaSH8bbL43htA" name="transmissionIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_QrfnoML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrZhAML6EeaSH8bbL43htA"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_SR6HoMMBEeaSH8bbL43htA" operation="_PIeRgMMBEeaSH8bbL43htA"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_aEoEwML7EeaSH8bbL43htA" name="Parcel">
      <ownedAttribute xmi:id="_cj_qMML7EeaSH8bbL43htA" name="number" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_2upQ0MMJEeaSH8bbL43htA" name="level">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_wiSxYMMLEeaSH8bbL43htA" value="2"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_BxJI8N5pEeakB9CQglrL_g" name="stage" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_jvOOEMM4EeahHehXumVB-w" name="Chute" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_p1u5UMM4EeahHehXumVB-w" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_sK7PEMM4EeahHehXumVB-w" name="exit" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_v-KQIMM4EeahHehXumVB-w" name="detection" visibility="public" type="_wvKPQMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:id="_4iC8wMM4EeahHehXumVB-w" name="parcel" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_8_D6oMM4EeahHehXumVB-w"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_8_HlAMM4EeahHehXumVB-w" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_qxGOYMX2EeaYV5cb1Zesag" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_WbYyIMX5EeaYV5cb1Zesag" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_oc-oIMYhEeaYV5cb1Zesag" name="delay">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_1Wbm0MYhEeaYV5cb1Zesag" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_h0HrQKorEeiDp6I37tg_Bw" name="observation" visibility="protected" type="_htzA1KorEeiDp6I37tg_Bw" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_h0JgcKorEeiDp6I37tg_Bw" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_h0JgcaorEeiDp6I37tg_Bw" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_mXBE0MM6EeahHehXumVB-w" name="ChuteStateMachine" isReentrant="false">
        <region xmi:id="_mXBE0cM6EeahHehXumVB-w" name="Region">
          <transition xmi:id="_mXBE0sM6EeahHehXumVB-w" name="Initial" source="_mXBE18M6EeahHehXumVB-w" target="_mXBE2MM6EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_h1pVQKorEeiDp6I37tg_Bw" name="Initial__13">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo2&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_mXBE1MM6EeahHehXumVB-w" name="reception" source="_mXBE2MM6EeahHehXumVB-w" target="_k2uPwMX4EeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mXBE1cM6EeahHehXumVB-w">
              <language>C++</language>
              <body>    this->parcel = Parcel();
    this->parcel.number = p.number;
    this->parcel.level = p.level;
    this->parcel.stage = p.stage;
    log.show(&quot;Chute %s of stage %d becomes occupied\n&quot;, this->getName(), p.stage);
    timer.informIn(UMLRTTimespec(this->delay,0));

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::reception&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_mXBE1sM6EeahHehXumVB-w" event="_SR6HoMMBEeaSH8bbL43htA" port="_p1u5UMM4EeahHehXumVB-w"/>
            <trigger xmi:id="_h15M4KorEeiDp6I37tg_Bw" event="_h14l0KorEeiDp6I37tg_Bw" port="_h0HrQKorEeiDp6I37tg_Bw"/>
          </transition>
          <transition xmi:id="_9Jw84MX4EeaYV5cb1Zesag" name="transmission" source="_k2uPwMX4EeaYV5cb1Zesag" target="_mXBE2MM6EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_aOTjAPPAEeajSJ5GKhFEgA">
              <language>C++</language>
              <body>    detection.detect(this->parcel).send();
    exit.transmit(this->parcel).send();
    log.show(&quot;Chute %s of stage %d is now free\n&quot;, this->getName(), this->parcel.stage);

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::transmission&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_w7wScMX5EeaYV5cb1Zesag" port="_WbYyIMX5EeaYV5cb1Zesag">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
            <trigger xmi:id="_h2AhoKorEeiDp6I37tg_Bw" event="_h1_6kKorEeiDp6I37tg_Bw" port="_h0HrQKorEeiDp6I37tg_Bw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_mXBE18M6EeahHehXumVB-w" name="Pseudo2"/>
          <subvertex xmi:type="uml:State" xmi:id="_mXBE2MM6EeahHehXumVB-w" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_h1kcwKorEeiDp6I37tg_Bw" name="IDLE__8">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_h1lD0KorEeiDp6I37tg_Bw" name="IDLE__9">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_k2uPwMX4EeaYV5cb1Zesag" name="OCCUPIED">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_h1m5AKorEeiDp6I37tg_Bw" name="OCCUPIED__10">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_h1ngEKorEeiDp6I37tg_Bw" name="OCCUPIED__11">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_h1eWIKorEeiDp6I37tg_Bw" name="Observation__sendEvent" specification="_h0Nx4KorEeiDp6I37tg_Bw">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_h0Nx4KorEeiDp6I37tg_Bw" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_h1eWIKorEeiDp6I37tg_Bw">
        <ownedParameter xmi:id="_h0OY8KorEeiDp6I37tg_Bw" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h0amMKorEeiDp6I37tg_Bw" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h0oBkKorEeiDp6I37tg_Bw" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h00O0KorEeiDp6I37tg_Bw" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h0014KorEeiDp6I37tg_Bw" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h09_0KorEeiDp6I37tg_Bw" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h1JmAKorEeiDp6I37tg_Bw" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h1KNEKorEeiDp6I37tg_Bw" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h1KNEaorEeiDp6I37tg_Bw" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h1K0IKorEeiDp6I37tg_Bw" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h1T-EKorEeiDp6I37tg_Bw" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_wvPHwMM4EeahHehXumVB-w" name="detection">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_wvKPQMM4EeahHehXumVB-w" name="detection">
        <interfaceRealization xmi:id="_wvat8MM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wvV1cMM4EeahHehXumVB-w" contract="_wvV1cMM4EeahHehXumVB-w"/>
        <interfaceRealization xmi:id="_wvltEMM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wviCsMM4EeahHehXumVB-w" contract="_wviCsMM4EeahHehXumVB-w"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_wvV1cMM4EeahHehXumVB-w" name="detection"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_wvcjIMM4EeahHehXumVB-w" name="detection~">
        <ownedOperation xmi:id="_F05S4MM5EeahHehXumVB-w" name="detect">
          <ownedParameter xmi:id="_G2MX0MM5EeahHehXumVB-w" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_wvgNgMM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wvcjIMM4EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_wvhboMM4EeahHehXumVB-w" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_wviCsMM4EeahHehXumVB-w" name="detectionIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_wvmUIMM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wviCsMM4EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_Mh59cMM5EeahHehXumVB-w" operation="_F05S4MM5EeahHehXumVB-w"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_AJLGMMM5EeahHehXumVB-w" name="Sensor" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_CHUN4MM5EeahHehXumVB-w" name="detection" visibility="public" type="_wvKPQMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_m5dgAMM5EeahHehXumVB-w" name="switchProtocol" visibility="public" type="_RDbn4MM5EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_uL2LsMM9EeahHehXumVB-w" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_hx0lMKorEeiDp6I37tg_Bw" name="observation" visibility="protected" type="_htzA1KorEeiDp6I37tg_Bw" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_hx5dsKorEeiDp6I37tg_Bw" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_hx6EwKorEeiDp6I37tg_Bw" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_IdCu8MM7EeahHehXumVB-w" name="SensorStateMachine" isReentrant="false">
        <region xmi:id="_IdCu8cM7EeahHehXumVB-w" name="Region">
          <transition xmi:id="_IdDWAMM7EeahHehXumVB-w" name="Initial" source="_IdDWBcM7EeahHehXumVB-w" target="_IdDWBsM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_hz_IYKorEeiDp6I37tg_Bw" name="Initial__7">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo1&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_IdDWAsM7EeahHehXumVB-w" name="IDLE__IDLE__5" source="_IdDWBsM7EeahHehXumVB-w" target="_IdDWBsM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_IdDWA8M7EeahHehXumVB-w">
              <language>C++</language>
              <body>    int reducedNumber = p.number/p.level; 
    int isOdd = reducedNumber % 2;
    if (isOdd == 0) {
    log.show(&quot;At stage %s (%d), turn left.\n&quot;, getName(), p.level);
    switchProtocol.setSwitch(0).send();
    }
    else {
    log.show(&quot;At stage %s (%d), turn right.\n&quot;, getName(), p.level);
    switchProtocol.setSwitch(1).send();
    }

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::IDLE__IDLE__5&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_PGM0QMM7EeahHehXumVB-w" event="_Mh59cMM5EeahHehXumVB-w" port="_CHUN4MM5EeahHehXumVB-w"/>
            <trigger xmi:id="_hz-hUKorEeiDp6I37tg_Bw" event="_hz96QKorEeiDp6I37tg_Bw" port="_hx0lMKorEeiDp6I37tg_Bw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_IdDWBcM7EeahHehXumVB-w" name="Pseudo1"/>
          <subvertex xmi:type="uml:State" xmi:id="_IdDWBsM7EeahHehXumVB-w" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_hzvQwKorEeiDp6I37tg_Bw" name="IDLE__2">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_hzwe4KorEeiDp6I37tg_Bw" name="IDLE__3">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_hzn8AKorEeiDp6I37tg_Bw" name="Observation__sendEvent" specification="_hyALYKorEeiDp6I37tg_Bw">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_hyALYKorEeiDp6I37tg_Bw" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_hzn8AKorEeiDp6I37tg_Bw">
        <ownedParameter xmi:id="_hyEc0KorEeiDp6I37tg_Bw" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hycQQKorEeiDp6I37tg_Bw" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hyrg0KorEeiDp6I37tg_Bw" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hy3HAKorEeiDp6I37tg_Bw" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hy3uEKorEeiDp6I37tg_Bw" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hzD7UKorEeiDp6I37tg_Bw" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hzO6cKorEeiDp6I37tg_Bw" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hzQIkKorEeiDp6I37tg_Bw" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hzQvoKorEeiDp6I37tg_Bw" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hzRWsKorEeiDp6I37tg_Bw" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_hzc84KorEeiDp6I37tg_Bw" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_O_UbEMM5EeahHehXumVB-w" name="Switcher" classifierBehavior="_yUE3QMM7EeahHehXumVB-w" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_gMZLEMM5EeahHehXumVB-w" name="switchProtocol" visibility="public" type="_RDbn4MM5EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_0cp_QMM5EeahHehXumVB-w" name="right" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_3tk9cMM5EeahHehXumVB-w" name="left" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_VxKF0MM6EeahHehXumVB-w" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:id="_tx4ecMM7EeahHehXumVB-w" name="choice">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_Yk87wMM9EeahHehXumVB-w" name="parcel" type="_aEoEwML7EeaSH8bbL43htA"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_x2tmMMX2EeaYV5cb1Zesag" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_b1lNUMYiEeaYV5cb1Zesag" name="delay">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_eEeGwMYiEeaYV5cb1Zesag" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_4c8vAMYlEeaYV5cb1Zesag" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_h4WD8KorEeiDp6I37tg_Bw" name="observation" visibility="protected" type="_htzA1KorEeiDp6I37tg_Bw" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_h4XSEaorEeiDp6I37tg_Bw" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_h4XSEqorEeiDp6I37tg_Bw" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_yUE3QMM7EeahHehXumVB-w" name="SwitcherStateMachine" isReentrant="false">
        <region xmi:id="_yUMMAMM7EeahHehXumVB-w" name="Region">
          <transition xmi:id="_yUTgwcM7EeahHehXumVB-w" name="Initial" source="_yUOoQMM7EeahHehXumVB-w" target="_yUSSoMM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_h50DkKorEeiDp6I37tg_Bw" name="Initial__29">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo4&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_2LEW8MM7EeahHehXumVB-w" name="IDLE__IDLE__31" source="_yUSSoMM7EeahHehXumVB-w" target="_yUSSoMM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Ci9gsMM8EeahHehXumVB-w">
              <language>C++</language>
              <body>    this->choice = c;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE__IDLE__31&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_82qsQMM7EeahHehXumVB-w" event="_cjDs4MM5EeahHehXumVB-w" port="_gMZLEMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_h57YUKorEeiDp6I37tg_Bw" event="_h5y1cKorEeiDp6I37tg_Bw" port="_h4WD8KorEeiDp6I37tg_Bw"/>
          </transition>
          <transition xmi:id="_GIbLgMM8EeahHehXumVB-w" name="reception" source="_yUSSoMM7EeahHehXumVB-w" target="_GOTbgMYlEeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fAyMMMM8EeahHehXumVB-w">
              <language>C++</language>
              <body>    this->parcel = Parcel();
    this->parcel.number = p.number;
    this->parcel.level = p.level;
    this->parcel.stage = p.stage;
    log.show(&quot;Switcher %s of stage %d becomes occupied\n&quot;, this->getName(), p.stage);
    timer.informIn(UMLRTTimespec(this->delay,0));

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::reception&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_J-RbsMM8EeahHehXumVB-w" event="_SR6HoMMBEeaSH8bbL43htA" port="_VxKF0MM6EeahHehXumVB-w"/>
            <trigger xmi:id="_h5ukAKorEeiDp6I37tg_Bw" event="_h5t88qorEeiDp6I37tg_Bw" port="_h4WD8KorEeiDp6I37tg_Bw"/>
          </transition>
          <transition xmi:id="_BK59oMYmEeaYV5cb1Zesag" name="transmission" source="_GOTbgMYlEeaYV5cb1Zesag" target="_yUSSoMM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_qAissPPAEeajSJ5GKhFEgA">
              <language>C++</language>
              <body>    this->parcel.level--;
    log.show(&quot;Switcher %s of stage %d is now free\n&quot;, this->getName(), this->parcel.stage);
    if (choice == 0) {
    this->parcel.stage = 1;
    left.transmit(this->parcel).send();
    }
    else {
    this->parcel.stage = 2;
    right.transmit(this->parcel).send();
    }

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::transmission&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_E7SfAMYmEeaYV5cb1Zesag" port="_4c8vAMYlEeaYV5cb1Zesag">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
            <trigger xmi:id="_h6AQ0qorEeiDp6I37tg_Bw" event="_h6AQ0aorEeiDp6I37tg_Bw" port="_h4WD8KorEeiDp6I37tg_Bw"/>
          </transition>
          <transition xmi:id="_i9e1YMYoEeaYV5cb1Zesag" name="OCCUPIED__OCCUPIED__27" source="_GOTbgMYlEeaYV5cb1Zesag" target="_GOTbgMYlEeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_yidmMMYoEeaYV5cb1Zesag">
              <language>C++</language>
              <body>    log.show(&quot;Impossible to activate the switch of %s: the switch gate is obstructed by a parcel\n&quot;, this->getName());

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED__OCCUPIED__27&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_oHSAwMYoEeaYV5cb1Zesag" event="_cjDs4MM5EeahHehXumVB-w" port="_gMZLEMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_h5zcgKorEeiDp6I37tg_Bw" event="_h5y1cKorEeiDp6I37tg_Bw" port="_h4WD8KorEeiDp6I37tg_Bw"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_yUOoQMM7EeahHehXumVB-w" name="Pseudo4"/>
          <subvertex xmi:type="uml:State" xmi:id="_yUSSoMM7EeahHehXumVB-w" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_h5nPQKorEeiDp6I37tg_Bw" name="IDLE__21">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_h5n2UKorEeiDp6I37tg_Bw" name="IDLE__22">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_GOTbgMYlEeaYV5cb1Zesag" name="OCCUPIED">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_h5pEcKorEeiDp6I37tg_Bw" name="OCCUPIED__23">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_h5prgKorEeiDp6I37tg_Bw" name="OCCUPIED__24">
              <language>C++</language>
              <body>
Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_h5i90KorEeiDp6I37tg_Bw" name="Observation__sendEvent" specification="_h4ZHQKorEeiDp6I37tg_Bw">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_h4ZHQKorEeiDp6I37tg_Bw" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_h5i90KorEeiDp6I37tg_Bw">
        <ownedParameter xmi:id="_h4ZuUKorEeiDp6I37tg_Bw" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h4i4QKorEeiDp6I37tg_Bw" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h4spQKorEeiDp6I37tg_Bw" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h43oYKorEeiDp6I37tg_Bw" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h44PcKorEeiDp6I37tg_Bw" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h5D1oKorEeiDp6I37tg_Bw" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h5ONsKorEeiDp6I37tg_Bw" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h5O0wKorEeiDp6I37tg_Bw" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h5QC4KorEeiDp6I37tg_Bw" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h5Qp8KorEeiDp6I37tg_Bw" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_h5bCAKorEeiDp6I37tg_Bw" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_RDfSQMM5EeahHehXumVB-w" name="switchProtocol">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_RDbn4MM5EeahHehXumVB-w" name="switchProtocol">
        <interfaceRealization xmi:id="_RDkx0MM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDiVkMM5EeahHehXumVB-w" contract="_RDiVkMM5EeahHehXumVB-w"/>
        <interfaceRealization xmi:id="_RDsGkMM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDpDQMM5EeahHehXumVB-w" contract="_RDpDQMM5EeahHehXumVB-w"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_RDiVkMM5EeahHehXumVB-w" name="switchProtocol"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_RDlY4MM5EeahHehXumVB-w" name="switchProtocol~">
        <ownedOperation xmi:id="_XR2R8MM5EeahHehXumVB-w" name="setSwitch">
          <ownedParameter xmi:id="_YFqUgMM5EeahHehXumVB-w" name="c">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_RDn1IMM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDlY4MM5EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_RDocMMM5EeahHehXumVB-w" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_RDpDQMM5EeahHehXumVB-w" name="switchProtocolIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_RDtUsMM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDpDQMM5EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_cjDs4MM5EeahHehXumVB-w" operation="_XR2R8MM5EeahHehXumVB-w"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_htzA0KorEeiDp6I37tg_Bw" name="Observation">
      <eAnnotations xmi:id="_htzA0aorEeiDp6I37tg_Bw" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
        <details xmi:id="_htzA0qorEeiDp6I37tg_Bw" key="language" value="umlrt-cpp"/>
      </eAnnotations>
      <packagedElement xmi:type="uml:Package" xmi:id="_htzA06orEeiDp6I37tg_Bw" name="Observation">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_htzA1KorEeiDp6I37tg_Bw" name="Observation">
          <interfaceRealization xmi:id="_huI_EKorEeiDp6I37tg_Bw" client="_htzA1KorEeiDp6I37tg_Bw" supplier="_htzA16orEeiDp6I37tg_Bw" contract="_htzA16orEeiDp6I37tg_Bw"/>
          <interfaceRealization xmi:id="_huI_EaorEeiDp6I37tg_Bw" client="_htzA1KorEeiDp6I37tg_Bw" supplier="_htzA3aorEeiDp6I37tg_Bw" contract="_htzA3aorEeiDp6I37tg_Bw"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_htzA16orEeiDp6I37tg_Bw" name="Observation">
          <ownedOperation xmi:id="_hz9TMKorEeiDp6I37tg_Bw" name="Sensor_detection_detect">
            <ownedParameter xmi:id="_hz9TMaorEeiDp6I37tg_Bw" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
          <ownedOperation xmi:id="_h13-wKorEeiDp6I37tg_Bw" name="Chute_enter_transmit">
            <ownedParameter xmi:id="_h13-waorEeiDp6I37tg_Bw" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
          <ownedOperation xmi:id="_h1_TgKorEeiDp6I37tg_Bw" name="Chute_timer_timeout"/>
          <ownedOperation xmi:id="_h4U10KorEeiDp6I37tg_Bw" name="Bin_enter_transmit">
            <ownedParameter xmi:id="_h4U10aorEeiDp6I37tg_Bw" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
          <ownedOperation xmi:id="_h5t88KorEeiDp6I37tg_Bw" name="Switcher_enter_transmit">
            <ownedParameter xmi:id="_h5t88aorEeiDp6I37tg_Bw" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
          <ownedOperation xmi:id="_h5yOYKorEeiDp6I37tg_Bw" name="Switcher_switchProtocol_setSwitch">
            <ownedParameter xmi:id="_h5yOYaorEeiDp6I37tg_Bw" name="c">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:id="_h6AQ0KorEeiDp6I37tg_Bw" name="Switcher_timer_timeout"/>
          <ownedOperation xmi:id="_h7W7sKorEeiDp6I37tg_Bw" name="Gen_timer_timeout"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_htzA2KorEeiDp6I37tg_Bw" name="Observation~">
          <ownedOperation xmi:id="_htzA2aorEeiDp6I37tg_Bw" name="event">
            <ownedParameter xmi:id="_htzA2qorEeiDp6I37tg_Bw" name="data" type="_htzBEKorEeiDp6I37tg_Bw"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_htzA26orEeiDp6I37tg_Bw" client="_htzA1KorEeiDp6I37tg_Bw" supplier="_htzA2KorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_htzA3KorEeiDp6I37tg_Bw" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_htzA3aorEeiDp6I37tg_Bw" name="ObservationIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_htzA3qorEeiDp6I37tg_Bw" client="_htzA1KorEeiDp6I37tg_Bw" supplier="_htzA3aorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_htzA36orEeiDp6I37tg_Bw" operation="_htzA2aorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_hz96QKorEeiDp6I37tg_Bw" name="Sensor_detection_detect" operation="_hz9TMKorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_h14l0KorEeiDp6I37tg_Bw" name="Chute_enter_transmit" operation="_h13-wKorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_h1_6kKorEeiDp6I37tg_Bw" name="Chute_timer_timeout" operation="_h1_TgKorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_h4U10qorEeiDp6I37tg_Bw" name="Bin_enter_transmit" operation="_h4U10KorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_h5t88qorEeiDp6I37tg_Bw" name="Switcher_enter_transmit" operation="_h5t88KorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_h5y1cKorEeiDp6I37tg_Bw" name="Switcher_switchProtocol_setSwitch" operation="_h5yOYKorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_h6AQ0aorEeiDp6I37tg_Bw" name="Switcher_timer_timeout" operation="_h6AQ0KorEeiDp6I37tg_Bw"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_h7W7saorEeiDp6I37tg_Bw" name="Gen_timer_timeout" operation="_h7W7sKorEeiDp6I37tg_Bw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_htzA4KorEeiDp6I37tg_Bw" name="Observer" classifierBehavior="_htzA6qorEeiDp6I37tg_Bw" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_htzA4aorEeiDp6I37tg_Bw" name="observation" visibility="public" type="_htzA1KorEeiDp6I37tg_Bw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_htzA4qorEeiDp6I37tg_Bw" value="20"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_htzA46orEeiDp6I37tg_Bw" value="20"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_htzA5KorEeiDp6I37tg_Bw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_htzA5aorEeiDp6I37tg_Bw" name="commandTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:id="_htzA5qorEeiDp6I37tg_Bw" name="eventQueue" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_htzA56orEeiDp6I37tg_Bw" name="eventTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:id="_htzA6KorEeiDp6I37tg_Bw" name="isPeriodic">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_htzA6aorEeiDp6I37tg_Bw"/>
        </ownedAttribute>
        <ownedAttribute xmi:id="_h7hTwKorEeiDp6I37tg_Bw" name="parcel" type="_aEoEwML7EeaSH8bbL43htA"/>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_htzA6qorEeiDp6I37tg_Bw" name="ObserverStateMachine" isReentrant="false">
          <region xmi:id="_htzA66orEeiDp6I37tg_Bw" name="Region">
            <transition xmi:id="_htzA7KorEeiDp6I37tg_Bw" name="configure" source="_htzA-qorEeiDp6I37tg_Bw" target="_htzA-6orEeiDp6I37tg_Bw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_htzA7aorEeiDp6I37tg_Bw">
                <language>C++</language>
                <body>int n = config.load();
log.show(&quot;Number of entries: %d\n&quot;, n);

// Socket
this->method = new Socket();
this->method->configure(config.getConfigList());
this->method->connect();

// Text 
this->serializer = new Text();
this->serializer->configure(config.getConfigList());

std::string mode = config.get(&quot;mode&quot;);
std::string periodicity = config.get(&quot;periodicity&quot;);

// If sending events is set as periodic
if (periodicity != &quot;&quot; &amp;&amp; mode == &quot;periodic&quot;) {
	this->isPeriodic = true;
	// Periodicity is set in microseconds
	// Multiplied by 1000 to get nanoseconds
	long nano = (long long)(atol(periodicity.c_str())*1000);
	long seconds = nano/1000000000;
	eventTimer.informEvery(UMLRTTimespec(seconds, (nano-1000000000*seconds)));
}

// Instantiating the command timer
commandTimer.informEvery(UMLRTTimespec(0,500000000));
</body>
              </effect>
            </transition>
            <transition xmi:id="_htzA7qorEeiDp6I37tg_Bw" name="event received" source="_htzA-6orEeiDp6I37tg_Bw" target="_htzA-6orEeiDp6I37tg_Bw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_htzA76orEeiDp6I37tg_Bw">
                <language>C++</language>
                <body>std::string event = this->serializer->serialize(data.event) + &quot;\n&quot;;
if (this->isPeriodic) {
	eventQueue.push_back(event);
}
else {
	this->method->sendData(event);
}</body>
              </effect>
              <trigger xmi:id="_htzA8KorEeiDp6I37tg_Bw" event="_htzA36orEeiDp6I37tg_Bw" port="_htzA4aorEeiDp6I37tg_Bw"/>
            </transition>
            <transition xmi:id="_htzA8aorEeiDp6I37tg_Bw" name="command received" source="_htzA-6orEeiDp6I37tg_Bw" target="_htzA-6orEeiDp6I37tg_Bw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_htzA8qorEeiDp6I37tg_Bw">
                <language>C++</language>
                <body>std::string data = this->method->read();
    if (data != &quot;&quot;) {
    Event evt = this->serializer->parse(data);
    if (evt.getEventSource() == Event::EventSource::Command) {

      std::map&lt;std::string, size_t>::iterator iter;
      std::string sourceName = evt.getSourceName();

      switch(evt.getEventKind()) {
        case Event::EventKind::List:
          // List of capsule parts
          evt.setSourceName(&quot;Observer&quot;);
          for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
            evt.setParam(iter->first, capsuleTypes[iter->first]);
          }
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Show:
          // Show a specific capsule part
          this->method->sendData(this->serializer->serialize(listCapsuleMessage(evt)));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Trigger:
          evt = this->triggerCapsuleMessage(evt);
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        default:
        break;
      }
    }
}

/*std::string data = this->method->read();
    std::stringstream ss;
    if (data != &quot;&quot;) {

        std::istringstream iss(data);
        std::vector&lt;std::string> cmd;
        while (iss) {
            std::string subs;
            iss >> subs; 
            if (iss.str().empty()) {
                cmd.push_back(subs);
            }
        }

        if (cmd.size() == 0)
            return;

        if (cmd.size() > 1 &amp;&amp; cmd[0] == &quot;list&quot; &amp;&amp; cmd[1] == &quot;capsules&quot;) {
            ss  &lt;&lt; &quot;List of capsules:\n&quot;;
            std::map&lt;std::string, size_t>::iterator iter;
            for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; iter->first &lt;&lt; &quot; [&quot;&lt;&lt; capsuleTypes[iter->first]&lt;&lt; &quot;]\n&quot;;
            }
            this->method->sendData(ss.str());
        }
        else if (cmd.size() > 2 &amp;&amp; cmd[0] == &quot;show&quot; &amp;&amp; cmd[1] == &quot;capsule&quot;) {

            printf(&quot;capsule:%s|type:%s\n&quot;, cmd[1].c_str(), capsuleTypes[cmd[2]].c_str());
            if (capsuleTypes[cmd[2]] == &quot;&quot;) {
                printf(&quot;error: %s\n&quot;, capsuleTypes[cmd[2]].c_str());
                return;
            }
            std::string capsuleType = capsuleTypes[cmd[2]];
            ss  &lt;&lt; &quot;Capsule: &quot; &lt;&lt; cmd[2];
            ss  &lt;&lt; &quot; type: &quot; &lt;&lt; capsuleTypes[cmd[2]] &lt;&lt; &quot;\n&quot;;
            ss  &lt;&lt; &quot;List of triggers:\n&quot;;
            if (capsuleType == &quot;Gen&quot;) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; &quot;generate()\n&quot;;
                this->method->sendData(ss.str());
            }
        }

    }*/</body>
              </effect>
              <trigger xmi:id="_htzA86orEeiDp6I37tg_Bw" port="_htzA5aorEeiDp6I37tg_Bw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:id="_htzA9KorEeiDp6I37tg_Bw" name="register capsules" source="_htzA-6orEeiDp6I37tg_Bw" target="_htzA-6orEeiDp6I37tg_Bw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_htzA9aorEeiDp6I37tg_Bw">
                <language>C++</language>
                <body>std::stringstream ss;
    ss &lt;&lt; msg->signal.getSrcPort()->slot->name &lt;&lt; &quot;:&quot; &lt;&lt; msg->signal.getSrcPort()->slot->capsuleIndex;
    printf(&quot;capsule name: %s at port %d\n&quot;, ss.str().c_str(), (int)msg->sapIndex0_);
    capsules[ss.str()] = msg->sapIndex0_;
    capsuleTypes[ss.str()] = msg->signal.getSrcPort()->slot->capsuleClass->name;</body>
              </effect>
              <trigger xmi:id="_htzA9qorEeiDp6I37tg_Bw" port="_htzA4aorEeiDp6I37tg_Bw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_PQtAwOzeEeSRtqCWFwOf8g"/>
              </trigger>
            </transition>
            <transition xmi:id="_htzA96orEeiDp6I37tg_Bw" name="events periodically sent" source="_htzA-6orEeiDp6I37tg_Bw" target="_htzA-6orEeiDp6I37tg_Bw">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_htzA-KorEeiDp6I37tg_Bw" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>unsigned size = this->eventQueue.size();
for (unsigned int i = 0; i &lt; size; i++) {
	this->method->sendData(this->eventQueue.back());
	this->eventQueue.pop_back();
}</body>
              </effect>
              <trigger xmi:id="_htzA-aorEeiDp6I37tg_Bw" port="_htzA56orEeiDp6I37tg_Bw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_htzA-qorEeiDp6I37tg_Bw">
              <name xsi:nil="true"/>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_htzA-6orEeiDp6I37tg_Bw" name="OBSERVING"/>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_htzA_KorEeiDp6I37tg_Bw" name="listCapsuleMessage" specification="_htzA_6orEeiDp6I37tg_Bw">
          <language>C++</language>
          <body>std::string sourceName = evt.getSourceName();
if (sourceName == &quot;Chute&quot;) {
	evt.setParam(&quot;0&quot;, &quot;timer_timeout&quot;);
	evt.setParam(&quot;1&quot;, &quot;enter_transmit&quot;);
}
if (sourceName == &quot;Switcher&quot;) {
	evt.setParam(&quot;0&quot;, &quot;timer_timeout&quot;);
	evt.setParam(&quot;1&quot;, &quot;switchProtocol_setSwitch&quot;);
	evt.setParam(&quot;2&quot;, &quot;enter_transmit&quot;);
}
if (sourceName == &quot;Gen&quot;) {
	evt.setParam(&quot;0&quot;, &quot;timer_timeout&quot;);
}
if (sourceName == &quot;Sensor&quot;) {
	evt.setParam(&quot;0&quot;, &quot;detection_detect&quot;);
}
if (sourceName == &quot;Bin&quot;) {
	evt.setParam(&quot;0&quot;, &quot;enter_transmit&quot;);
}
return evt;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_htzA_aorEeiDp6I37tg_Bw" name="triggerCapsuleMessage" specification="_htzBAqorEeiDp6I37tg_Bw">
          <language>C++</language>
          <body>std::map&lt;std::string, size_t>::iterator iter;
std::string instanceName = evt.getCapsuleInstance(); // name of the instance
std::string capsuleType = &quot;&quot;;     // name of the capsule
std::string opName    = evt.getParam(&quot;operation&quot;);
int portIndex = -1;
for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
if (iter->first == instanceName) {
portIndex = capsules[iter->first];
capsuleType = capsuleTypes[iter->first];
break;
}
}
// For debugging purpose
  printf(&quot;instanceName = %s, capsuleType = %s, portIndex = %d&quot;,      instanceName.c_str(),      capsuleType.c_str(),      (int)portIndex);
if (portIndex == -1) {
printf(&quot;Problem with instanceName = %s&quot;, instanceName.c_str());evt.setParam(&quot;success&quot;, 0);
return evt;
}
if (capsuleType == &quot;Chute&quot;) {
if (opName == &quot;timer_timeout&quot;) {
observation.Chute_timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;enter_transmit&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Chute_enter_transmit(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Switcher&quot;) {
if (opName == &quot;timer_timeout&quot;) {
observation.Switcher_timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;switchProtocol_setSwitch&quot;) {
observation.Switcher_switchProtocol_setSwitch(atoi(evt.getParam(&quot;c&quot;).c_str())).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;enter_transmit&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Switcher_enter_transmit(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Gen&quot;) {
if (opName == &quot;timer_timeout&quot;) {
observation.Gen_timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Sensor&quot;) {
if (opName == &quot;detection_detect&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Sensor_detection_detect(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Bin&quot;) {
if (opName == &quot;enter_transmit&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Bin_enter_transmit(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
return evt;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_htzA_qorEeiDp6I37tg_Bw" name="to_bool" specification="_htzBBaorEeiDp6I37tg_Bw">
          <language>C++</language>
          <body>return strcmp(s.c_str(),&quot;0&quot;) != 0 &amp;&amp; strcmp(s.c_str(), &quot;false&quot;) != 0;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_h7yZgaorEeiDp6I37tg_Bw" name="init_parcel" specification="_h7ih4KorEeiDp6I37tg_Bw">
          <language>C++</language>
          <body>parcel.number = atoi(evt.getParam(prefix + &quot;.number&quot;).c_str());
parcel.level = atoi(evt.getParam(prefix + &quot;.level&quot;).c_str());
parcel.stage = atoi(evt.getParam(prefix + &quot;.stage&quot;).c_str());
</body>
        </ownedBehavior>
        <ownedOperation xmi:id="_htzA_6orEeiDp6I37tg_Bw" name="listCapsuleMessage" concurrency="guarded" method="_htzA_KorEeiDp6I37tg_Bw">
          <ownedParameter xmi:id="_htzBAKorEeiDp6I37tg_Bw" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:id="_htzBAaorEeiDp6I37tg_Bw" name="response" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:id="_htzBAqorEeiDp6I37tg_Bw" name="triggerCapsuleMessage" concurrency="guarded" method="_htzA_aorEeiDp6I37tg_Bw">
          <ownedParameter xmi:id="_htzBA6orEeiDp6I37tg_Bw" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:id="_htzBBKorEeiDp6I37tg_Bw" name="response" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:id="_htzBBaorEeiDp6I37tg_Bw" name="to_bool" concurrency="guarded" method="_htzA_qorEeiDp6I37tg_Bw">
          <ownedParameter xmi:id="_htzBBqorEeiDp6I37tg_Bw" name="s">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:id="_htzBB6orEeiDp6I37tg_Bw" name="result" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:id="_h7ih4KorEeiDp6I37tg_Bw" name="init_parcel" method="_h7yZgaorEeiDp6I37tg_Bw">
          <ownedParameter xmi:id="_h7rEwKorEeiDp6I37tg_Bw" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:id="_h7yZgKorEeiDp6I37tg_Bw" name="prefix">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_htzBCKorEeiDp6I37tg_Bw" name="internal">
        <packagedElement xmi:type="uml:Artifact" xmi:id="_htzBCaorEeiDp6I37tg_Bw" name="Event" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_htzBCqorEeiDp6I37tg_Bw" name="CLIUtils"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_htzBC6orEeiDp6I37tg_Bw" name="Serializer"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_htzBDKorEeiDp6I37tg_Bw" name="Method"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_htzBDaorEeiDp6I37tg_Bw" name="Text" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_htzBDqorEeiDp6I37tg_Bw" name="Socket"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_htzBD6orEeiDp6I37tg_Bw" name="Config"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_htzBEKorEeiDp6I37tg_Bw" name="EventObj"/>
      <profileApplication xmi:id="_htzBEaorEeiDp6I37tg_Bw">
        <eAnnotations xmi:id="_htzBEqorEeiDp6I37tg_Bw" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
        </eAnnotations>
        <appliedProfile href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
      </profileApplication>
      <profileApplication xmi:id="_htzBE6orEeiDp6I37tg_Bw">
        <eAnnotations xmi:id="_htzBFKorEeiDp6I37tg_Bw" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
        </eAnnotations>
        <appliedProfile href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:id="_htzBFaorEeiDp6I37tg_Bw">
        <eAnnotations xmi:id="_htzBFqorEeiDp6I37tg_Bw" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
        </eAnnotations>
        <appliedProfile href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
      </profileApplication>
      <profileApplication xmi:id="_htzBF6orEeiDp6I37tg_Bw">
        <eAnnotations xmi:id="_htzBGKorEeiDp6I37tg_Bw" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
        </eAnnotations>
        <appliedProfile href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
      </profileApplication>
    </packagedElement>
    <profileApplication xmi:id="_nykGUML5EeaSH8bbL43htA">
      <eAnnotations xmi:id="_nyl7gML5EeaSH8bbL43htA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:id="_8dJfAML5EeaSH8bbL43htA">
      <eAnnotations xmi:id="_8dKtIML5EeaSH8bbL43htA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
    <profileApplication xmi:id="_8dLUMML5EeaSH8bbL43htA">
      <eAnnotations xmi:id="_8dL7QML5EeaSH8bbL43htA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_9cQyoML5EeaSH8bbL43htA" base_Class="_9X86YML5EeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_Gu9tEML6EeaSH8bbL43htA" base_Class="_GuPUUML6EeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_Iu5kgML6EeaSH8bbL43htA" base_Class="_IuNA8ML6EeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_LOpkcML6EeaSH8bbL43htA" base_Class="_LOPUwML6EeaSH8bbL43htA"/>
  <UMLRealTime:ProtocolContainer xmi:id="_QrF_AML6EeaSH8bbL43htA" base_Package="_QrBtkML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTMessageSet xmi:id="_QrOh4ML6EeaSH8bbL43htA" base_Interface="_QrKQcML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTMessageSet xmi:id="_QrWdsML6EeaSH8bbL43htA" base_Interface="_QrSzUML6EeaSH8bbL43htA" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_QrckUML6EeaSH8bbL43htA" base_Interface="_QrZhAML6EeaSH8bbL43htA" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_QrgOsML6EeaSH8bbL43htA" base_Collaboration="_Qq5xwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_a5_b8ML6EeaSH8bbL43htA" base_Port="_a5ynoML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_ej0CUML6EeaSH8bbL43htA" base_Port="_ejuiwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_gvt5MML6EeaSH8bbL43htA" base_Port="_gvpnwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_ieknsML6EeaSH8bbL43htA" base_Port="_ieg9UML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_l2SKYML6EeaSH8bbL43htA" base_Port="_l2PuIML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_o94NcML6EeaSH8bbL43htA" base_Property="_o9z8AML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_sW7z8ML6EeaSH8bbL43htA" base_Property="_sW4woML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_uWJ5sML6EeaSH8bbL43htA" base_Property="_uWG2YML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_wXCMUML6EeaSH8bbL43htA" base_Property="_wW-h8ML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_zZAIgML6EeaSH8bbL43htA" base_Property="_zY9sQML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_9hs20cL6EeaSH8bbL43htA" base_Connector="_9hn-UML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_-P8c4sL6EeaSH8bbL43htA" base_Connector="_-P5ZkML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_-9SrEcL6EeaSH8bbL43htA" base_Connector="_-9PnwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_ihRg8ML7EeaSH8bbL43htA" isWired="false" base_Port="_ihPrwML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_sgbRsML7EeaSH8bbL43htA" base_Pseudostate="_sgYOYML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTState xmi:id="_sggKMML7EeaSH8bbL43htA" base_State="_sgeVAML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_sglCsML7EeaSH8bbL43htA" base_Region="_sgSu0ML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_shjTEML7EeaSH8bbL43htA" base_StateMachine="_sgJk4ML7EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_TGQH8ML8EeaSH8bbL43htA" isWired="false" base_Port="_TGKoYML8EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_QkHBsMMEEeaSH8bbL43htA" isWired="false" base_Port="_QkCwQMMEEeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_P-0CoMMMEeaSH8bbL43htA" isWired="false" base_Port="_P-w_UMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_SANSoMMMEeaSH8bbL43htA" base_Pseudostate="_SAMEgMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTState xmi:id="_SAPH0MMMEeaSH8bbL43htA" base_State="_SAN5sMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_SAPu4MMMEeaSH8bbL43htA" base_Region="_SAKPUMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_SBGqkMMMEeaSH8bbL43htA" base_StateMachine="_SAHMAMMMEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_0KCXUsMPEeaSH8bbL43htA" base_Connector="_0KAiIMMPEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_02B6osMPEeaSH8bbL43htA" base_Connector="_02AFcMMPEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_13cUUcMPEeaSH8bbL43htA" base_Connector="_13afIMMPEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_2pYHkMMPEeaSH8bbL43htA" base_Connector="_2pVrUMMPEeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_bKtWgMMQEeaSH8bbL43htA" base_Property="_bKsIYMMQEeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_ex6GsMMQEeaSH8bbL43htA" base_Property="_ex4RgMMQEeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_gzrKIMMQEeaSH8bbL43htA" base_Property="_gzot4MMQEeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_j0w1YMM4EeahHehXumVB-w" base_Class="_jvOOEMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_p187wMM4EeahHehXumVB-w" base_Port="_p1u5UMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_sK-SYMM4EeahHehXumVB-w" base_Port="_sK7PEMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_v-PIoMM4EeahHehXumVB-w" base_Port="_v-KQIMM4EeahHehXumVB-w"/>
  <UMLRealTime:ProtocolContainer xmi:id="_wvSyIMM4EeahHehXumVB-w" base_Package="_wvPHwMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_wvY4wMM4EeahHehXumVB-w" base_Interface="_wvV1cMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_wve_YMM4EeahHehXumVB-w" base_Interface="_wvcjIMM4EeahHehXumVB-w" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_wvke8MM4EeahHehXumVB-w" base_Interface="_wviCsMM4EeahHehXumVB-w" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_wvniQMM4EeahHehXumVB-w" base_Collaboration="_wvKPQMM4EeahHehXumVB-w"/>
  <UMLRealTime:Capsule xmi:id="_AJ77MMM5EeahHehXumVB-w" base_Class="_AJLGMMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_CHYfUMM5EeahHehXumVB-w" base_Port="_CHUN4MM5EeahHehXumVB-w"/>
  <UMLRealTime:Capsule xmi:id="_O_8GIMM5EeahHehXumVB-w" base_Class="_O_UbEMM5EeahHehXumVB-w"/>
  <UMLRealTime:ProtocolContainer xmi:id="_RDhugMM5EeahHehXumVB-w" base_Package="_RDfSQMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_RDkKwMM5EeahHehXumVB-w" base_Interface="_RDiVkMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_RDnOEMM5EeahHehXumVB-w" base_Interface="_RDlY4MM5EeahHehXumVB-w" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_RDrfgMM5EeahHehXumVB-w" base_Interface="_RDpDQMM5EeahHehXumVB-w" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_RDt7wMM5EeahHehXumVB-w" base_Collaboration="_RDbn4MM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_gMcOYMM5EeahHehXumVB-w" base_Port="_gMZLEMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_m5f8QMM5EeahHehXumVB-w" base_Port="_m5dgAMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_0csbgMM5EeahHehXumVB-w" base_Port="_0cp_QMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_3ton0MM5EeahHehXumVB-w" base_Port="_3tk9cMM5EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_8dOjcMM5EeahHehXumVB-w" base_Property="_8dMHMMM5EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_ANxc4MM6EeahHehXumVB-w" base_Property="_ANvnsMM6EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_DptYQMM6EeahHehXumVB-w" base_Property="_Dpq8AMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_GmrfssM6EeahHehXumVB-w" base_Connector="_GmpDcMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_JFkkAsM6EeahHehXumVB-w" base_Connector="_JFiHwMM6EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_KEoNQMM6EeahHehXumVB-w" base_Property="_KElJ8MM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_Ni31wsM6EeahHehXumVB-w" base_Connector="_Ni2AkMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_Q2uzMMM6EeahHehXumVB-w" base_Connector="_Q2rv4MM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_TMfwscM6EeahHehXumVB-w" base_Connector="_TMcGUMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_T-WEYcM6EeahHehXumVB-w" base_Connector="_T-SaAMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_VxL7AMM6EeahHehXumVB-w" base_Port="_VxKF0MM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_fBwHcsM6EeahHehXumVB-w" base_Connector="_fBuSQMM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_mXF9UMM6EeahHehXumVB-w" base_StateMachine="_mXBE0MM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_mXGkYMM6EeahHehXumVB-w" base_Region="_mXBE0cM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_mXHLcMM6EeahHehXumVB-w" base_Pseudostate="_mXBE18M6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTState xmi:id="_mXHygMM6EeahHehXumVB-w" base_State="_mXBE2MM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_IdGZUMM7EeahHehXumVB-w" base_StateMachine="_IdCu8MM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_IdHAYMM7EeahHehXumVB-w" base_Region="_IdCu8cM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_IdHncMM7EeahHehXumVB-w" base_Pseudostate="_IdDWBcM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTState xmi:id="_IdHnccM7EeahHehXumVB-w" base_State="_IdDWBsM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_yUREgMM7EeahHehXumVB-w" base_Pseudostate="_yUOoQMM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTState xmi:id="_yUTgwMM7EeahHehXumVB-w" base_State="_yUSSoMM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_yUUu4MM7EeahHehXumVB-w" base_Region="_yUMMAMM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_yVXQsMM7EeahHehXumVB-w" base_StateMachine="_yUE3QMM7EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_uL4n8MM9EeahHehXumVB-w" isWired="false" base_Port="_uL2LsMM9EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_qxaXcMX2EeaYV5cb1Zesag" isWired="false" base_Port="_qxGOYMX2EeaYV5cb1Zesag"/>
  <UMLRealTime:RTPort xmi:id="_x2xQkMX2EeaYV5cb1Zesag" isWired="false" base_Port="_x2tmMMX2EeaYV5cb1Zesag"/>
  <UMLRTStateMachines:RTState xmi:id="_k2x6IMX4EeaYV5cb1Zesag" base_State="_k2uPwMX4EeaYV5cb1Zesag"/>
  <UMLRealTime:RTPort xmi:id="_Wbb1cMX5EeaYV5cb1Zesag" isWired="false" base_Port="_WbYyIMX5EeaYV5cb1Zesag"/>
  <UMLRTStateMachines:RTState xmi:id="_GOUpoMYlEeaYV5cb1Zesag" base_State="_GOTbgMYlEeaYV5cb1Zesag"/>
  <UMLRealTime:RTPort xmi:id="_4c99IMYlEeaYV5cb1Zesag" isWired="false" base_Port="_4c8vAMYlEeaYV5cb1Zesag"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_TuYcgN5nEeakB9CQglrL_g" headerPreface="" base_Class="_aEoEwML7EeaSH8bbL43htA" privateDeclarations="" publicDeclarations=""/>
  <UMLRealTime:Capsule xmi:id="_ht3SQKorEeiDp6I37tg_Bw" base_Class="_htzA4KorEeiDp6I37tg_Bw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_ht35UKorEeiDp6I37tg_Bw" base_Package="_htzA06orEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTMessageSet xmi:id="_ht35UaorEeiDp6I37tg_Bw" base_Interface="_htzA16orEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTMessageSet xmi:id="_ht4gYKorEeiDp6I37tg_Bw" base_Interface="_htzA2KorEeiDp6I37tg_Bw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_ht4gYaorEeiDp6I37tg_Bw" base_Interface="_htzA3aorEeiDp6I37tg_Bw" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_ht4gYqorEeiDp6I37tg_Bw" base_Collaboration="_htzA1KorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_ht5HcKorEeiDp6I37tg_Bw" isNotification="true" isPublish="true" isWired="false" base_Port="_htzA4aorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_ht5HcaorEeiDp6I37tg_Bw" isWired="false" base_Port="_htzA5KorEeiDp6I37tg_Bw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_ht5HcqorEeiDp6I37tg_Bw" base_Pseudostate="_htzA-qorEeiDp6I37tg_Bw"/>
  <UMLRTStateMachines:RTState xmi:id="_ht5ugKorEeiDp6I37tg_Bw" base_State="_htzA-6orEeiDp6I37tg_Bw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_ht5ugaorEeiDp6I37tg_Bw" base_Region="_htzA66orEeiDp6I37tg_Bw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_ht5ugqorEeiDp6I37tg_Bw" base_StateMachine="_htzA6qorEeiDp6I37tg_Bw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_ht9Y4KorEeiDp6I37tg_Bw" headerPreface="#include &quot;Method.hh&quot;&#xA;#include &quot;Socket.hh&quot;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Text.hh&quot;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;#include &quot;Config.hh&quot;&#xA;#include &lt;deque>" base_Class="_htzA4KorEeiDp6I37tg_Bw" privateDeclarations="Method* method;&#xA;Serializer* serializer;&#xA;std::map&lt;std::string, size_t> capsules;&#xA;std::map&lt;std::string, std::string> capsuleTypes;&#xA;Config config;"/>
  <UMLRealTime:RTPort xmi:id="_ht9_8KorEeiDp6I37tg_Bw" isWired="false" base_Port="_htzA5aorEeiDp6I37tg_Bw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_ht_OEKorEeiDp6I37tg_Bw" headerPreface="#include &quot;Event.hh&quot;" implementationPreface="" base_Class="_htzBEKorEeiDp6I37tg_Bw" publicDeclarations="Event event;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_ht_1IKorEeiDp6I37tg_Bw" base_Artifact="_htzBCaorEeiDp6I37tg_Bw" includeFile="/*&#xA; * Event.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef EVENT_HH_&#xA;#define EVENT_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;&#xA;class Event {&#xA;&#xA;public:&#xA;typedef enum {&#xA;&#x9;&#x9;Signal,&#xA;&#x9;&#x9;Method,&#xA;&#x9;&#x9;ActionCode,&#xA;&#x9;&#x9;Transition,&#xA;&#x9;&#x9;State,&#xA;&#x9;&#x9;Capsule,&#xA;&#x9;&#x9;Attribute,&#xA;&#x9;&#x9;Timer,&#xA;&#x9;&#x9;UnknownSource, Command&#xA;&#x9;} EventSource;&#xA;&#xA;&#x9;typedef enum {&#xA;&#x9;&#x9;SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;&#x9;&#x9;MethodCall,&#xA;&#x9;&#x9;MethodCallReceive,&#xA;&#x9;&#x9;MethodStartExecute,&#xA;&#x9;&#x9;MethodReturn,&#xA;&#x9;&#x9;MethodFailed,&#xA;&#x9;&#x9;MethodReturnReceived, // Method events&#xA;&#x9;&#x9;ActionStart,&#xA;&#x9;&#x9;ActionEnd, // Action code events&#xA;&#x9;&#x9;TransitionStart,&#xA;&#x9;&#x9;TransitionEnd, // Transition events&#xA;&#x9;&#x9;StateEntryStart,&#xA;&#x9;&#x9;StateEntryEnd,&#xA;&#x9;&#x9;StateExitStart,&#xA;&#x9;&#x9;StateExitEnd,&#xA;&#x9;&#x9;StateIdleStart,&#xA;&#x9;&#x9;StateIdleEnd, // State events&#xA;&#x9;&#x9;CapsuleInstantiate,&#xA;&#x9;&#x9;CapsuleFree, // Capsule events&#xA;&#x9;&#x9;AttributeInstantiate,&#xA;&#x9;&#x9;AttributeFree,&#xA;&#x9;&#x9;AttributeChange, // Attribute events&#xA;&#x9;&#x9;TimerStart,&#xA;&#x9;&#x9;TimerSet,&#xA;&#x9;&#x9;TimerCancel,&#xA;&#x9;&#x9;TimerTimeout, // Timer events&#xA;&#x9;&#x9;UnknownKind, List, Show, Trigger&#xA;&#x9;} EventKind;&#xA;&#xA;private:&#xA;&#x9;std::string capsuleInstance;&#xA;&#x9;std::string sourceName;&#xA;&#x9;std::string eventId;&#xA;&#x9;long seconds;&#xA;&#x9;long nanoseconds;&#xA;&#x9;EventSource eventSource;&#xA;&#x9;EventKind eventKind;&#xA;&#x9;std::map&lt;std::string, std::string> params;&#xA;&#xA;public:&#xA;&#x9;Event(std::string capsuleInstance = &quot;&quot;, std::string sourceName = &quot;&quot;,&#xA;&#x9;&#x9;&#x9;EventSource eventSource = UnknownSource, EventKind eventKind =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;UnknownKind, long seconds = 0, long nanoseconds = 0);&#xA;&#x9;const std::string getCapsuleInstance() const;&#xA;&#x9;void setCapsuleInstance(const std::string capsuleInstance);&#xA;&#x9;const std::string getSourceName() const;&#xA;&#x9;void setSourceName(const std::string sourceName);&#xA;&#x9;const EventSource getEventSource() const;&#xA;&#x9;void setEventSource(const Event::EventSource source);&#xA;&#x9;const EventKind getEventKind() const;&#xA;&#x9;void setEventKind(const Event::EventKind kind);&#xA;&#x9;const long getSeconds() const;&#xA;&#x9;const long getNanoseconds() const;&#xA;&#x9;void setTimestamp();&#xA;&#x9;void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;&#x9;void setSeconds(const long seconds);&#xA;&#x9;void setNanoseconds(const long nanoseconds = 0);&#xA;&#x9;void setEventId(const std::string eventId);&#xA;&#x9;const std::string getEventId() const;&#xA;&#x9;void generateEventId();&#xA;&#x9;const std::map&lt;std::string, std::string> getParams() const;&#xA;&#x9;const std::string getParam(std::string key) const;&#xA;&#x9;void setParams(const std::map&lt;std::string, std::string> params);&#xA;&#x9;void setParam(const std::string key, const std::string value);&#xA;&#x9;void setParam(const std::string key, const int value);&#xA;&#x9;void clearParams();&#xA;};&#xA;&#xA;#endif /* EVENT_HH_ */" sourceFile="/*&#xA; * Event.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;&#xA;Event::Event(std::string capsuleInstance, std::string sourceName,&#xA;&#x9;&#x9;EventSource eventSource, EventKind eventKind, long seconds,&#xA;&#x9;&#x9;long nanoseconds) {&#xA;&#xA;&#x9;this->generateEventId();&#xA;&#x9;this->setCapsuleInstance(capsuleInstance);&#xA;&#x9;this->setSourceName(sourceName);&#xA;&#x9;this->setEventSource(eventSource);&#xA;&#x9;this->setEventKind(eventKind);&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;&#x9;return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;&#x9;this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;const std::string Event::getSourceName() const {&#xA;&#x9;return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;&#x9;this->sourceName = sourceName;&#xA;}&#xA;&#xA;const Event::EventSource Event::getEventSource() const {&#xA;&#x9;return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;&#x9;this->eventSource = source;&#xA;}&#xA;&#xA;const Event::EventKind Event::getEventKind() const {&#xA;&#x9;return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;&#x9;this->eventKind = kind;&#xA;}&#xA;&#xA;const long Event::getSeconds() const {&#xA;&#x9;return this->seconds;&#xA;}&#xA;&#xA;const long Event::getNanoseconds() const {&#xA;&#x9;return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;&#x9;setSeconds(seconds);&#xA;&#x9;this->setNanoseconds(nanoseconds);&#xA;&#x9;this->seconds = seconds;&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;&#x9;this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;&#x9;return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;&#x9;this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;std::stringstream ss;&#xA;&#x9;int r;&#xA;&#x9;r = random();&#xA;&#xA;&#x9;ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;&#x9;this->eventId = ss.str();&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;&#x9;return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;&#x9;bool n = this->params.count(key);&#xA;&#x9;return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const std::map&lt;std::string, std::string> params) {&#xA;&#x9;this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const std::string value) {&#xA;&#x9;if (key.length() >= 1)&#xA;&#x9;&#x9;this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const int value) {&#xA;&#x9;std::stringstream v;&#xA;&#x9;v &lt;&lt; value;&#xA;&#x9;this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;&#x9;this->params.clear();&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_huAcMKorEeiDp6I37tg_Bw" base_Artifact="_htzBCqorEeiDp6I37tg_Bw" includeFile="/*&#xA; * CLIUtils.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CLIUTILS_HH_&#xA;#define CLIUTILS_HH_&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str);&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd);&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;#endif /* CLIUTILS_HH_ */" sourceFile="/*&#xA; * CLIUtils.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str) {&#xA;&#x9;size_t strBegin = str.find_first_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;if (strBegin == std::string::npos)&#xA;&#x9;&#x9;return &quot;&quot;; // no content&#xA;&#xA;&#x9;size_t strEnd = str.find_last_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;size_t strRange = strEnd - strBegin + 1;&#xA;&#x9;return str.substr(strBegin, strRange);&#xA;}&#xA;&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd) {&#xA;&#x9;std::vector&lt;std::string> cmdTokens;&#xA;&#xA;&#x9;std::string command = trim(cmd);&#xA;&#xA;&#x9;if (command.length() == 0)&#xA;&#x9;&#x9;return cmdTokens;&#xA;&#xA;&#x9;std::string tempS = &quot;&quot;;&#xA;&#x9;bool newVar = false;&#xA;&#x9;bool quotation = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; command.length(); i++) {&#xA;&#xA;&#x9;&#x9;char c = command[i];&#xA;&#x9;&#x9;bool isSpaceOrEOL = (c == ' ' || c == '\n');&#xA;&#xA;&#x9;&#x9;if (isSpaceOrEOL) {&#xA;&#xA;&#x9;&#x9;&#x9;if (!newVar)&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (c == '&quot;') {&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;// open a quotation&#xA;&#x9;&#x9;&#x9;&#x9;quotation = true;&#xA;&#x9;&#x9;&#x9;&#x9;if (newVar) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;quotation = false;&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newVar)&#xA;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#xA;&#x9;return cmdTokens;&#xA;}&#xA;&#xA;}&#xA;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_huAcMaorEeiDp6I37tg_Bw" base_Artifact="_htzBC6orEeiDp6I37tg_Bw" includeFile="/*&#xA; * Serializer.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SERIALIZER_HH_&#xA;#define SERIALIZER_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;public:&#xA;&#x9;Serializer();&#xA;&#x9;virtual ~Serializer();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const std::string serialize(const Event event) const = 0;&#xA;&#x9;virtual Event parse(const std::string data) const = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* SERIALIZER_HH_ */" sourceFile="/*&#xA; * Serializer.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;&#xA;Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_huBDQKorEeiDp6I37tg_Bw" base_Artifact="_htzBDKorEeiDp6I37tg_Bw" includeFile="/*&#xA; * Method.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef METHOD_HH_&#xA;#define METHOD_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Method {&#xA;&#xA;public:&#xA;&#x9;Method();&#xA;&#x9;virtual ~Method();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect() = 0;&#xA;&#x9;virtual void disconnect() = 0;&#xA;&#x9;virtual std::string read() = 0;&#xA;&#x9;virtual void sendData(std::string) = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* METHOD_HH_ */&#xA;" sourceFile="/*&#xA; * Method.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;const bool Method::canConnect() const {&#xA;&#x9;return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_huBDQaorEeiDp6I37tg_Bw" base_Artifact="_htzBDaorEeiDp6I37tg_Bw" includeFile="/*&#xA; * Text.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef TEXT_HH_&#xA;#define TEXT_HH_&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Event.hh&quot;&#xA;#include &lt;string>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;unistd.h>&#xA;&#xA;class Text: public Serializer {&#xA;&#xA;private:&#xA;&#x9;std::string format;&#xA;&#xA;&#x9;// separators&#xA;&#x9;char separator;&#xA;&#x9;char paramSeparator;&#xA;&#x9;char keyValueSeparator;&#xA;&#xA;&#x9;std::vector&lt;std::string> fields;&#xA;&#x9;unsigned int fieldNumber;&#xA;&#x9;const std::vector&lt;std::string> split(const std::string data,&#xA;&#x9;&#x9;&#x9;const char separator) const;&#xA;&#xA;protected:&#xA;&#x9;const std::string getField(const std::string field,&#xA;&#x9;&#x9;&#x9;const Event&amp; event) const;&#xA;&#x9;void setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;&#x9;Event&amp; event) const;&#xA;&#xA;public:&#xA;&#x9;Text();&#xA;&#x9;virtual ~Text();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const std::string serialize(const Event event) const;&#xA;&#x9;const std::string serializeParams(const Event event) const;&#xA;&#x9;virtual Event parse(const std::string data) const;&#xA;&#x9;void parseParameters(Event&amp; event, const std::string data) const;&#xA;&#x9;void setFormat(const std::string format);&#xA;&#x9;const std::string getFormat() const;&#xA;&#x9;void setSeparator(const char separator);&#xA;&#x9;void setParamSeparator(const char paramSeparator);&#xA;&#x9;void setKeyValueSeparator(const char keyValueSeparator);&#xA;};&#xA;&#xA;#endif /* TEXT_HH_ */" sourceFile="/*&#xA; * Text.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Text.hh&quot;&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;iostream>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;algorithm>&#xA;&#xA;Text::Text() :&#xA;&#x9;&#x9;Serializer() {&#xA;&#x9;this->setSeparator('|');&#xA;&#x9;this->setParamSeparator(';');&#xA;&#x9;this->setKeyValueSeparator(':');&#xA;&#x9;this->setFormat(&#xA;&#x9;&#x9;&#x9;&quot;eventId|sourceName|capsuleInstance|eventSource|eventKind|seconds|nanoseconds|params&quot;);&#xA;}&#xA;&#xA;Text::~Text() {&#xA;}&#xA;&#xA;void Text::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#x9;std::string separator, paramSeparator, keyValueSeparator, format;&#xA;&#xA;&#x9;separator = this->getConfig(configList, &quot;text.separator&quot;);&#xA;&#x9;paramSeparator = this->getConfig(configList, &quot;text.paramSeparator&quot;);&#xA;&#x9;keyValueSeparator = this->getConfig(configList, &quot;text.keyValueSeparator&quot;);&#xA;&#x9;format = this->getConfig(configList, &quot;text.format&quot;);&#xA;&#xA;&#x9;if (!separator.empty())&#xA;&#x9;&#x9;this->setSeparator(separator[0]);&#xA;&#xA;&#x9;if (!paramSeparator.empty())&#xA;&#x9;&#x9;this->setParamSeparator(paramSeparator[0]);&#xA;&#xA;&#x9;if (!keyValueSeparator.empty())&#xA;&#x9;&#x9;this->setKeyValueSeparator(keyValueSeparator[0]);&#xA;&#xA;&#x9;if (!format.empty())&#xA;&#x9;&#x9;this->setFormat(format);&#xA;&#xA;}&#xA;&#xA;void Text::setFormat(const std::string format) {&#xA;&#x9;this->format = format;&#xA;&#x9;std::vector&lt;std::string> v = this->split(format, this->separator);&#xA;&#xA;&#x9;if (!v.size())&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;this->fields.clear();&#xA;&#x9;this->fields = v;&#xA;&#x9;this->fieldNumber = this->fields.size();&#xA;}&#xA;&#xA;const std::string Text::getFormat() const {&#xA;&#x9;return this->format;&#xA;}&#xA;&#xA;void Text::setSeparator(const char separator) {&#xA;&#x9;this->separator = separator;&#xA;}&#xA;&#xA;void Text::setParamSeparator(const char paramSeparator) {&#xA;&#x9;this->paramSeparator = paramSeparator;&#xA;}&#xA;&#xA;void Text::setKeyValueSeparator(const char keyValueSeparator) {&#xA;&#x9;this->keyValueSeparator = keyValueSeparator;&#xA;}&#xA;&#xA;const std::string Text::serialize(Event event) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it1;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#xA;&#x9;for (it1 = v.begin(); it1 != v.end(); ++it1) {&#xA;&#x9;&#x9;std::string field = *it1;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;out &lt;&lt; this->getField(field, event) &lt;&lt; fieldSeparator;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;const std::string Text::serializeParams(Event event) const {&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;// params&#xA;&#x9;std::map&lt;std::string, std::string>::const_iterator it2;&#xA;&#x9;std::map&lt;std::string, std::string> params = event.getParams();&#xA;&#xA;&#x9;if (params.empty())&#xA;&#x9;&#x9;return out.str();&#xA;&#xA;&#x9;it2 = params.begin();&#xA;&#x9;out &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;&#x9;++it2;&#xA;&#xA;&#x9;for (; it2 != params.end(); ++it2) {&#xA;&#x9;&#x9;out &lt;&lt; this->paramSeparator &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; it2->second;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;Event Text::parse(const std::string data) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;&#x9;std::vector&lt;std::string> values = this->split(data, fieldSeparator);&#xA;&#x9;Event event;&#xA;&#xA;&#x9;if (values.size() &lt; fieldNumber) {&#xA;&#x9;&#x9;std::cout &lt;&lt; &quot;Error in parsing event stream, only &quot; &lt;&lt; values.size()&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; &quot; are parsed \n&quot;;&#xA;&#x9;&#x9;return event;&#xA;&#x9;}&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;for (it = v.begin(); it != v.end(); ++it) {&#xA;&#x9;&#x9;std::string field = *it;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;this->setField(field, values[i], event);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#xA;&#x9;return event;&#xA;}&#xA;&#xA;void Text::parseParameters(Event&amp; event, const std::string data) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v = this->split(data, this->paramSeparator);&#xA;&#x9;std::string temp;&#xA;&#xA;&#x9;if (v.size() == 0)&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;event.clearParams();&#xA;&#xA;&#x9;for (unsigned i = 0; i &lt; v.size(); i++) {&#xA;&#xA;&#x9;&#x9;std::string::size_type sepIndex = 0;&#xA;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;temp = v[i];&#xA;&#xA;&#x9;&#x9;sepIndex = temp.find(this->keyValueSeparator, 0);&#xA;&#x9;&#x9;key = temp.substr(0, sepIndex);&#xA;&#x9;&#x9;value = temp.substr(sepIndex + 1, temp.length());&#xA;&#xA;&#x9;&#x9;event.setParam(key, value);&#xA;&#xA;&#x9;}&#xA;}&#xA;&#xA;const std::vector&lt;std::string> Text::split(const std::string data,&#xA;&#x9;&#x9;const char separator) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v;&#xA;&#x9;std::string temp = &quot;&quot;;&#xA;&#x9;bool newField = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; data.length(); i++) {&#xA;&#x9;&#x9;if (data[i] == separator) {&#xA;&#x9;&#x9;&#x9;newField = false;&#xA;&#x9;&#x9;&#x9;v.push_back(temp);&#xA;&#x9;&#x9;&#x9;temp = &quot;&quot;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;temp = temp + (data[i]);&#xA;&#x9;&#x9;&#x9;newField = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newField)&#xA;&#x9;&#x9;v.push_back(temp);&#xA;&#xA;&#x9;return v;&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the observer&#xA;const std::string Text::getField(const std::string field,&#xA;&#x9;&#x9;const Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;return event.getEventId();&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;return event.getSourceName();&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;return event.getCapsuleInstance();&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventSource();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventKind();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getSeconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getNanoseconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;return this->serializeParams(event);&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Text::setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;event.setEventId(value);&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;event.setSourceName(value);&#xA;        else if (field == &quot;capsuleinstance&quot;)&#xA;                event.setCapsuleInstance(value);&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;event.setEventSource((Event::EventSource) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;event.setEventKind((Event::EventKind) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;event.setSeconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;event.setNanoseconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;this->parseParameters(event, value);&#xA;&#x9;}&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_huBDQqorEeiDp6I37tg_Bw" base_Artifact="_htzBDqorEeiDp6I37tg_Bw" includeFile="/*&#xA; * Socket.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SOCKET_HH_&#xA;#define SOCKET_HH_&#xA;&#xA;#include &lt;arpa/inet.h>&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;sys/select.h>&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Socket: public Method {&#xA;&#xA;private:&#xA;&#x9;int port;&#xA;&#x9;std::string address;&#xA;&#xA;&#x9;fd_set master;    // master file descriptor list&#xA;&#x9;fd_set read_fds;  // temp file descriptor list for select()&#xA;&#x9;int fdmax;        // maximum file descriptor number&#xA;&#xA;&#x9;int listener;     // listening socket descriptor&#xA;&#x9;struct sockaddr_storage remoteaddr; // client address&#xA;&#x9;socklen_t addrlen;&#xA;&#xA;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;struct timeval tv;&#xA;&#xA;public:&#xA;&#x9;Socket();&#xA;&#x9;virtual ~Socket();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect();&#xA;&#x9;virtual void disconnect();&#xA;&#x9;virtual std::string read();&#xA;&#x9;virtual void sendData(std::string data);&#xA;&#xA;&#x9;const int getPort() const;&#xA;&#x9;void setPort(const int port);&#xA;&#xA;&#x9;const std::string getAddress() const;&#xA;&#x9;void setAddress(const std::string address);&#xA;};&#xA;&#xA;#endif /* SOCKET_HH_ */" sourceFile="/*&#xA; * Socket.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Socket.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;string.h>&#xA;#include &lt;unistd.h>&#xA;#include &lt;sys/types.h>&#xA;#include &lt;sys/socket.h>&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;arpa/inet.h>&#xA;#include &lt;netdb.h>&#xA;#include &lt;sstream>&#xA;&#xA;// get sockaddr, IPv4 or IPv6:&#xA;void *get_in_addr(struct sockaddr *sa) {&#xA;&#x9;if (sa->sa_family == AF_INET) {&#xA;&#x9;&#x9;return &amp;(((struct sockaddr_in*) sa)->sin_addr);&#xA;&#x9;}&#xA;&#xA;&#x9;return &amp;(((struct sockaddr_in6*) sa)->sin6_addr);&#xA;}&#xA;&#xA;Socket::Socket() :&#xA;&#x9;&#x9;Method() {&#xA;&#x9;this->setPort(8080);&#xA;&#x9;this->setAddress(&quot;localhost&quot;);&#xA;}&#xA;&#xA;Socket::~Socket() {&#xA;}&#xA;&#xA;void Socket::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;&#x9;std::string port, address;&#xA;&#x9;port = this->getConfig(configList, &quot;port&quot;);&#xA;&#x9;address = this->getConfig(configList, &quot;address&quot;);&#xA;&#xA;&#x9;if (!port.empty())&#xA;&#x9;&#x9;this->setPort(atoi(port.c_str()));&#xA;&#xA;&#x9;if (!address.empty())&#xA;&#x9;&#x9;this->setAddress(address);&#xA;&#xA;&#x9;printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xA;}&#xA;&#xA;const bool Socket::canConnect() const {&#xA;&#x9;return true;&#xA;}&#xA;&#xA;int Socket::connect() {&#xA;&#xA;&#x9;int rv, result = -1;&#xA;&#x9;struct addrinfo hints, *ai, *p;&#xA;&#x9;int yes = 1;   // for setsockopt&#xA;&#xA;&#x9;std::stringstream port;&#xA;&#x9;port &lt;&lt; this->getPort();&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;FD_ZERO(&amp;master);    // clear the master and temp sets&#xA;&#x9;FD_ZERO(&amp;read_fds);&#xA;&#xA;&#x9;// get us a socket and bind it&#xA;&#x9;memset(&amp;hints, 0, sizeof hints);&#xA;&#x9;hints.ai_family = AF_UNSPEC;&#xA;&#x9;hints.ai_socktype = SOCK_STREAM;&#xA;&#x9;hints.ai_flags = AI_PASSIVE;&#xA;&#x9;if ((rv = getaddrinfo(NULL, port.str().c_str(), &amp;hints, &amp;ai)) != 0) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));&#xA;&#x9;&#x9;exit(1);&#xA;&#x9;}&#xA;&#xA;&#x9;for (p = ai; p != NULL; p = p->ai_next) {&#xA;&#x9;&#x9;listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);&#xA;&#x9;&#x9;if (listener &lt; 0) {&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// lose the pesky &quot;address already in use&quot; error message&#xA;&#x9;&#x9;setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));&#xA;&#xA;&#x9;&#x9;if (bind(listener, p->ai_addr, p->ai_addrlen) &lt; 0) {&#xA;&#x9;&#x9;&#x9;close(listener);&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#xA;&#x9;&#x9;// if we got here, it means we didn't get bound&#xA;&#x9;if (p == NULL) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);&#xA;&#x9;&#x9;exit(2);&#xA;&#x9;}&#xA;&#xA;&#x9;freeaddrinfo(ai); // all done with this&#xA;&#xA;&#x9;// listen&#xA;&#x9;if (listen(listener, 10) == -1) {&#xA;&#x9;&#x9;perror(&quot;listen&quot;);&#xA;&#x9;&#x9;exit(3);&#xA;&#x9;}&#xA;&#xA;&#x9;// add the listener to the master set&#xA;&#x9;FD_SET(listener, &amp;master);&#xA;&#xA;&#x9;// keep track of the biggest file descriptor&#xA;&#x9;fdmax = listener; // so far, it's this one&#xA;&#xA;&#x9;return result;&#xA;&#xA;}&#xA;&#xA;void Socket::disconnect() {&#xA;}&#xA;&#xA;std::string Socket::read() {&#xA;&#xA;&#x9;// main loop&#xA;&#x9;read_fds = master; // copy it&#xA;&#x9;int rc = select(fdmax + 1, &amp;read_fds, NULL, NULL, &amp;tv);&#xA;&#x9;if (rc == -1) {&#xA;&#x9;&#x9;perror(&quot;select&quot;);&#xA;&#x9;&#x9;exit(4);&#xA;&#x9;}&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;if (rc == 0) {&#xA;&#x9;&#x9;//   printf(&quot;timeout\n&quot;);&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;// run through the existing connections looking for data to read&#xA;&#x9;for (i = 0; i &lt;= fdmax; i++) {&#xA;&#x9;&#x9;if (FD_ISSET(i, &amp;read_fds)) { // we got one!!&#xA;&#x9;&#x9;&#x9;if (i == listener) {&#xA;&#x9;&#x9;&#x9;&#x9;// handle new connections&#xA;&#x9;&#x9;&#x9;&#x9;addrlen = sizeof remoteaddr;&#xA;&#x9;&#x9;&#x9;&#x9;int newfd = accept(listener, (struct sockaddr *) &amp;remoteaddr,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;addrlen);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (newfd == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;accept&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_SET(newfd, &amp;master); // add to master set&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newfd > fdmax) {    // keep track of the max&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fdmax = newfd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;new connection from %s on &quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;socket %d\n&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inet_ntop(remoteaddr.ss_family,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;get_in_addr((struct sockaddr*) &amp;remoteaddr),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;remoteIP, INET6_ADDRSTRLEN), newfd);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;char buf[256];    // buffer for client data&#xA;&#x9;&#x9;&#x9;&#x9;int nbytes;&#xA;&#x9;&#x9;&#x9;&#x9;// handle data from a client&#xA;&#x9;&#x9;&#x9;&#x9;if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// got error or connection closed by client&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// connection closed&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;socket %d hung up\n&quot;, i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;recv&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;close(i); // bye!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_CLR(i, &amp;master); // remove from master set&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::string str(buf, buf + nbytes - 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return str;&#xA;//    printf(&quot;new data: %s\n&quot;, buf);&#xA;//    // we got some data from a client&#xA;//    int j = 0;&#xA;//    for(j = 0; j &lt;= fdmax; j++) {&#xA;//        // send to everyone!&#xA;//        if (FD_ISSET(j, &amp;master)) {&#xA;//            // except the listener and ourselves&#xA;//            if (j != listener &amp;&amp; j != i) {&#xA;//                if (send(j, buf, nbytes, 0) == -1) {&#xA;//                    perror(&quot;send&quot;);&#xA;//                }&#xA;//            }&#xA;//        }&#xA;//    }&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} // END handle data from client&#xA;&#x9;&#x9;} // END got new incoming connection&#xA;&#x9;} // END looping through file descriptors&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Socket::sendData(std::string data) {&#xA;&#x9;int j = 0;&#xA;&#x9;for (j = 0; j &lt;= fdmax; j++) {&#xA;&#x9;&#x9;// send to everyone&#xA;&#x9;&#x9;if (FD_ISSET(j, &amp;master)) {&#xA;&#x9;&#x9;&#x9;// no exception&#xA;&#x9;&#x9;&#x9;if (j != listener) {&#xA;&#x9;&#x9;&#x9;&#x9;if (write(j, data.c_str(), data.length()) == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//    perror(&quot;does not work\n&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;const int Socket::getPort() const {&#xA;&#x9;return this->port;&#xA;}&#xA;&#xA;void Socket::setPort(const int port) {&#xA;&#x9;this->port = port;&#xA;}&#xA;&#xA;const std::string Socket::getAddress() const {&#xA;&#x9;return this->address;&#xA;}&#xA;&#xA;void Socket::setAddress(const std::string address) {&#xA;&#x9;this->address = address;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_huCRYKorEeiDp6I37tg_Bw" base_Artifact="_htzBD6orEeiDp6I37tg_Bw" includeFile="/*&#xA; * Config.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CONFIG_HH_&#xA;#define CONFIG_HH_&#xA;&#xA;#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;private:&#xA;&#x9;std::string configFileName;&#xA;&#x9;std::string fieldSeparator;&#xA;&#x9;std::string commentStr;&#xA;&#x9;std::string getConfigPath();&#xA;&#x9;std::map&lt;std::string, std::string> configList;&#xA;&#xA;public:&#xA;&#x9;Config();&#xA;&#x9;~Config();&#xA;&#x9;int load();&#xA;&#x9;void append(std::string key, std::string value);&#xA;&#x9;std::string get(std::string key);&#xA;&#x9;void setConfigFileName(const std::string configFileName);&#xA;&#x9;const std::string getConfigFileName() const;&#xA;&#xA;&#x9;void setFieldSeparator(const std::string fieldSeparator);&#xA;&#x9;const std::string getFieldSeparator() const;&#xA;&#xA;&#x9;void setCommentStr(const std::string commentStr);&#xA;&#x9;const std::string getCommentStr() const;&#xA;&#xA;&#x9;const std::map&lt;std::string, std::string> getConfigList() const;&#xA;};&#xA;&#xA;#endif /* CONFIG_HH_ */" sourceFile="/*&#xA; * Config.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Config.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;&#x9;this->setConfigFileName(&quot;config&quot;);&#xA;&#x9;this->setFieldSeparator(&quot;=&quot;);&#xA;&#x9;this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;&#x9;int result = 0;&#xA;&#x9;std::string prefix = &quot;&quot;;&#xA;&#x9;std::string configPath = this->getConfigPath();&#xA;&#x9;std::ifstream configFile(configPath.c_str());&#xA;&#x9;std::string line;&#xA;&#xA;&#x9;if (configFile.is_open()) {&#xA;&#x9;&#x9;while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;&#x9;// skip the space and comment line&#xA;&#x9;&#x9;&#x9;std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex])&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;!= std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;&#x9;&#x9;&#x9;// Check if it is a definition of a specific rule&#xA;&#x9;&#x9;&#x9;std::string::size_type prefixIndex = line.find(&quot;[&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (prefixIndex != std::string::npos) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;&#x9;&#x9;&#x9;&#x9;std::string p = line.substr(valueNonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#x9;&#x9;&#x9;&#x9;prefix = p;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;&#x9;&#x9;&#x9;if (sepIndex + 1 == line.length())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (valueNonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;&#x9;&#x9;&#x9;if (!prefix.empty())&#xA;&#x9;&#x9;&#x9;&#x9;key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key, value);&#xA;&#x9;&#x9;&#x9;printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; std::endl;&#xA;&#x9;&#x9;result = -1;&#xA;&#x9;}&#xA;&#x9;configFile.close();&#xA;&#x9;return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;&#x9;std::string path;&#xA;&#xA;&#x9;ssize_t len = ::readlink(&quot;/proc/self/exe&quot;, result, sizeof(result));&#xA;&#x9;if (len != -1) {&#xA;&#x9;&#x9;path = std::string(result);&#xA;&#x9;}&#xA;&#xA;// find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;// remove the last fragment of the path&#xA;&#x9;path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;// return the full path&#xA;&#x9;return (path != &quot;&quot;) ?&#xA;&#x9;&#x9;&#x9;path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;&#x9;this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;&#x9;return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;&#x9;this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;&#x9;return this->fieldSeparator;&#xA;}&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;&#x9;this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;&#x9;return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
  <RTCppProperties:AttributeProperties xmi:id="_huC4cKorEeiDp6I37tg_Bw" type="std::deque&lt;std::string>" base_Property="_htzA5qorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_huDfgKorEeiDp6I37tg_Bw" isWired="false" base_Port="_htzA56orEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_huDfgaorEeiDp6I37tg_Bw" type="Event" base_Parameter="_htzBAKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_huEGkKorEeiDp6I37tg_Bw" type="Event" base_Parameter="_htzBAaorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_huEtoKorEeiDp6I37tg_Bw" type="Event" base_Parameter="_htzBA6orEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_huEtoaorEeiDp6I37tg_Bw" type="Event" base_Parameter="_htzBBKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_huFUsKorEeiDp6I37tg_Bw" type="std::string" base_Parameter="_htzBBqorEeiDp6I37tg_Bw"/>
  <UMLRealTime:CapsulePart xmi:id="_hxyI8KorEeiDp6I37tg_Bw" base_Property="_huNQgKorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_hx4PkKorEeiDp6I37tg_Bw" isNotification="true" isWired="false" base_Port="_hx0lMKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_hyIuQKorEeiDp6I37tg_Bw" type="Event::EventSource" base_Parameter="_hyEc0KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_hyfTkKorEeiDp6I37tg_Bw" type="Event::EventKind" base_Parameter="_hycQQKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_hysu8KorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_hyrg0KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_hy5jQKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_hy3uEKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_hzFJcKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_hzD7UKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_hzSk0KorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_hzRWsKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_hzeLAKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_hzc84KorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_h0I5YKorEeiDp6I37tg_Bw" isNotification="true" isWired="false" base_Port="_h0HrQKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h0PnEKorEeiDp6I37tg_Bw" type="Event::EventSource" base_Parameter="_h0OY8KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h0cbYKorEeiDp6I37tg_Bw" type="Event::EventKind" base_Parameter="_h0amMKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h0pPsKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h0oBkKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h02rEKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h0014KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h1AcEKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h09_0KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h1MCQKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h1K0IKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h1VMMKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h1T-EKorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_h2C94KorEeiDp6I37tg_Bw" isNotification="true" isWired="false" base_Port="_h2BvwKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h2JEgKorEeiDp6I37tg_Bw" type="Event::EventSource" base_Parameter="_h2HPUKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h2UDoKorEeiDp6I37tg_Bw" type="Event::EventKind" base_Parameter="_h2S1gKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h2fp0KorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h2ebsKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h21BAKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h2zL0KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h3AAIKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h2-yAKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h3K_QKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h3KYMKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h3VXUKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h3UJMKorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_h4XSEKorEeiDp6I37tg_Bw" isNotification="true" isWired="false" base_Port="_h4WD8KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h4aVYKorEeiDp6I37tg_Bw" type="Event::EventSource" base_Parameter="_h4ZuUKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h4ktcKorEeiDp6I37tg_Bw" type="Event::EventKind" base_Parameter="_h4i4QKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h4tQUKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h4spQKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h45dkKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h44PcKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h5EcsKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h5D1oKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h5R4EKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h5Qp8KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h5bpEKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h5bCAKorEeiDp6I37tg_Bw"/>
  <UMLRealTime:RTPort xmi:id="_h6Be8KorEeiDp6I37tg_Bw" isNotification="true" isWired="false" base_Port="_h6A34KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h6EiQKorEeiDp6I37tg_Bw" type="Event::EventSource" base_Parameter="_h6D7MKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h6L3AKorEeiDp6I37tg_Bw" type="Event::EventKind" base_Parameter="_h6Ko4KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h6VA8KorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h6UZ4KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h6eK4KorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h6dj0KorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h6nU0KorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h6mGsKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h6ziEKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h6y7AKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h69TEKorEeiDp6I37tg_Bw" type="const char *" base_Parameter="_h68sAKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h72D4KorEeiDp6I37tg_Bw" type="Event" base_Parameter="_h7rEwKorEeiDp6I37tg_Bw"/>
  <RTCppProperties:ParameterProperties xmi:id="_h77jcKorEeiDp6I37tg_Bw" type="std::string" base_Parameter="_h7yZgKorEeiDp6I37tg_Bw"/>
</xmi:XMI>
