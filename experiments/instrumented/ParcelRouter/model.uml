<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Model xmi:id="_nx1tkML5EeaSH8bbL43htA" name="RootElement">
    <eAnnotations xmi:id="_IbhgEML7EeaSH8bbL43htA" source="UMLRT_Default_top">
      <details xmi:id="_IbjVQML7EeaSH8bbL43htA" key="top_name" value="Parcer_Router"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Class" xmi:id="_9X86YML5EeaSH8bbL43htA" name="Parcer_Router" isActive="true">
      <ownedAttribute xmi:id="_o9z8AML6EeaSH8bbL43htA" name="gen" visibility="protected" type="_GuPUUML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_sW4woML6EeaSH8bbL43htA" name="top" visibility="protected" type="_IuNA8ML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_uWG2YML6EeaSH8bbL43htA" name="right" visibility="protected" type="_IuNA8ML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_wW-h8ML6EeaSH8bbL43htA" name="left" visibility="protected" type="_IuNA8ML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_zY9sQML6EeaSH8bbL43htA" name="bin1" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_YaaZIMMQEeaSH8bbL43htA" value="1"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_YaWHsMMQEeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_bKsIYMMQEeaSH8bbL43htA" name="bin2" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_ex4RgMMQEeaSH8bbL43htA" name="bin3" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_gzot4MMQEeaSH8bbL43htA" name="bin0" visibility="protected" type="_LOPUwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_7xxb0Kr2EeiNHY6qjNhZ4w" name="observer" type="_7xdS0Kr2EeiNHY6qjNhZ4w" aggregation="composite"/>
      <ownedConnector xmi:id="_9hn-UML6EeaSH8bbL43htA" name="RTConnector1">
        <end xmi:id="_9hsPwML6EeaSH8bbL43htA" partWithPort="_o9z8AML6EeaSH8bbL43htA" role="_a5ynoML6EeaSH8bbL43htA"/>
        <end xmi:id="_9hs20ML6EeaSH8bbL43htA" partWithPort="_sW4woML6EeaSH8bbL43htA" role="_ejuiwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_-P5ZkML6EeaSH8bbL43htA" name="RTConnector2">
        <end xmi:id="_-P8c4ML6EeaSH8bbL43htA" partWithPort="_sW4woML6EeaSH8bbL43htA" role="_gvpnwML6EeaSH8bbL43htA"/>
        <end xmi:id="_-P8c4cL6EeaSH8bbL43htA" partWithPort="_uWG2YML6EeaSH8bbL43htA" role="_ejuiwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_-9PnwML6EeaSH8bbL43htA" name="RTConnector3">
        <end xmi:id="_-9SEAML6EeaSH8bbL43htA" partWithPort="_sW4woML6EeaSH8bbL43htA" role="_ieg9UML6EeaSH8bbL43htA"/>
        <end xmi:id="_-9SrEML6EeaSH8bbL43htA" partWithPort="_wW-h8ML6EeaSH8bbL43htA" role="_ejuiwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_0KAiIMMPEeaSH8bbL43htA" name="RTConnector4">
        <end xmi:id="_0KCXUMMPEeaSH8bbL43htA" partWithPort="_uWG2YML6EeaSH8bbL43htA" role="_gvpnwML6EeaSH8bbL43htA"/>
        <end xmi:id="_0KCXUcMPEeaSH8bbL43htA" partWithPort="_ex4RgMMQEeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_02AFcMMPEeaSH8bbL43htA" name="RTConnector5">
        <end xmi:id="_02B6oMMPEeaSH8bbL43htA" partWithPort="_uWG2YML6EeaSH8bbL43htA" role="_ieg9UML6EeaSH8bbL43htA"/>
        <end xmi:id="_02B6ocMPEeaSH8bbL43htA" partWithPort="_bKsIYMMQEeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_13afIMMPEeaSH8bbL43htA" name="RTConnector6">
        <end xmi:id="_13btQMMPEeaSH8bbL43htA" partWithPort="_wW-h8ML6EeaSH8bbL43htA" role="_gvpnwML6EeaSH8bbL43htA"/>
        <end xmi:id="_13cUUMMPEeaSH8bbL43htA" partWithPort="_zY9sQML6EeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_2pVrUMMPEeaSH8bbL43htA" name="RTConnector7">
        <end xmi:id="_2pXggMMPEeaSH8bbL43htA" partWithPort="_wW-h8ML6EeaSH8bbL43htA" role="_ieg9UML6EeaSH8bbL43htA"/>
        <end xmi:id="_2pXggcMPEeaSH8bbL43htA" partWithPort="_gzot4MMQEeaSH8bbL43htA" role="_l2PuIML6EeaSH8bbL43htA"/>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_GuPUUML6EeaSH8bbL43htA" name="Gen" classifierBehavior="_sgJk4ML7EeaSH8bbL43htA" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_a5ynoML6EeaSH8bbL43htA" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ihPrwML7EeaSH8bbL43htA" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_TGKoYML8EeaSH8bbL43htA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_37GIwML8EeaSH8bbL43htA" name="parcel" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_48hwkML8EeaSH8bbL43htA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_48kM0ML8EeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_zN4IcMYtEeaYV5cb1Zesag" name="delay">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_9chtwMYtEeaYV5cb1Zesag" value="8"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_BH5zUMYuEeaYV5cb1Zesag" name="successorFree">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_72VLsKr2EeiNHY6qjNhZ4w" name="observation" visibility="protected" type="_7xdSxKr2EeiNHY6qjNhZ4w" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_72VywKr2EeiNHY6qjNhZ4w" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_72Vywar2EeiNHY6qjNhZ4w" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_sgJk4ML7EeaSH8bbL43htA" name="GenStateMachine" isReentrant="false">
        <region xmi:id="_sgSu0ML7EeaSH8bbL43htA" name="Region">
          <transition xmi:id="_sgjNgML7EeaSH8bbL43htA" name="Initial" source="_sgYOYML7EeaSH8bbL43htA" target="_sgeVAML7EeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_6ZnPEML7EeaSH8bbL43htA">
              <language>C++</language>
              <body>srand(time(0));
timer.informEvery(UMLRTTimespec(4,0));

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo1&quot;,(char *)&quot;GENERATING&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_yYjisML7EeaSH8bbL43htA" name="GENERATING__GENERATING__6" source="_sgeVAML7EeaSH8bbL43htA" target="_sgeVAML7EeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_I7aroML8EeaSH8bbL43htA" name="generation">
              <language>C++</language>
              <body>if (!this->successorFree) {
	log.show(&quot;impossible to generate a new parcel: the first chute is obfuscated\n&quot;);
}
  else {  
    int random = rand() % 4;
    parcel = Parcel();
    parcel.number = random;
    parcel.stage = 0; // 0 for &quot;top&quot;, 1 for &quot;left&quot;, 2 for &quot;right&quot;
    parcel.level = 2;
    enter.transmit(parcel).send();
    log.show(&quot;generating a parcel %d on stage %d\n&quot;, random, parcel.stage);
    this->successorFree = false;
}

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::GENERATING__GENERATING__6&quot;,(char *)&quot;GENERATING&quot;,(char *)&quot;GENERATING&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_1e0JAML7EeaSH8bbL43htA" port="_ihPrwML7EeaSH8bbL43htA">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
            <trigger xmi:id="_73YUkKr2EeiNHY6qjNhZ4w" event="_73Xtgar2EeiNHY6qjNhZ4w" port="_72VLsKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_mEQaEMYdEeaYV5cb1Zesag" name="GENERATING__GENERATING__8" source="_sgeVAML7EeaSH8bbL43htA" target="_sgeVAML7EeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_GNInwMYuEeaYV5cb1Zesag">
              <language>C++</language>
              <body>this->successorFree = free;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::GENERATING__GENERATING__8&quot;,(char *)&quot;GENERATING&quot;,(char *)&quot;GENERATING&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_rdPQ8MYdEeaYV5cb1Zesag" event="_OTwdgMOlEeaV4cHHWddkKg" port="_a5ynoML6EeaSH8bbL43htA"/>
            <trigger xmi:id="_73b-86r2EeiNHY6qjNhZ4w" event="_73b-8qr2EeiNHY6qjNhZ4w" port="_72VLsKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_sgYOYML7EeaSH8bbL43htA" name="Pseudo1"/>
          <subvertex xmi:type="uml:State" xmi:id="_sgeVAML7EeaSH8bbL43htA" name="GENERATING">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_oXPLQKoxEeiNHY6qjNhZ4w" name="GENERATING__2">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::GENERATING&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_oXYVMKoxEeiNHY6qjNhZ4w" name="GENERATING__3">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Gen::GenStateMachine::Region::GENERATING&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_73Rm4Kr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" specification="_72cgcKr2EeiNHY6qjNhZ4w">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_72cgcKr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_73Rm4Kr2EeiNHY6qjNhZ4w">
        <ownedParameter xmi:id="_72dHgKr2EeiNHY6qjNhZ4w" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_72jOIKr2EeiNHY6qjNhZ4w" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_72qi4Kr2EeiNHY6qjNhZ4w" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_72wpgKr2EeiNHY6qjNhZ4w" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_72xQkKr2EeiNHY6qjNhZ4w" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_725zcKr2EeiNHY6qjNhZ4w" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_73C9YKr2EeiNHY6qjNhZ4w" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_73DkcKr2EeiNHY6qjNhZ4w" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_73Dkcar2EeiNHY6qjNhZ4w" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_73ELgKr2EeiNHY6qjNhZ4w" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_73K5MKr2EeiNHY6qjNhZ4w" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_IuNA8ML6EeaSH8bbL43htA" name="Stage" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ejuiwML6EeaSH8bbL43htA" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_gvpnwML6EeaSH8bbL43htA" name="right" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ieg9UML6EeaSH8bbL43htA" name="left" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_Ko_yUML9EeaSH8bbL43htA" name="parcel" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_Ko_yUcL9EeaSH8bbL43htA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_Ko_yUsL9EeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_QkCwQMMEEeaSH8bbL43htA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_8dMHMMM5EeahHehXumVB-w" name="chute1" visibility="protected" type="_jvOOEMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_ANvnsMM6EeahHehXumVB-w" name="chute2" visibility="protected" type="_jvOOEMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_Dpq8AMM6EeahHehXumVB-w" name="sensor" visibility="protected" type="_AJLGMMM5EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedAttribute xmi:id="_KElJ8MM6EeahHehXumVB-w" name="switcher" visibility="protected" type="_O_UbEMM5EeahHehXumVB-w" isOrdered="true" aggregation="composite"/>
      <ownedConnector xmi:id="_GmpDcMM6EeahHehXumVB-w" name="RTConnector1">
        <end xmi:id="_GmrfsMM6EeahHehXumVB-w" partWithPort="_8dMHMMM5EeahHehXumVB-w" role="_v-KQIMM4EeahHehXumVB-w"/>
        <end xmi:id="_GmrfscM6EeahHehXumVB-w" partWithPort="_Dpq8AMM6EeahHehXumVB-w" role="_CHUN4MM5EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_JFiHwMM6EeahHehXumVB-w" name="RTConnector2">
        <end xmi:id="_JFkkAMM6EeahHehXumVB-w" partWithPort="_8dMHMMM5EeahHehXumVB-w" role="_sK7PEMM4EeahHehXumVB-w"/>
        <end xmi:id="_JFkkAcM6EeahHehXumVB-w" partWithPort="_ANvnsMM6EeahHehXumVB-w" role="_p1u5UMM4EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_Ni2AkMM6EeahHehXumVB-w" name="RTConnector3">
        <end xmi:id="_Ni31wMM6EeahHehXumVB-w" partWithPort="_Dpq8AMM6EeahHehXumVB-w" role="_m5dgAMM5EeahHehXumVB-w"/>
        <end xmi:id="_Ni31wcM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_gMZLEMM5EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_Q2rv4MM6EeahHehXumVB-w" name="RTConnector4">
        <end xmi:id="_Q2uMIMM6EeahHehXumVB-w" role="_ejuiwML6EeaSH8bbL43htA"/>
        <end xmi:id="_Q2uMIcM6EeahHehXumVB-w" partWithPort="_8dMHMMM5EeahHehXumVB-w" role="_p1u5UMM4EeahHehXumVB-w"/>
      </ownedConnector>
      <ownedConnector xmi:id="_TMcGUMM6EeahHehXumVB-w" name="RTConnector5">
        <end xmi:id="_TMfJoMM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_0cp_QMM5EeahHehXumVB-w"/>
        <end xmi:id="_TMfwsMM6EeahHehXumVB-w" role="_gvpnwML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_T-SaAMM6EeahHehXumVB-w" name="RTConnector6">
        <end xmi:id="_T-VdUMM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_3tk9cMM5EeahHehXumVB-w"/>
        <end xmi:id="_T-WEYMM6EeahHehXumVB-w" role="_ieg9UML6EeaSH8bbL43htA"/>
      </ownedConnector>
      <ownedConnector xmi:id="_fBuSQMM6EeahHehXumVB-w" name="RTConnector7">
        <end xmi:id="_fBwHcMM6EeahHehXumVB-w" partWithPort="_ANvnsMM6EeahHehXumVB-w" role="_sK7PEMM4EeahHehXumVB-w"/>
        <end xmi:id="_fBwHccM6EeahHehXumVB-w" partWithPort="_KElJ8MM6EeahHehXumVB-w" role="_VxKF0MM6EeahHehXumVB-w"/>
      </ownedConnector>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_LOPUwML6EeaSH8bbL43htA" name="Bin" classifierBehavior="_SAHMAMMMEeaSH8bbL43htA" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_l2PuIML6EeaSH8bbL43htA" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_K51lgMMPEeaSH8bbL43htA" value="1"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_K5yiMMMPEeaSH8bbL43htA" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_LhdrYML9EeaSH8bbL43htA" name="parcels" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_LhdrYcL9EeaSH8bbL43htA"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_LhdrYsL9EeaSH8bbL43htA" value="*"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_P-w_UMMMEeaSH8bbL43htA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_74dSoKr2EeiNHY6qjNhZ4w" name="observation" visibility="protected" type="_7xdSxKr2EeiNHY6qjNhZ4w" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_74egwar2EeiNHY6qjNhZ4w" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_74egwqr2EeiNHY6qjNhZ4w" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_SAHMAMMMEeaSH8bbL43htA" name="BinStateMachine" isReentrant="false">
        <region xmi:id="_SAKPUMMMEeaSH8bbL43htA" name="Region">
          <transition xmi:id="_SAPH0cMMEeaSH8bbL43htA" name="Initial" source="_SAMEgMMMEeaSH8bbL43htA" target="_SAN5sMMMEeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_JNwIoMX4EeaYV5cb1Zesag">
              <language>C++</language>
              <body>enter.setFree(true).send();

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo3&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_YPSEAMMMEeaSH8bbL43htA" name="IDLE__IDLE__34" source="_SAN5sMMMEeaSH8bbL43htA" target="_SAN5sMMMEeaSH8bbL43htA">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mJFFYMMMEeaSH8bbL43htA">
              <language>C++</language>
              <body>    log.show(&quot;%s received Parcel (%d)\n&quot;, getName(), p.number);
    enter.setFree(true).send();


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::IDLE__IDLE__34&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_bX4MoMMMEeaSH8bbL43htA" event="_SR6HoMMBEeaSH8bbL43htA" port="_l2PuIML6EeaSH8bbL43htA"/>
            <trigger xmi:id="_75l7E6r2EeiNHY6qjNhZ4w" event="_75l7Eqr2EeiNHY6qjNhZ4w" port="_74dSoKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_SAMEgMMMEeaSH8bbL43htA" name="Pseudo3"/>
          <subvertex xmi:type="uml:State" xmi:id="_SAN5sMMMEeaSH8bbL43htA" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_od5z8KoxEeiNHY6qjNhZ4w" name="IDLE__31">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_od5z8aoxEeiNHY6qjNhZ4w" name="IDLE__32">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Bin::BinStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_75Zt0Kr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" specification="_74fu4Kr2EeiNHY6qjNhZ4w">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_74fu4Kr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_75Zt0Kr2EeiNHY6qjNhZ4w">
        <ownedParameter xmi:id="_74gV8Kr2EeiNHY6qjNhZ4w" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_74l1gKr2EeiNHY6qjNhZ4w" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_74txUKr2EeiNHY6qjNhZ4w" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_740fAKr2EeiNHY6qjNhZ4w" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_741GEKr2EeiNHY6qjNhZ4w" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_748a0Kr2EeiNHY6qjNhZ4w" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_75HZ8Kr2EeiNHY6qjNhZ4w" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_75IBAKr2EeiNHY6qjNhZ4w" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_75IBAar2EeiNHY6qjNhZ4w" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_75IoEKr2EeiNHY6qjNhZ4w" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_75RK8Kr2EeiNHY6qjNhZ4w" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_QrBtkML6EeaSH8bbL43htA" name="transmission">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_Qq5xwML6EeaSH8bbL43htA" name="transmission">
        <interfaceRealization xmi:id="_QrQXEML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrKQcML6EeaSH8bbL43htA" contract="_QrKQcML6EeaSH8bbL43htA"/>
        <interfaceRealization xmi:id="_QreZgML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrZhAML6EeaSH8bbL43htA" contract="_QrZhAML6EeaSH8bbL43htA"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_QrKQcML6EeaSH8bbL43htA" name="transmission">
        <ownedOperation xmi:id="_NmRscMOlEeaV4cHHWddkKg" name="setFree">
          <ownedParameter xmi:id="_2eSnwMOlEeaV4cHHWddkKg" name="free">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_QrSzUML6EeaSH8bbL43htA" name="transmission~">
        <ownedOperation xmi:id="_PIeRgMMBEeaSH8bbL43htA" name="transmit">
          <ownedParameter xmi:id="_QFxAMMMBEeaSH8bbL43htA" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_QrXr0ML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrSzUML6EeaSH8bbL43htA"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_QrY58ML6EeaSH8bbL43htA" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_QrZhAML6EeaSH8bbL43htA" name="transmissionIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_QrfnoML6EeaSH8bbL43htA" client="_Qq5xwML6EeaSH8bbL43htA" supplier="_QrZhAML6EeaSH8bbL43htA"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_SR6HoMMBEeaSH8bbL43htA" operation="_PIeRgMMBEeaSH8bbL43htA"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_OTwdgMOlEeaV4cHHWddkKg" operation="_NmRscMOlEeaV4cHHWddkKg"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_aEoEwML7EeaSH8bbL43htA" name="Parcel">
      <ownedAttribute xmi:id="_cj_qMML7EeaSH8bbL43htA" name="number" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_2upQ0MMJEeaSH8bbL43htA" name="level">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_wiSxYMMLEeaSH8bbL43htA" value="2"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_BxJI8N5pEeakB9CQglrL_g" name="stage" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_jvOOEMM4EeahHehXumVB-w" name="Chute" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_p1u5UMM4EeahHehXumVB-w" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_sK7PEMM4EeahHehXumVB-w" name="exit" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_v-KQIMM4EeahHehXumVB-w" name="detection" visibility="public" type="_wvKPQMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:id="_4iC8wMM4EeahHehXumVB-w" name="parcel" type="_aEoEwML7EeaSH8bbL43htA">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_8_D6oMM4EeahHehXumVB-w"/>
        <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_8_HlAMM4EeahHehXumVB-w" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_gQNcAMOlEeaV4cHHWddkKg" name="successorFree">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_qxGOYMX2EeaYV5cb1Zesag" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_WbYyIMX5EeaYV5cb1Zesag" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_oc-oIMYhEeaYV5cb1Zesag" name="delay">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_1Wbm0MYhEeaYV5cb1Zesag" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_7x3icKr2EeiNHY6qjNhZ4w" name="observation" visibility="protected" type="_7xdSxKr2EeiNHY6qjNhZ4w" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_7x7z4Kr2EeiNHY6qjNhZ4w" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_7x7z4ar2EeiNHY6qjNhZ4w" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_mXBE0MM6EeahHehXumVB-w" name="ChuteStateMachine" isReentrant="false">
        <region xmi:id="_mXBE0cM6EeahHehXumVB-w" name="Region">
          <transition xmi:id="_mXBE0sM6EeahHehXumVB-w" name="Initial" source="_mXBE18M6EeahHehXumVB-w" target="_mXBE2MM6EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ob628KoxEeiNHY6qjNhZ4w" name="Initial__27">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::Initial&quot;,(char *)&quot;&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_mXBE1MM6EeahHehXumVB-w" name="reception" source="_mXBE2MM6EeahHehXumVB-w" target="_k2uPwMX4EeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mXBE1cM6EeahHehXumVB-w">
              <language>C++</language>
              <body>this->parcel = Parcel();
this->parcel.number = p.number;
this->parcel.level =p.level;
this->parcel.stage = p.stage;

log.show(&quot;Chute %s of stage %d becomes occupied\n&quot;, this->getName(), p.stage);
timer.informIn(UMLRTTimespec(this->delay,0));

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::reception&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_mXBE1sM6EeahHehXumVB-w" event="_SR6HoMMBEeaSH8bbL43htA" port="_p1u5UMM4EeahHehXumVB-w"/>
            <trigger xmi:id="_70PhAKr2EeiNHY6qjNhZ4w" event="_70O58qr2EeiNHY6qjNhZ4w" port="_7x3icKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_nnQiEMOlEeaV4cHHWddkKg" name="IDLE__IDLE__19" source="_mXBE2MM6EeahHehXumVB-w" target="_mXBE2MM6EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_AMB4YMOmEeaV4cHHWddkKg">
              <language>C++</language>
              <body>this->successorFree = free;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::IDLE__IDLE__19&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_8Oj9QMOlEeaV4cHHWddkKg" event="_OTwdgMOlEeaV4cHHWddkKg" port="_sK7PEMM4EeahHehXumVB-w"/>
            <trigger xmi:id="_70A3gKr2EeiNHY6qjNhZ4w" event="_7z14Yqr2EeiNHY6qjNhZ4w" port="_7x3icKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_9Jw84MX4EeaYV5cb1Zesag" name="transmission" source="_k2uPwMX4EeaYV5cb1Zesag" target="_aLwP8MX6EeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_obtbkKoxEeiNHY6qjNhZ4w" name="transmission__23">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::transmission&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;jam ?&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_w7wScMX5EeaYV5cb1Zesag" port="_WbYyIMX5EeaYV5cb1Zesag">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
            <trigger xmi:id="_70FI8Kr2EeiNHY6qjNhZ4w" event="_70Eh4ar2EeiNHY6qjNhZ4w" port="_7x3icKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_DR_fYMX5EeaYV5cb1Zesag" name="OCCUPIED__OCCUPIED__21" source="_k2uPwMX4EeaYV5cb1Zesag" target="_k2uPwMX4EeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_LH2oYMX5EeaYV5cb1Zesag">
              <language>C++</language>
              <body>this->successorFree =free;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::OCCUPIED__OCCUPIED__21&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_I-QeoMX5EeaYV5cb1Zesag" event="_OTwdgMOlEeaV4cHHWddkKg" port="_sK7PEMM4EeahHehXumVB-w"/>
            <trigger xmi:id="_7z2fcKr2EeiNHY6qjNhZ4w" event="_7z14Yqr2EeiNHY6qjNhZ4w" port="_7x3icKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_eK17sMX6EeaYV5cb1Zesag" name="jam ?__IDLE__29" guard="_pg8RQMX6EeaYV5cb1Zesag" source="_aLwP8MX6EeaYV5cb1Zesag" target="_mXBE2MM6EeahHehXumVB-w">
            <ownedRule xmi:id="_pg8RQMX6EeaYV5cb1Zesag">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_pg8RQcX6EeaYV5cb1Zesag">
                <language>C++</language>
                <body>return this->successorFree;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_5gzAMMX6EeaYV5cb1Zesag">
              <language>C++</language>
              <body>	detection.detect(this->parcel).send();
	exit.transmit(this->parcel).send();
	this->successorFree = false;
log.show(&quot;Chute %s of stage %d is now free\n&quot;, this->getName(), this->parcel.stage);

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::jam ?__IDLE__29&quot;,(char *)&quot;jam ?&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_toofYMX6EeaYV5cb1Zesag" name="jam ?__OCCUPIED__25" guard="_z09ewMX6EeaYV5cb1Zesag" source="_aLwP8MX6EeaYV5cb1Zesag" target="_k2uPwMX4EeaYV5cb1Zesag">
            <ownedRule xmi:id="_z09ewMX6EeaYV5cb1Zesag">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_z09ewcX6EeaYV5cb1Zesag">
                <language>C++</language>
                <body>return !this->successorFree;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Br9q0MX7EeaYV5cb1Zesag">
              <language>C++</language>
              <body>log.show(&quot;JAM detected in %s of stage %d\n&quot;, this->getName(), this->parcel.level-1);
timer.informIn(UMLRTTimespec(this->delay,0));

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::jam ?__OCCUPIED__25&quot;,(char *)&quot;jam ?&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_mXBE18M6EeahHehXumVB-w" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_mXBE2MM6EeahHehXumVB-w" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_t4ekIMX4EeaYV5cb1Zesag" name="setFree">
              <language>C++</language>
              <body>enter.setFree(true).send();

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_obO6cKoxEeiNHY6qjNhZ4w" name="IDLE__15">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_k2uPwMX4EeaYV5cb1Zesag" name="OCCUPIED">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_obRWsKoxEeiNHY6qjNhZ4w" name="OCCUPIED__16">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_obR9wKoxEeiNHY6qjNhZ4w" name="OCCUPIED__17">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Chute::ChuteStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_aLwP8MX6EeaYV5cb1Zesag" name="jam ?" kind="choice"/>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_7zsHYKr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" specification="_7yGzAKr2EeiNHY6qjNhZ4w">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_7yGzAKr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_7zsHYKr2EeiNHY6qjNhZ4w">
        <ownedParameter xmi:id="_7yJ2UKr2EeiNHY6qjNhZ4w" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7yZt8Kr2EeiNHY6qjNhZ4w" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7ysB0Kr2EeiNHY6qjNhZ4w" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7yz9oKr2EeiNHY6qjNhZ4w" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7y0ksKr2EeiNHY6qjNhZ4w" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7y8ggKr2EeiNHY6qjNhZ4w" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7zJ74Kr2EeiNHY6qjNhZ4w" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7zKi8Kr2EeiNHY6qjNhZ4w" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7zKi8ar2EeiNHY6qjNhZ4w" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7zLKAKr2EeiNHY6qjNhZ4w" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_7zTs4Kr2EeiNHY6qjNhZ4w" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_wvPHwMM4EeahHehXumVB-w" name="detection">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_wvKPQMM4EeahHehXumVB-w" name="detection">
        <interfaceRealization xmi:id="_wvat8MM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wvV1cMM4EeahHehXumVB-w" contract="_wvV1cMM4EeahHehXumVB-w"/>
        <interfaceRealization xmi:id="_wvltEMM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wviCsMM4EeahHehXumVB-w" contract="_wviCsMM4EeahHehXumVB-w"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_wvV1cMM4EeahHehXumVB-w" name="detection"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_wvcjIMM4EeahHehXumVB-w" name="detection~">
        <ownedOperation xmi:id="_F05S4MM5EeahHehXumVB-w" name="detect">
          <ownedParameter xmi:id="_G2MX0MM5EeahHehXumVB-w" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_wvgNgMM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wvcjIMM4EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_wvhboMM4EeahHehXumVB-w" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_wviCsMM4EeahHehXumVB-w" name="detectionIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_wvmUIMM4EeahHehXumVB-w" client="_wvKPQMM4EeahHehXumVB-w" supplier="_wviCsMM4EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_Mh59cMM5EeahHehXumVB-w" operation="_F05S4MM5EeahHehXumVB-w"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_AJLGMMM5EeahHehXumVB-w" name="Sensor" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_CHUN4MM5EeahHehXumVB-w" name="detection" visibility="public" type="_wvKPQMM4EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_m5dgAMM5EeahHehXumVB-w" name="switchProtocol" visibility="public" type="_RDbn4MM5EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_uL2LsMM9EeahHehXumVB-w" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_73cmAKr2EeiNHY6qjNhZ4w" name="observation" visibility="protected" type="_7xdSxKr2EeiNHY6qjNhZ4w" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_73dNEar2EeiNHY6qjNhZ4w" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_73dNEqr2EeiNHY6qjNhZ4w" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_IdCu8MM7EeahHehXumVB-w" name="SensorStateMachine" isReentrant="false">
        <region xmi:id="_IdCu8cM7EeahHehXumVB-w" name="Region">
          <transition xmi:id="_IdDWAMM7EeahHehXumVB-w" name="Initial" source="_IdDWBcM7EeahHehXumVB-w" target="_IdDWBsM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_oZdY0KoxEeiNHY6qjNhZ4w" name="Initial__12">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::Initial&quot;,(char *)&quot;Pseudo2&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_IdDWAsM7EeahHehXumVB-w" name="IDLE__IDLE__14" source="_IdDWBsM7EeahHehXumVB-w" target="_IdDWBsM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_IdDWA8M7EeahHehXumVB-w">
              <language>C++</language>
              <body>    int reducedNumber = p.number/p.level; 
    int isPair = reducedNumber % 2;
    if (isPair == 0) {
    log.show(&quot;At stage %s (%d), turn left.\n&quot;, getName(), p.level);
    switchProtocol.setSwitch(0).send();
    }
    else {
    log.show(&quot;At stage %s (%d), turn right.\n&quot;, getName(), p.level);
    switchProtocol.setSwitch(1).send();
    }

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::IDLE__IDLE__14&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_PGM0QMM7EeahHehXumVB-w" event="_Mh59cMM5EeahHehXumVB-w" port="_CHUN4MM5EeahHehXumVB-w"/>
            <trigger xmi:id="_74cEgKr2EeiNHY6qjNhZ4w" event="_74bdcqr2EeiNHY6qjNhZ4w" port="_73cmAKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_IdDWBcM7EeahHehXumVB-w" name="Pseudo2"/>
          <subvertex xmi:type="uml:State" xmi:id="_IdDWBsM7EeahHehXumVB-w" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_oZaVgKoxEeiNHY6qjNhZ4w" name="IDLE__9">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_oZa8kKoxEeiNHY6qjNhZ4w" name="IDLE__10">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Sensor::SensorStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_74UIsKr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" specification="_73d0IKr2EeiNHY6qjNhZ4w">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_73d0IKr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_74UIsKr2EeiNHY6qjNhZ4w">
        <ownedParameter xmi:id="_73ebMKr2EeiNHY6qjNhZ4w" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_73lv8Kr2EeiNHY6qjNhZ4w" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_73sdoKr2EeiNHY6qjNhZ4w" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_730ZcKr2EeiNHY6qjNhZ4w" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_730Zcar2EeiNHY6qjNhZ4w" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_737HIKr2EeiNHY6qjNhZ4w" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_74DqAKr2EeiNHY6qjNhZ4w" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_74EREKr2EeiNHY6qjNhZ4w" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_74EREar2EeiNHY6qjNhZ4w" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_74EREqr2EeiNHY6qjNhZ4w" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_74NbAKr2EeiNHY6qjNhZ4w" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Class" xmi:id="_O_UbEMM5EeahHehXumVB-w" name="Switcher" classifierBehavior="_yUE3QMM7EeahHehXumVB-w" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_gMZLEMM5EeahHehXumVB-w" name="switchProtocol" visibility="public" type="_RDbn4MM5EeahHehXumVB-w" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_0cp_QMM5EeahHehXumVB-w" name="right" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_3tk9cMM5EeahHehXumVB-w" name="left" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_VxKF0MM6EeahHehXumVB-w" name="enter" visibility="public" type="_Qq5xwML6EeaSH8bbL43htA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:id="_tx4ecMM7EeahHehXumVB-w" name="choice">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_Yk87wMM9EeahHehXumVB-w" name="parcel" type="_aEoEwML7EeaSH8bbL43htA"/>
      <ownedAttribute xmi:id="_GGZlEMOmEeaV4cHHWddkKg" name="leftSuccessorFree">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_J43KEMOmEeaV4cHHWddkKg" name="rightSuccessorFree">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_x2tmMMX2EeaYV5cb1Zesag" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:id="_b1lNUMYiEeaYV5cb1Zesag" name="delay">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_eEeGwMYiEeaYV5cb1Zesag" value="1"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_4c8vAMYlEeaYV5cb1Zesag" name="timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_70QIEKr2EeiNHY6qjNhZ4w" name="observation" visibility="protected" type="_7xdSxKr2EeiNHY6qjNhZ4w" aggregation="composite" isBehavior="true" isService="false">
        <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_70WOsKr2EeiNHY6qjNhZ4w" value="1"/>
        <upperValue xmi:type="uml:LiteralInteger" xmi:id="_70WOsar2EeiNHY6qjNhZ4w" value="1"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_yUE3QMM7EeahHehXumVB-w" name="SwitcherStateMachine" isReentrant="false">
        <region xmi:id="_yUMMAMM7EeahHehXumVB-w" name="Region">
          <transition xmi:id="_yUTgwcM7EeahHehXumVB-w" name="Initial" source="_yUOoQMM7EeahHehXumVB-w" target="_yUSSoMM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ogq0EKoxEeiNHY6qjNhZ4w" name="Initial__55">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::Initial&quot;,(char *)&quot;&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_2LEW8MM7EeahHehXumVB-w" name="IDLE__IDLE__44" source="_yUSSoMM7EeahHehXumVB-w" target="_yUSSoMM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Ci9gsMM8EeahHehXumVB-w">
              <language>C++</language>
              <body>this->choice = c;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE__IDLE__44&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_82qsQMM7EeahHehXumVB-w" event="_cjDs4MM5EeahHehXumVB-w" port="_gMZLEMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_71-mYar2EeiNHY6qjNhZ4w" event="_71-mYKr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_GIbLgMM8EeahHehXumVB-w" name="reception" source="_yUSSoMM7EeahHehXumVB-w" target="_GOTbgMYlEeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_fAyMMMM8EeahHehXumVB-w">
              <language>C++</language>
              <body>this->parcel = Parcel();
this->parcel.number = p.number;
this->parcel.level = p.level;
this->parcel.stage = p.stage;
log.show(&quot;Switcher %s of stage %d becomes occupied\n&quot;, this->getName(), p.stage);
timer.informIn(UMLRTTimespec(this->delay,0));

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::reception&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_J-RbsMM8EeahHehXumVB-w" event="_SR6HoMMBEeaSH8bbL43htA" port="_VxKF0MM6EeahHehXumVB-w"/>
            <trigger xmi:id="_72UkoKr2EeiNHY6qjNhZ4w" event="_72T9kqr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_ueXm0MX1EeaYV5cb1Zesag" name="IDLE__IDLE__49" source="_yUSSoMM7EeahHehXumVB-w" target="_yUSSoMM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_96BcgMX1EeaYV5cb1Zesag">
              <language>C++</language>
              <body>//log.show(&quot;left successor of switcher becomes free\n&quot;);
this->leftSuccessorFree = free;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE__IDLE__49&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_4FUS8MX1EeaYV5cb1Zesag" event="_OTwdgMOlEeaV4cHHWddkKg" port="_3tk9cMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_72MBwKr2EeiNHY6qjNhZ4w" event="_72Bpsqr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_A2lUQMX2EeaYV5cb1Zesag" name="IDLE__IDLE__57" source="_yUSSoMM7EeahHehXumVB-w" target="_yUSSoMM7EeahHehXumVB-w">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_GFMuMMX2EeaYV5cb1Zesag">
              <language>C++</language>
              <body>//log.show(&quot;right successor of switcher becomes free\n&quot;);
this->rightSuccessorFree = free;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE__IDLE__57&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;IDLE&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_IyVp4MX2EeaYV5cb1Zesag" event="_OTwdgMOlEeaV4cHHWddkKg" port="_0cp_QMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_716U8Kr2EeiNHY6qjNhZ4w" event="_71zAMKr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_TZCXcMYlEeaYV5cb1Zesag" name="Jam ?__OCCUPIED__51" guard="_NQku8MYmEeaYV5cb1Zesag" source="_RQRUIMYlEeaYV5cb1Zesag" target="_GOTbgMYlEeaYV5cb1Zesag">
            <ownedRule xmi:id="_NQku8MYmEeaYV5cb1Zesag">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_NQku8cYmEeaYV5cb1Zesag">
                <language>C++</language>
                <body>bool isFree = (choice == 0) ? this->leftSuccessorFree : this->rightSuccessorFree;
return !isFree;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_89scoMbxEeakjcfRNzjEZw">
              <language>C++</language>
              <body>log.show(&quot;JAM detected in %s of stage %d\n&quot;, this->getName(), this->parcel.level-1);
timer.informIn(UMLRTTimespec(this->delay,0));

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::Jam ?__OCCUPIED__51&quot;,(char *)&quot;Jam ?&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_UO4aUMYlEeaYV5cb1Zesag" name="Jam ?__IDLE__53" guard="_Qkpu0MYmEeaYV5cb1Zesag" source="_RQRUIMYlEeaYV5cb1Zesag" target="_yUSSoMM7EeahHehXumVB-w">
            <ownedRule xmi:id="_Qkpu0MYmEeaYV5cb1Zesag">
              <specification xmi:type="uml:OpaqueExpression" xmi:id="_Qkpu0cYmEeaYV5cb1Zesag">
                <language>C++</language>
                <body>bool isFree = (choice == 0) ? this->leftSuccessorFree : this->rightSuccessorFree;
return isFree;</body>
              </specification>
            </ownedRule>
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_haaLAMYmEeaYV5cb1Zesag">
              <language>C++</language>
              <body>this->parcel.level--;

log.show(&quot;Switcher %s of stage %d is now free\n&quot;, this->getName(), this->parcel.stage);

if (choice == 0) {
	this->parcel.stage = 1;
	left.transmit(this->parcel).send();
	this->leftSuccessorFree = false;
}
else {
	this->parcel.stage = 2;
	right.transmit(this->parcel).send();
	this->rightSuccessorFree = false;
}

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::Jam ?__IDLE__53&quot;,(char *)&quot;Jam ?&quot;,(char *)&quot;IDLE&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
            </effect>
          </transition>
          <transition xmi:id="_BK59oMYmEeaYV5cb1Zesag" name="transmission" source="_GOTbgMYlEeaYV5cb1Zesag" target="_RQRUIMYlEeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_of9pcaoxEeiNHY6qjNhZ4w" name="transmission__46">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::transmission&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;Jam ?&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_E7SfAMYmEeaYV5cb1Zesag" port="_4c8vAMYlEeaYV5cb1Zesag">
              <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
            </trigger>
            <trigger xmi:id="_713RoKr2EeiNHY6qjNhZ4w" event="_712DgKr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_AAZAYMYoEeaYV5cb1Zesag" name="OCCUPIED__OCCUPIED__40" source="_GOTbgMYlEeaYV5cb1Zesag" target="_GOTbgMYlEeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_IFuv0MYoEeaYV5cb1Zesag">
              <language>C++</language>
              <body>//log.show(&quot;right successor of switcher becomes free\n&quot;);
this->rightSuccessorFree = free;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED__OCCUPIED__40&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_D_7YEMYoEeaYV5cb1Zesag" event="_OTwdgMOlEeaV4cHHWddkKg" port="_0cp_QMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_71zAMar2EeiNHY6qjNhZ4w" event="_71zAMKr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_LJ32QMYoEeaYV5cb1Zesag" name="OCCUPIED__OCCUPIED__42" source="_GOTbgMYlEeaYV5cb1Zesag" target="_GOTbgMYlEeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_R25H4MYoEeaYV5cb1Zesag">
              <language>C++</language>
              <body>//log.show(&quot;left successor of switcher becomes free\n&quot;);
this->leftSuccessorFree = free;

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED__OCCUPIED__42&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_PMRUsMYoEeaYV5cb1Zesag" event="_OTwdgMOlEeaV4cHHWddkKg" port="_3tk9cMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_72Bps6r2EeiNHY6qjNhZ4w" event="_72Bpsqr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <transition xmi:id="_i9e1YMYoEeaYV5cb1Zesag" name="OCCUPIED__OCCUPIED__59" source="_GOTbgMYlEeaYV5cb1Zesag" target="_GOTbgMYlEeaYV5cb1Zesag">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_yidmMMYoEeaYV5cb1Zesag">
              <language>C++</language>
              <body>log.show(&quot;Impossible to activate the switch of %s: the switch gate is obstructed by a parcel\n&quot;, this->getName());

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED__OCCUPIED__59&quot;,(char *)&quot;OCCUPIED&quot;,(char *)&quot;OCCUPIED&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
            </effect>
            <trigger xmi:id="_oHSAwMYoEeaYV5cb1Zesag" event="_cjDs4MM5EeahHehXumVB-w" port="_gMZLEMM5EeahHehXumVB-w"/>
            <trigger xmi:id="_72FUEKr2EeiNHY6qjNhZ4w" event="_71-mYKr2EeiNHY6qjNhZ4w" port="_70QIEKr2EeiNHY6qjNhZ4w"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_yUOoQMM7EeahHehXumVB-w" name=""/>
          <subvertex xmi:type="uml:State" xmi:id="_yUSSoMM7EeahHehXumVB-w" name="IDLE">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_gwFREMYlEeaYV5cb1Zesag" name="setFree">
              <language>C++</language>
              <body>enter.setFree(true).send();

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_ofgWcKoxEeiNHY6qjNhZ4w" name="IDLE__38">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::IDLE&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_GOTbgMYlEeaYV5cb1Zesag" name="OCCUPIED">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_ofd6MKoxEeiNHY6qjNhZ4w" name="OCCUPIED__36">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </entry>
            <exit xmi:type="uml:OpaqueBehavior" xmi:id="_ofehQKoxEeiNHY6qjNhZ4w" name="OCCUPIED__37">
              <language>C++</language>
              <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;RootElement::Switcher::SwitcherStateMachine::Region::OCCUPIED&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
            </exit>
          </subvertex>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_RQRUIMYlEeaYV5cb1Zesag" name="Jam ?" kind="choice"/>
        </region>
      </ownedBehavior>
      <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_71qdUKr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" specification="_70YD4Kr2EeiNHY6qjNhZ4w">
        <language>C++</language>
        <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
      </ownedBehavior>
      <ownedOperation xmi:id="_70YD4Kr2EeiNHY6qjNhZ4w" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_71qdUKr2EeiNHY6qjNhZ4w">
        <ownedParameter xmi:id="_70Yq8Kr2EeiNHY6qjNhZ4w" name="source">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_70jqEKr2EeiNHY6qjNhZ4w" name="kind">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_70yTkKr2EeiNHY6qjNhZ4w" name="capsuleInstance">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_709SsKr2EeiNHY6qjNhZ4w" name="capsuleIndex">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedParameter>
        <ownedParameter xmi:id="_709Ssar2EeiNHY6qjNhZ4w" name="signalName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_71LVIKr2EeiNHY6qjNhZ4w" name="capsuleName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_71VGIKr2EeiNHY6qjNhZ4w" name="sourceName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_71VGIar2EeiNHY6qjNhZ4w" name="reserve1">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_71VtMKr2EeiNHY6qjNhZ4w" name="reserve2">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_71VtMar2EeiNHY6qjNhZ4w" name="reserve3">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
        <ownedParameter xmi:id="_71feMKr2EeiNHY6qjNhZ4w" name="reserve4">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedParameter>
      </ownedOperation>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_RDfSQMM5EeahHehXumVB-w" name="switchProtocol">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_RDbn4MM5EeahHehXumVB-w" name="switchProtocol">
        <interfaceRealization xmi:id="_RDkx0MM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDiVkMM5EeahHehXumVB-w" contract="_RDiVkMM5EeahHehXumVB-w"/>
        <interfaceRealization xmi:id="_RDsGkMM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDpDQMM5EeahHehXumVB-w" contract="_RDpDQMM5EeahHehXumVB-w"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_RDiVkMM5EeahHehXumVB-w" name="switchProtocol"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_RDlY4MM5EeahHehXumVB-w" name="switchProtocol~">
        <ownedOperation xmi:id="_XR2R8MM5EeahHehXumVB-w" name="setSwitch">
          <ownedParameter xmi:id="_YFqUgMM5EeahHehXumVB-w" name="c">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Usage" xmi:id="_RDn1IMM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDlY4MM5EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_RDocMMM5EeahHehXumVB-w" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_RDpDQMM5EeahHehXumVB-w" name="switchProtocolIO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_RDtUsMM5EeahHehXumVB-w" client="_RDbn4MM5EeahHehXumVB-w" supplier="_RDpDQMM5EeahHehXumVB-w"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_cjDs4MM5EeahHehXumVB-w" operation="_XR2R8MM5EeahHehXumVB-w"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_7xdSwKr2EeiNHY6qjNhZ4w" name="Observation">
      <eAnnotations xmi:id="_7xdSwar2EeiNHY6qjNhZ4w" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
        <details xmi:id="_7xdSwqr2EeiNHY6qjNhZ4w" key="language" value="umlrt-cpp"/>
      </eAnnotations>
      <packagedElement xmi:type="uml:Package" xmi:id="_7xdSw6r2EeiNHY6qjNhZ4w" name="Observation">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_7xdSxKr2EeiNHY6qjNhZ4w" name="Observation">
          <interfaceRealization xmi:id="_7xu_kKr2EeiNHY6qjNhZ4w" client="_7xdSxKr2EeiNHY6qjNhZ4w" supplier="_7xdSx6r2EeiNHY6qjNhZ4w" contract="_7xdSx6r2EeiNHY6qjNhZ4w"/>
          <interfaceRealization xmi:id="_7xu_kar2EeiNHY6qjNhZ4w" client="_7xdSxKr2EeiNHY6qjNhZ4w" supplier="_7xdSzar2EeiNHY6qjNhZ4w" contract="_7xdSzar2EeiNHY6qjNhZ4w"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_7xdSx6r2EeiNHY6qjNhZ4w" name="Observation">
          <ownedOperation xmi:id="_7z14YKr2EeiNHY6qjNhZ4w" name="Chute_exit_setFree">
            <ownedParameter xmi:id="_7z14Yar2EeiNHY6qjNhZ4w" name="free">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:id="_70Eh4Kr2EeiNHY6qjNhZ4w" name="Chute_timer_timeout"/>
          <ownedOperation xmi:id="_70O58Kr2EeiNHY6qjNhZ4w" name="Chute_enter_transmit">
            <ownedParameter xmi:id="_70O58ar2EeiNHY6qjNhZ4w" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
          <ownedOperation xmi:id="_71yZIKr2EeiNHY6qjNhZ4w" name="Switcher_right_setFree">
            <ownedParameter xmi:id="_71yZIar2EeiNHY6qjNhZ4w" name="free">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:id="_711ccKr2EeiNHY6qjNhZ4w" name="Switcher_timer_timeout"/>
          <ownedOperation xmi:id="_719_UKr2EeiNHY6qjNhZ4w" name="Switcher_switchProtocol_setSwitch">
            <ownedParameter xmi:id="_719_Uar2EeiNHY6qjNhZ4w" name="c">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:id="_72BpsKr2EeiNHY6qjNhZ4w" name="Switcher_left_setFree">
            <ownedParameter xmi:id="_72Bpsar2EeiNHY6qjNhZ4w" name="free">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:id="_72T9kKr2EeiNHY6qjNhZ4w" name="Switcher_enter_transmit">
            <ownedParameter xmi:id="_72T9kar2EeiNHY6qjNhZ4w" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
          <ownedOperation xmi:id="_73XtgKr2EeiNHY6qjNhZ4w" name="Gen_timer_timeout"/>
          <ownedOperation xmi:id="_73b-8Kr2EeiNHY6qjNhZ4w" name="Gen_enter_setFree">
            <ownedParameter xmi:id="_73b-8ar2EeiNHY6qjNhZ4w" name="free">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:id="_74bdcKr2EeiNHY6qjNhZ4w" name="Sensor_detection_detect">
            <ownedParameter xmi:id="_74bdcar2EeiNHY6qjNhZ4w" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
          <ownedOperation xmi:id="_75l7EKr2EeiNHY6qjNhZ4w" name="Bin_enter_transmit">
            <ownedParameter xmi:id="_75l7Ear2EeiNHY6qjNhZ4w" name="p" type="_aEoEwML7EeaSH8bbL43htA"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_7xdSyKr2EeiNHY6qjNhZ4w" name="Observation~">
          <ownedOperation xmi:id="_7xdSyar2EeiNHY6qjNhZ4w" name="event">
            <ownedParameter xmi:id="_7xdSyqr2EeiNHY6qjNhZ4w" name="data" type="_7xdTAKr2EeiNHY6qjNhZ4w"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_7xdSy6r2EeiNHY6qjNhZ4w" client="_7xdSxKr2EeiNHY6qjNhZ4w" supplier="_7xdSyKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_7xdSzKr2EeiNHY6qjNhZ4w" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_7xdSzar2EeiNHY6qjNhZ4w" name="ObservationIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_7xdSzqr2EeiNHY6qjNhZ4w" client="_7xdSxKr2EeiNHY6qjNhZ4w" supplier="_7xdSzar2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_7xdSz6r2EeiNHY6qjNhZ4w" operation="_7xdSyar2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_7z14Yqr2EeiNHY6qjNhZ4w" name="Chute_exit_setFree" operation="_7z14YKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_70Eh4ar2EeiNHY6qjNhZ4w" name="Chute_timer_timeout" operation="_70Eh4Kr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_70O58qr2EeiNHY6qjNhZ4w" name="Chute_enter_transmit" operation="_70O58Kr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_71zAMKr2EeiNHY6qjNhZ4w" name="Switcher_right_setFree" operation="_71yZIKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_712DgKr2EeiNHY6qjNhZ4w" name="Switcher_timer_timeout" operation="_711ccKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_71-mYKr2EeiNHY6qjNhZ4w" name="Switcher_switchProtocol_setSwitch" operation="_719_UKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_72Bpsqr2EeiNHY6qjNhZ4w" name="Switcher_left_setFree" operation="_72BpsKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_72T9kqr2EeiNHY6qjNhZ4w" name="Switcher_enter_transmit" operation="_72T9kKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_73Xtgar2EeiNHY6qjNhZ4w" name="Gen_timer_timeout" operation="_73XtgKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_73b-8qr2EeiNHY6qjNhZ4w" name="Gen_enter_setFree" operation="_73b-8Kr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_74bdcqr2EeiNHY6qjNhZ4w" name="Sensor_detection_detect" operation="_74bdcKr2EeiNHY6qjNhZ4w"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_75l7Eqr2EeiNHY6qjNhZ4w" name="Bin_enter_transmit" operation="_75l7EKr2EeiNHY6qjNhZ4w"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_7xdS0Kr2EeiNHY6qjNhZ4w" name="Observer" classifierBehavior="_7xdS2qr2EeiNHY6qjNhZ4w" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_7xdS0ar2EeiNHY6qjNhZ4w" name="observation" visibility="public" type="_7xdSxKr2EeiNHY6qjNhZ4w" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_7xdS0qr2EeiNHY6qjNhZ4w" value="20"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_7xdS06r2EeiNHY6qjNhZ4w" value="20"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_7xdS1Kr2EeiNHY6qjNhZ4w" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_7xdS1ar2EeiNHY6qjNhZ4w" name="commandTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:id="_7xdS1qr2EeiNHY6qjNhZ4w" name="eventQueue" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_7xdS16r2EeiNHY6qjNhZ4w" name="eventTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:id="_7xdS2Kr2EeiNHY6qjNhZ4w" name="isPeriodic">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_7xdS2ar2EeiNHY6qjNhZ4w"/>
        </ownedAttribute>
        <ownedAttribute xmi:id="_75wTIKr2EeiNHY6qjNhZ4w" name="parcel" type="_aEoEwML7EeaSH8bbL43htA"/>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_7xdS2qr2EeiNHY6qjNhZ4w" name="ObserverStateMachine" isReentrant="false">
          <region xmi:id="_7xdS26r2EeiNHY6qjNhZ4w" name="Region">
            <transition xmi:id="_7xdS3Kr2EeiNHY6qjNhZ4w" name="configure" source="_7xdS6qr2EeiNHY6qjNhZ4w" target="_7xdS66r2EeiNHY6qjNhZ4w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS3ar2EeiNHY6qjNhZ4w">
                <language>C++</language>
                <body>int n = config.load();
log.show(&quot;Number of entries: %d\n&quot;, n);

// Socket
this->method = new Socket();
this->method->configure(config.getConfigList());
this->method->connect();

// Text 
this->serializer = new Text();
this->serializer->configure(config.getConfigList());

std::string mode = config.get(&quot;mode&quot;);
std::string periodicity = config.get(&quot;periodicity&quot;);

// If sending events is set as periodic
if (periodicity != &quot;&quot; &amp;&amp; mode == &quot;periodic&quot;) {
	this->isPeriodic = true;
	// Periodicity is set in microseconds
	// Multiplied by 1000 to get nanoseconds
	long nano = (long long)(atol(periodicity.c_str())*1000);
	long seconds = nano/1000000000;
	eventTimer.informEvery(UMLRTTimespec(seconds, (nano-1000000000*seconds)));
}

// Instantiating the command timer
commandTimer.informEvery(UMLRTTimespec(0,500000000));
</body>
              </effect>
            </transition>
            <transition xmi:id="_7xdS3qr2EeiNHY6qjNhZ4w" name="event received" source="_7xdS66r2EeiNHY6qjNhZ4w" target="_7xdS66r2EeiNHY6qjNhZ4w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS36r2EeiNHY6qjNhZ4w">
                <language>C++</language>
                <body>std::string event = this->serializer->serialize(data.event) + &quot;\n&quot;;
if (this->isPeriodic) {
	eventQueue.push_back(event);
}
else {
	this->method->sendData(event);
}</body>
              </effect>
              <trigger xmi:id="_7xdS4Kr2EeiNHY6qjNhZ4w" event="_7xdSz6r2EeiNHY6qjNhZ4w" port="_7xdS0ar2EeiNHY6qjNhZ4w"/>
            </transition>
            <transition xmi:id="_7xdS4ar2EeiNHY6qjNhZ4w" name="command received" source="_7xdS66r2EeiNHY6qjNhZ4w" target="_7xdS66r2EeiNHY6qjNhZ4w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS4qr2EeiNHY6qjNhZ4w">
                <language>C++</language>
                <body>std::string data = this->method->read();
    if (data != &quot;&quot;) {
    Event evt = this->serializer->parse(data);
    if (evt.getEventSource() == Event::EventSource::Command) {

      std::map&lt;std::string, size_t>::iterator iter;
      std::string sourceName = evt.getSourceName();

      switch(evt.getEventKind()) {
        case Event::EventKind::List:
          // List of capsule parts
          evt.setSourceName(&quot;Observer&quot;);
          for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
            evt.setParam(iter->first, capsuleTypes[iter->first]);
          }
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Show:
          // Show a specific capsule part
          this->method->sendData(this->serializer->serialize(listCapsuleMessage(evt)));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Trigger:
          evt = this->triggerCapsuleMessage(evt);
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        default:
        break;
      }
    }
}

/*std::string data = this->method->read();
    std::stringstream ss;
    if (data != &quot;&quot;) {

        std::istringstream iss(data);
        std::vector&lt;std::string> cmd;
        while (iss) {
            std::string subs;
            iss >> subs; 
            if (iss.str().empty()) {
                cmd.push_back(subs);
            }
        }

        if (cmd.size() == 0)
            return;

        if (cmd.size() > 1 &amp;&amp; cmd[0] == &quot;list&quot; &amp;&amp; cmd[1] == &quot;capsules&quot;) {
            ss  &lt;&lt; &quot;List of capsules:\n&quot;;
            std::map&lt;std::string, size_t>::iterator iter;
            for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; iter->first &lt;&lt; &quot; [&quot;&lt;&lt; capsuleTypes[iter->first]&lt;&lt; &quot;]\n&quot;;
            }
            this->method->sendData(ss.str());
        }
        else if (cmd.size() > 2 &amp;&amp; cmd[0] == &quot;show&quot; &amp;&amp; cmd[1] == &quot;capsule&quot;) {

            printf(&quot;capsule:%s|type:%s\n&quot;, cmd[1].c_str(), capsuleTypes[cmd[2]].c_str());
            if (capsuleTypes[cmd[2]] == &quot;&quot;) {
                printf(&quot;error: %s\n&quot;, capsuleTypes[cmd[2]].c_str());
                return;
            }
            std::string capsuleType = capsuleTypes[cmd[2]];
            ss  &lt;&lt; &quot;Capsule: &quot; &lt;&lt; cmd[2];
            ss  &lt;&lt; &quot; type: &quot; &lt;&lt; capsuleTypes[cmd[2]] &lt;&lt; &quot;\n&quot;;
            ss  &lt;&lt; &quot;List of triggers:\n&quot;;
            if (capsuleType == &quot;Gen&quot;) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; &quot;generate()\n&quot;;
                this->method->sendData(ss.str());
            }
        }

    }*/</body>
              </effect>
              <trigger xmi:id="_7xdS46r2EeiNHY6qjNhZ4w" port="_7xdS1ar2EeiNHY6qjNhZ4w">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:id="_7xdS5Kr2EeiNHY6qjNhZ4w" name="register capsules" source="_7xdS66r2EeiNHY6qjNhZ4w" target="_7xdS66r2EeiNHY6qjNhZ4w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS5ar2EeiNHY6qjNhZ4w">
                <language>C++</language>
                <body>std::stringstream ss;
    ss &lt;&lt; msg->signal.getSrcPort()->slot->name &lt;&lt; &quot;:&quot; &lt;&lt; msg->signal.getSrcPort()->slot->capsuleIndex;
    printf(&quot;capsule name: %s at port %d\n&quot;, ss.str().c_str(), (int)msg->sapIndex0_);
    capsules[ss.str()] = msg->sapIndex0_;
    capsuleTypes[ss.str()] = msg->signal.getSrcPort()->slot->capsuleClass->name;</body>
              </effect>
              <trigger xmi:id="_7xdS5qr2EeiNHY6qjNhZ4w" port="_7xdS0ar2EeiNHY6qjNhZ4w">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_PQtAwOzeEeSRtqCWFwOf8g"/>
              </trigger>
            </transition>
            <transition xmi:id="_7xdS56r2EeiNHY6qjNhZ4w" name="events periodically sent" source="_7xdS66r2EeiNHY6qjNhZ4w" target="_7xdS66r2EeiNHY6qjNhZ4w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS6Kr2EeiNHY6qjNhZ4w" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>unsigned size = this->eventQueue.size();
for (unsigned int i = 0; i &lt; size; i++) {
	this->method->sendData(this->eventQueue.back());
	this->eventQueue.pop_back();
}</body>
              </effect>
              <trigger xmi:id="_7xdS6ar2EeiNHY6qjNhZ4w" port="_7xdS16r2EeiNHY6qjNhZ4w">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_7xdS6qr2EeiNHY6qjNhZ4w">
              <name xsi:nil="true"/>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_7xdS66r2EeiNHY6qjNhZ4w" name="OBSERVING"/>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS7Kr2EeiNHY6qjNhZ4w" name="listCapsuleMessage" specification="_7xdS76r2EeiNHY6qjNhZ4w">
          <language>C++</language>
          <body>std::string sourceName = evt.getSourceName();
if (sourceName == &quot;Chute&quot;) {
	evt.setParam(&quot;0&quot;, &quot;exit_setFree&quot;);
	evt.setParam(&quot;1&quot;, &quot;timer_timeout&quot;);
	evt.setParam(&quot;2&quot;, &quot;enter_transmit&quot;);
}
if (sourceName == &quot;Bin&quot;) {
	evt.setParam(&quot;0&quot;, &quot;enter_transmit&quot;);
}
if (sourceName == &quot;Switcher&quot;) {
	evt.setParam(&quot;0&quot;, &quot;right_setFree&quot;);
	evt.setParam(&quot;1&quot;, &quot;timer_timeout&quot;);
	evt.setParam(&quot;2&quot;, &quot;switchProtocol_setSwitch&quot;);
	evt.setParam(&quot;3&quot;, &quot;left_setFree&quot;);
	evt.setParam(&quot;4&quot;, &quot;enter_transmit&quot;);
}
if (sourceName == &quot;Sensor&quot;) {
	evt.setParam(&quot;0&quot;, &quot;detection_detect&quot;);
}
if (sourceName == &quot;Gen&quot;) {
	evt.setParam(&quot;0&quot;, &quot;enter_setFree&quot;);
	evt.setParam(&quot;1&quot;, &quot;timer_timeout&quot;);
}
return evt;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS7ar2EeiNHY6qjNhZ4w" name="triggerCapsuleMessage" specification="_7xdS8qr2EeiNHY6qjNhZ4w">
          <language>C++</language>
          <body>std::map&lt;std::string, size_t>::iterator iter;
std::string instanceName = evt.getCapsuleInstance(); // name of the instance
std::string capsuleType = &quot;&quot;;     // name of the capsule
std::string opName    = evt.getParam(&quot;operation&quot;);
int portIndex = -1;
for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
if (iter->first == instanceName) {
portIndex = capsules[iter->first];
capsuleType = capsuleTypes[iter->first];
break;
}
}
// For debugging purpose
  printf(&quot;instanceName = %s, capsuleType = %s, portIndex = %d&quot;,      instanceName.c_str(),      capsuleType.c_str(),      (int)portIndex);
if (portIndex == -1) {
printf(&quot;Problem with instanceName = %s&quot;, instanceName.c_str());evt.setParam(&quot;success&quot;, 0);
return evt;
}
if (capsuleType == &quot;Chute&quot;) {
if (opName == &quot;exit_setFree&quot;) {
observation.Chute_exit_setFree(to_bool(evt.getParam(&quot;free&quot;))).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;timer_timeout&quot;) {
observation.Chute_timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;enter_transmit&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Chute_enter_transmit(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Bin&quot;) {
if (opName == &quot;enter_transmit&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Bin_enter_transmit(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Switcher&quot;) {
if (opName == &quot;right_setFree&quot;) {
observation.Switcher_right_setFree(to_bool(evt.getParam(&quot;free&quot;))).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;timer_timeout&quot;) {
observation.Switcher_timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;switchProtocol_setSwitch&quot;) {
observation.Switcher_switchProtocol_setSwitch(atoi(evt.getParam(&quot;c&quot;).c_str())).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;left_setFree&quot;) {
observation.Switcher_left_setFree(to_bool(evt.getParam(&quot;free&quot;))).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;enter_transmit&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Switcher_enter_transmit(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Sensor&quot;) {
if (opName == &quot;detection_detect&quot;) {
init_parcel(evt, &quot;p&quot;);
observation.Sensor_detection_detect(this->parcel).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Gen&quot;) {
if (opName == &quot;enter_setFree&quot;) {
observation.Gen_enter_setFree(to_bool(evt.getParam(&quot;free&quot;))).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;timer_timeout&quot;) {
observation.Gen_timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
return evt;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_7xdS7qr2EeiNHY6qjNhZ4w" name="to_bool" specification="_7xdS9ar2EeiNHY6qjNhZ4w">
          <language>C++</language>
          <body>return strcmp(s.c_str(),&quot;0&quot;) != 0 &amp;&amp; strcmp(s.c_str(), &quot;false&quot;) != 0;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_75-Vkar2EeiNHY6qjNhZ4w" name="init_parcel" specification="_75w6MKr2EeiNHY6qjNhZ4w">
          <language>C++</language>
          <body>parcel.number = atoi(evt.getParam(prefix + &quot;.number&quot;).c_str());
parcel.level = atoi(evt.getParam(prefix + &quot;.level&quot;).c_str());
parcel.stage = atoi(evt.getParam(prefix + &quot;.stage&quot;).c_str());
</body>
        </ownedBehavior>
        <ownedOperation xmi:id="_7xdS76r2EeiNHY6qjNhZ4w" name="listCapsuleMessage" concurrency="guarded" method="_7xdS7Kr2EeiNHY6qjNhZ4w">
          <ownedParameter xmi:id="_7xdS8Kr2EeiNHY6qjNhZ4w" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:id="_7xdS8ar2EeiNHY6qjNhZ4w" name="response" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:id="_7xdS8qr2EeiNHY6qjNhZ4w" name="triggerCapsuleMessage" concurrency="guarded" method="_7xdS7ar2EeiNHY6qjNhZ4w">
          <ownedParameter xmi:id="_7xdS86r2EeiNHY6qjNhZ4w" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:id="_7xdS9Kr2EeiNHY6qjNhZ4w" name="response" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:id="_7xdS9ar2EeiNHY6qjNhZ4w" name="to_bool" concurrency="guarded" method="_7xdS7qr2EeiNHY6qjNhZ4w">
          <ownedParameter xmi:id="_7xdS9qr2EeiNHY6qjNhZ4w" name="s">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:id="_7xdS96r2EeiNHY6qjNhZ4w" name="result" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:id="_75w6MKr2EeiNHY6qjNhZ4w" name="init_parcel" method="_75-Vkar2EeiNHY6qjNhZ4w">
          <ownedParameter xmi:id="_753n4Kr2EeiNHY6qjNhZ4w" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:id="_75-VkKr2EeiNHY6qjNhZ4w" name="prefix">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_7xdS-Kr2EeiNHY6qjNhZ4w" name="internal">
        <packagedElement xmi:type="uml:Artifact" xmi:id="_7xdS-ar2EeiNHY6qjNhZ4w" name="Event" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_7xdS-qr2EeiNHY6qjNhZ4w" name="CLIUtils"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_7xdS-6r2EeiNHY6qjNhZ4w" name="Serializer"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_7xdS_Kr2EeiNHY6qjNhZ4w" name="Method"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_7xdS_ar2EeiNHY6qjNhZ4w" name="Text" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_7xdS_qr2EeiNHY6qjNhZ4w" name="Socket"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_7xdS_6r2EeiNHY6qjNhZ4w" name="Config"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_7xdTAKr2EeiNHY6qjNhZ4w" name="EventObj"/>
      <profileApplication xmi:id="_7xdTAar2EeiNHY6qjNhZ4w">
        <eAnnotations xmi:id="_7xdTAqr2EeiNHY6qjNhZ4w" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
        </eAnnotations>
        <appliedProfile href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
      </profileApplication>
      <profileApplication xmi:id="_7xdTA6r2EeiNHY6qjNhZ4w">
        <eAnnotations xmi:id="_7xdTBKr2EeiNHY6qjNhZ4w" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
        </eAnnotations>
        <appliedProfile href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:id="_7xdTBar2EeiNHY6qjNhZ4w">
        <eAnnotations xmi:id="_7xdTBqr2EeiNHY6qjNhZ4w" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
        </eAnnotations>
        <appliedProfile href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
      </profileApplication>
      <profileApplication xmi:id="_7xdTB6r2EeiNHY6qjNhZ4w">
        <eAnnotations xmi:id="_7xdTCKr2EeiNHY6qjNhZ4w" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
        </eAnnotations>
        <appliedProfile href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
      </profileApplication>
    </packagedElement>
    <profileApplication xmi:id="_nykGUML5EeaSH8bbL43htA">
      <eAnnotations xmi:id="_nyl7gML5EeaSH8bbL43htA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:id="_8dJfAML5EeaSH8bbL43htA">
      <eAnnotations xmi:id="_8dKtIML5EeaSH8bbL43htA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
    <profileApplication xmi:id="_8dLUMML5EeaSH8bbL43htA">
      <eAnnotations xmi:id="_8dL7QML5EeaSH8bbL43htA" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_9cQyoML5EeaSH8bbL43htA" base_Class="_9X86YML5EeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_Gu9tEML6EeaSH8bbL43htA" base_Class="_GuPUUML6EeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_Iu5kgML6EeaSH8bbL43htA" base_Class="_IuNA8ML6EeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_LOpkcML6EeaSH8bbL43htA" base_Class="_LOPUwML6EeaSH8bbL43htA"/>
  <UMLRealTime:ProtocolContainer xmi:id="_QrF_AML6EeaSH8bbL43htA" base_Package="_QrBtkML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTMessageSet xmi:id="_QrOh4ML6EeaSH8bbL43htA" base_Interface="_QrKQcML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTMessageSet xmi:id="_QrWdsML6EeaSH8bbL43htA" base_Interface="_QrSzUML6EeaSH8bbL43htA" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_QrckUML6EeaSH8bbL43htA" base_Interface="_QrZhAML6EeaSH8bbL43htA" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_QrgOsML6EeaSH8bbL43htA" base_Collaboration="_Qq5xwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_a5_b8ML6EeaSH8bbL43htA" base_Port="_a5ynoML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_ej0CUML6EeaSH8bbL43htA" base_Port="_ejuiwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_gvt5MML6EeaSH8bbL43htA" base_Port="_gvpnwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_ieknsML6EeaSH8bbL43htA" base_Port="_ieg9UML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_l2SKYML6EeaSH8bbL43htA" base_Port="_l2PuIML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_o94NcML6EeaSH8bbL43htA" base_Property="_o9z8AML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_sW7z8ML6EeaSH8bbL43htA" base_Property="_sW4woML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_uWJ5sML6EeaSH8bbL43htA" base_Property="_uWG2YML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_wXCMUML6EeaSH8bbL43htA" base_Property="_wW-h8ML6EeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_zZAIgML6EeaSH8bbL43htA" base_Property="_zY9sQML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_9hs20cL6EeaSH8bbL43htA" base_Connector="_9hn-UML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_-P8c4sL6EeaSH8bbL43htA" base_Connector="_-P5ZkML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_-9SrEcL6EeaSH8bbL43htA" base_Connector="_-9PnwML6EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_ihRg8ML7EeaSH8bbL43htA" isWired="false" base_Port="_ihPrwML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_sgbRsML7EeaSH8bbL43htA" base_Pseudostate="_sgYOYML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTState xmi:id="_sggKMML7EeaSH8bbL43htA" base_State="_sgeVAML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_sglCsML7EeaSH8bbL43htA" base_Region="_sgSu0ML7EeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_shjTEML7EeaSH8bbL43htA" base_StateMachine="_sgJk4ML7EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_TGQH8ML8EeaSH8bbL43htA" isWired="false" base_Port="_TGKoYML8EeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_QkHBsMMEEeaSH8bbL43htA" isWired="false" base_Port="_QkCwQMMEEeaSH8bbL43htA"/>
  <UMLRealTime:RTPort xmi:id="_P-0CoMMMEeaSH8bbL43htA" isWired="false" base_Port="_P-w_UMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_SANSoMMMEeaSH8bbL43htA" base_Pseudostate="_SAMEgMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTState xmi:id="_SAPH0MMMEeaSH8bbL43htA" base_State="_SAN5sMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_SAPu4MMMEeaSH8bbL43htA" base_Region="_SAKPUMMMEeaSH8bbL43htA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_SBGqkMMMEeaSH8bbL43htA" base_StateMachine="_SAHMAMMMEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_0KCXUsMPEeaSH8bbL43htA" base_Connector="_0KAiIMMPEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_02B6osMPEeaSH8bbL43htA" base_Connector="_02AFcMMPEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_13cUUcMPEeaSH8bbL43htA" base_Connector="_13afIMMPEeaSH8bbL43htA"/>
  <UMLRealTime:RTConnector xmi:id="_2pYHkMMPEeaSH8bbL43htA" base_Connector="_2pVrUMMPEeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_bKtWgMMQEeaSH8bbL43htA" base_Property="_bKsIYMMQEeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_ex6GsMMQEeaSH8bbL43htA" base_Property="_ex4RgMMQEeaSH8bbL43htA"/>
  <UMLRealTime:CapsulePart xmi:id="_gzrKIMMQEeaSH8bbL43htA" base_Property="_gzot4MMQEeaSH8bbL43htA"/>
  <UMLRealTime:Capsule xmi:id="_j0w1YMM4EeahHehXumVB-w" base_Class="_jvOOEMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_p187wMM4EeahHehXumVB-w" base_Port="_p1u5UMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_sK-SYMM4EeahHehXumVB-w" base_Port="_sK7PEMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_v-PIoMM4EeahHehXumVB-w" base_Port="_v-KQIMM4EeahHehXumVB-w"/>
  <UMLRealTime:ProtocolContainer xmi:id="_wvSyIMM4EeahHehXumVB-w" base_Package="_wvPHwMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_wvY4wMM4EeahHehXumVB-w" base_Interface="_wvV1cMM4EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_wve_YMM4EeahHehXumVB-w" base_Interface="_wvcjIMM4EeahHehXumVB-w" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_wvke8MM4EeahHehXumVB-w" base_Interface="_wviCsMM4EeahHehXumVB-w" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_wvniQMM4EeahHehXumVB-w" base_Collaboration="_wvKPQMM4EeahHehXumVB-w"/>
  <UMLRealTime:Capsule xmi:id="_AJ77MMM5EeahHehXumVB-w" base_Class="_AJLGMMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_CHYfUMM5EeahHehXumVB-w" base_Port="_CHUN4MM5EeahHehXumVB-w"/>
  <UMLRealTime:Capsule xmi:id="_O_8GIMM5EeahHehXumVB-w" base_Class="_O_UbEMM5EeahHehXumVB-w"/>
  <UMLRealTime:ProtocolContainer xmi:id="_RDhugMM5EeahHehXumVB-w" base_Package="_RDfSQMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_RDkKwMM5EeahHehXumVB-w" base_Interface="_RDiVkMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTMessageSet xmi:id="_RDnOEMM5EeahHehXumVB-w" base_Interface="_RDlY4MM5EeahHehXumVB-w" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_RDrfgMM5EeahHehXumVB-w" base_Interface="_RDpDQMM5EeahHehXumVB-w" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_RDt7wMM5EeahHehXumVB-w" base_Collaboration="_RDbn4MM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_gMcOYMM5EeahHehXumVB-w" base_Port="_gMZLEMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_m5f8QMM5EeahHehXumVB-w" base_Port="_m5dgAMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_0csbgMM5EeahHehXumVB-w" base_Port="_0cp_QMM5EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_3ton0MM5EeahHehXumVB-w" base_Port="_3tk9cMM5EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_8dOjcMM5EeahHehXumVB-w" base_Property="_8dMHMMM5EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_ANxc4MM6EeahHehXumVB-w" base_Property="_ANvnsMM6EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_DptYQMM6EeahHehXumVB-w" base_Property="_Dpq8AMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_GmrfssM6EeahHehXumVB-w" base_Connector="_GmpDcMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_JFkkAsM6EeahHehXumVB-w" base_Connector="_JFiHwMM6EeahHehXumVB-w"/>
  <UMLRealTime:CapsulePart xmi:id="_KEoNQMM6EeahHehXumVB-w" base_Property="_KElJ8MM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_Ni31wsM6EeahHehXumVB-w" base_Connector="_Ni2AkMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_Q2uzMMM6EeahHehXumVB-w" base_Connector="_Q2rv4MM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_TMfwscM6EeahHehXumVB-w" base_Connector="_TMcGUMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_T-WEYcM6EeahHehXumVB-w" base_Connector="_T-SaAMM6EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_VxL7AMM6EeahHehXumVB-w" base_Port="_VxKF0MM6EeahHehXumVB-w"/>
  <UMLRealTime:RTConnector xmi:id="_fBwHcsM6EeahHehXumVB-w" base_Connector="_fBuSQMM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_mXF9UMM6EeahHehXumVB-w" base_StateMachine="_mXBE0MM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_mXGkYMM6EeahHehXumVB-w" base_Region="_mXBE0cM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_mXHLcMM6EeahHehXumVB-w" base_Pseudostate="_mXBE18M6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTState xmi:id="_mXHygMM6EeahHehXumVB-w" base_State="_mXBE2MM6EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_IdGZUMM7EeahHehXumVB-w" base_StateMachine="_IdCu8MM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_IdHAYMM7EeahHehXumVB-w" base_Region="_IdCu8cM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_IdHncMM7EeahHehXumVB-w" base_Pseudostate="_IdDWBcM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTState xmi:id="_IdHnccM7EeahHehXumVB-w" base_State="_IdDWBsM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_yUREgMM7EeahHehXumVB-w" base_Pseudostate="_yUOoQMM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTState xmi:id="_yUTgwMM7EeahHehXumVB-w" base_State="_yUSSoMM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_yUUu4MM7EeahHehXumVB-w" base_Region="_yUMMAMM7EeahHehXumVB-w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_yVXQsMM7EeahHehXumVB-w" base_StateMachine="_yUE3QMM7EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_uL4n8MM9EeahHehXumVB-w" isWired="false" base_Port="_uL2LsMM9EeahHehXumVB-w"/>
  <UMLRealTime:RTPort xmi:id="_qxaXcMX2EeaYV5cb1Zesag" isWired="false" base_Port="_qxGOYMX2EeaYV5cb1Zesag"/>
  <UMLRealTime:RTPort xmi:id="_x2xQkMX2EeaYV5cb1Zesag" isWired="false" base_Port="_x2tmMMX2EeaYV5cb1Zesag"/>
  <UMLRTStateMachines:RTState xmi:id="_k2x6IMX4EeaYV5cb1Zesag" base_State="_k2uPwMX4EeaYV5cb1Zesag"/>
  <UMLRealTime:RTPort xmi:id="_Wbb1cMX5EeaYV5cb1Zesag" isWired="false" base_Port="_WbYyIMX5EeaYV5cb1Zesag"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_aL1IcMX6EeaYV5cb1Zesag" base_Pseudostate="_aLwP8MX6EeaYV5cb1Zesag"/>
  <UMLRTStateMachines:RTState xmi:id="_GOUpoMYlEeaYV5cb1Zesag" base_State="_GOTbgMYlEeaYV5cb1Zesag"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_RQTwYMYlEeaYV5cb1Zesag" base_Pseudostate="_RQRUIMYlEeaYV5cb1Zesag"/>
  <UMLRealTime:RTPort xmi:id="_4c99IMYlEeaYV5cb1Zesag" isWired="false" base_Port="_4c8vAMYlEeaYV5cb1Zesag"/>
  <RTCppProperties:PassiveClassProperties xmi:id="_TuYcgN5nEeakB9CQglrL_g" headerPreface="" base_Class="_aEoEwML7EeaSH8bbL43htA" privateDeclarations="" publicDeclarations=""/>
  <UMLRealTime:Capsule xmi:id="_oRRtMKoxEeiNHY6qjNhZ4w"/>
  <UMLRealTime:ProtocolContainer xmi:id="_oRSUQKoxEeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTMessageSet xmi:id="_oRS7UKoxEeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTMessageSet xmi:id="_oRTiYKoxEeiNHY6qjNhZ4w" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_oRTiYaoxEeiNHY6qjNhZ4w" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_oRUJcKoxEeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_oRUwgKoxEeiNHY6qjNhZ4w" isNotification="true" isPublish="true" isWired="false"/>
  <UMLRealTime:RTPort xmi:id="_oRUwgaoxEeiNHY6qjNhZ4w" isWired="false"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_oRVXkKoxEeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTState xmi:id="_oRVXkaoxEeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_oRVXkqoxEeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_oRV-oKoxEeiNHY6qjNhZ4w"/>
  <RTCppProperties:CapsuleProperties xmi:id="_oRZpAKoxEeiNHY6qjNhZ4w" headerPreface="#include &quot;Method.hh&quot;&#xA;#include &quot;Socket.hh&quot;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Text.hh&quot;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;#include &quot;Config.hh&quot;&#xA;#include &lt;deque>" privateDeclarations="Method* method;&#xA;Serializer* serializer;&#xA;std::map&lt;std::string, size_t> capsules;&#xA;std::map&lt;std::string, std::string> capsuleTypes;&#xA;Config config;"/>
  <UMLRealTime:RTPort xmi:id="_oRa3IKoxEeiNHY6qjNhZ4w" isWired="false"/>
  <RTCppProperties:CapsuleProperties xmi:id="_oRcFQKoxEeiNHY6qjNhZ4w" headerPreface="#include &quot;Event.hh&quot;" implementationPreface="" publicDeclarations="Event event;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_oRdTYKoxEeiNHY6qjNhZ4w" includeFile="/*&#xA; * Event.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef EVENT_HH_&#xA;#define EVENT_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;&#xA;class Event {&#xA;&#xA;public:&#xA;typedef enum {&#xA;&#x9;&#x9;Signal,&#xA;&#x9;&#x9;Method,&#xA;&#x9;&#x9;ActionCode,&#xA;&#x9;&#x9;Transition,&#xA;&#x9;&#x9;State,&#xA;&#x9;&#x9;Capsule,&#xA;&#x9;&#x9;Attribute,&#xA;&#x9;&#x9;Timer,&#xA;&#x9;&#x9;UnknownSource, Command&#xA;&#x9;} EventSource;&#xA;&#xA;&#x9;typedef enum {&#xA;&#x9;&#x9;SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;&#x9;&#x9;MethodCall,&#xA;&#x9;&#x9;MethodCallReceive,&#xA;&#x9;&#x9;MethodStartExecute,&#xA;&#x9;&#x9;MethodReturn,&#xA;&#x9;&#x9;MethodFailed,&#xA;&#x9;&#x9;MethodReturnReceived, // Method events&#xA;&#x9;&#x9;ActionStart,&#xA;&#x9;&#x9;ActionEnd, // Action code events&#xA;&#x9;&#x9;TransitionStart,&#xA;&#x9;&#x9;TransitionEnd, // Transition events&#xA;&#x9;&#x9;StateEntryStart,&#xA;&#x9;&#x9;StateEntryEnd,&#xA;&#x9;&#x9;StateExitStart,&#xA;&#x9;&#x9;StateExitEnd,&#xA;&#x9;&#x9;StateIdleStart,&#xA;&#x9;&#x9;StateIdleEnd, // State events&#xA;&#x9;&#x9;CapsuleInstantiate,&#xA;&#x9;&#x9;CapsuleFree, // Capsule events&#xA;&#x9;&#x9;AttributeInstantiate,&#xA;&#x9;&#x9;AttributeFree,&#xA;&#x9;&#x9;AttributeChange, // Attribute events&#xA;&#x9;&#x9;TimerStart,&#xA;&#x9;&#x9;TimerSet,&#xA;&#x9;&#x9;TimerCancel,&#xA;&#x9;&#x9;TimerTimeout, // Timer events&#xA;&#x9;&#x9;UnknownKind, List, Show, Trigger&#xA;&#x9;} EventKind;&#xA;&#xA;private:&#xA;&#x9;std::string capsuleInstance;&#xA;&#x9;std::string sourceName;&#xA;&#x9;std::string eventId;&#xA;&#x9;long seconds;&#xA;&#x9;long nanoseconds;&#xA;&#x9;EventSource eventSource;&#xA;&#x9;EventKind eventKind;&#xA;&#x9;std::map&lt;std::string, std::string> params;&#xA;&#xA;public:&#xA;&#x9;Event(std::string capsuleInstance = &quot;&quot;, std::string sourceName = &quot;&quot;,&#xA;&#x9;&#x9;&#x9;EventSource eventSource = UnknownSource, EventKind eventKind =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;UnknownKind, long seconds = 0, long nanoseconds = 0);&#xA;&#x9;const std::string getCapsuleInstance() const;&#xA;&#x9;void setCapsuleInstance(const std::string capsuleInstance);&#xA;&#x9;const std::string getSourceName() const;&#xA;&#x9;void setSourceName(const std::string sourceName);&#xA;&#x9;const EventSource getEventSource() const;&#xA;&#x9;void setEventSource(const Event::EventSource source);&#xA;&#x9;const EventKind getEventKind() const;&#xA;&#x9;void setEventKind(const Event::EventKind kind);&#xA;&#x9;const long getSeconds() const;&#xA;&#x9;const long getNanoseconds() const;&#xA;&#x9;void setTimestamp();&#xA;&#x9;void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;&#x9;void setSeconds(const long seconds);&#xA;&#x9;void setNanoseconds(const long nanoseconds = 0);&#xA;&#x9;void setEventId(const std::string eventId);&#xA;&#x9;const std::string getEventId() const;&#xA;&#x9;void generateEventId();&#xA;&#x9;const std::map&lt;std::string, std::string> getParams() const;&#xA;&#x9;const std::string getParam(std::string key) const;&#xA;&#x9;void setParams(const std::map&lt;std::string, std::string> params);&#xA;&#x9;void setParam(const std::string key, const std::string value);&#xA;&#x9;void setParam(const std::string key, const int value);&#xA;&#x9;void clearParams();&#xA;};&#xA;&#xA;#endif /* EVENT_HH_ */" sourceFile="/*&#xA; * Event.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;&#xA;Event::Event(std::string capsuleInstance, std::string sourceName,&#xA;&#x9;&#x9;EventSource eventSource, EventKind eventKind, long seconds,&#xA;&#x9;&#x9;long nanoseconds) {&#xA;&#xA;&#x9;this->generateEventId();&#xA;&#x9;this->setCapsuleInstance(capsuleInstance);&#xA;&#x9;this->setSourceName(sourceName);&#xA;&#x9;this->setEventSource(eventSource);&#xA;&#x9;this->setEventKind(eventKind);&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;&#x9;return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;&#x9;this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;const std::string Event::getSourceName() const {&#xA;&#x9;return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;&#x9;this->sourceName = sourceName;&#xA;}&#xA;&#xA;const Event::EventSource Event::getEventSource() const {&#xA;&#x9;return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;&#x9;this->eventSource = source;&#xA;}&#xA;&#xA;const Event::EventKind Event::getEventKind() const {&#xA;&#x9;return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;&#x9;this->eventKind = kind;&#xA;}&#xA;&#xA;const long Event::getSeconds() const {&#xA;&#x9;return this->seconds;&#xA;}&#xA;&#xA;const long Event::getNanoseconds() const {&#xA;&#x9;return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;&#x9;setSeconds(seconds);&#xA;&#x9;this->setNanoseconds(nanoseconds);&#xA;&#x9;this->seconds = seconds;&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;&#x9;this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;&#x9;return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;&#x9;this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;std::stringstream ss;&#xA;&#x9;int r;&#xA;&#x9;r = random();&#xA;&#xA;&#x9;ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;&#x9;this->eventId = ss.str();&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;&#x9;return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;&#x9;bool n = this->params.count(key);&#xA;&#x9;return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const std::map&lt;std::string, std::string> params) {&#xA;&#x9;this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const std::string value) {&#xA;&#x9;if (key.length() >= 1)&#xA;&#x9;&#x9;this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const int value) {&#xA;&#x9;std::stringstream v;&#xA;&#x9;v &lt;&lt; value;&#xA;&#x9;this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;&#x9;this->params.clear();&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_oRd6cKoxEeiNHY6qjNhZ4w" includeFile="/*&#xA; * CLIUtils.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CLIUTILS_HH_&#xA;#define CLIUTILS_HH_&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str);&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd);&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;#endif /* CLIUTILS_HH_ */" sourceFile="/*&#xA; * CLIUtils.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str) {&#xA;&#x9;size_t strBegin = str.find_first_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;if (strBegin == std::string::npos)&#xA;&#x9;&#x9;return &quot;&quot;; // no content&#xA;&#xA;&#x9;size_t strEnd = str.find_last_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;size_t strRange = strEnd - strBegin + 1;&#xA;&#x9;return str.substr(strBegin, strRange);&#xA;}&#xA;&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd) {&#xA;&#x9;std::vector&lt;std::string> cmdTokens;&#xA;&#xA;&#x9;std::string command = trim(cmd);&#xA;&#xA;&#x9;if (command.length() == 0)&#xA;&#x9;&#x9;return cmdTokens;&#xA;&#xA;&#x9;std::string tempS = &quot;&quot;;&#xA;&#x9;bool newVar = false;&#xA;&#x9;bool quotation = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; command.length(); i++) {&#xA;&#xA;&#x9;&#x9;char c = command[i];&#xA;&#x9;&#x9;bool isSpaceOrEOL = (c == ' ' || c == '\n');&#xA;&#xA;&#x9;&#x9;if (isSpaceOrEOL) {&#xA;&#xA;&#x9;&#x9;&#x9;if (!newVar)&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (c == '&quot;') {&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;// open a quotation&#xA;&#x9;&#x9;&#x9;&#x9;quotation = true;&#xA;&#x9;&#x9;&#x9;&#x9;if (newVar) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;quotation = false;&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newVar)&#xA;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#xA;&#x9;return cmdTokens;&#xA;}&#xA;&#xA;}&#xA;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_oRd6caoxEeiNHY6qjNhZ4w" includeFile="/*&#xA; * Serializer.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SERIALIZER_HH_&#xA;#define SERIALIZER_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;public:&#xA;&#x9;Serializer();&#xA;&#x9;virtual ~Serializer();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const std::string serialize(const Event event) const = 0;&#xA;&#x9;virtual Event parse(const std::string data) const = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* SERIALIZER_HH_ */" sourceFile="/*&#xA; * Serializer.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;&#xA;Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_oRehgKoxEeiNHY6qjNhZ4w" includeFile="/*&#xA; * Method.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef METHOD_HH_&#xA;#define METHOD_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Method {&#xA;&#xA;public:&#xA;&#x9;Method();&#xA;&#x9;virtual ~Method();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect() = 0;&#xA;&#x9;virtual void disconnect() = 0;&#xA;&#x9;virtual std::string read() = 0;&#xA;&#x9;virtual void sendData(std::string) = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* METHOD_HH_ */&#xA;" sourceFile="/*&#xA; * Method.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;const bool Method::canConnect() const {&#xA;&#x9;return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_oRehgaoxEeiNHY6qjNhZ4w" includeFile="/*&#xA; * Text.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef TEXT_HH_&#xA;#define TEXT_HH_&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Event.hh&quot;&#xA;#include &lt;string>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;unistd.h>&#xA;&#xA;class Text: public Serializer {&#xA;&#xA;private:&#xA;&#x9;std::string format;&#xA;&#xA;&#x9;// separators&#xA;&#x9;char separator;&#xA;&#x9;char paramSeparator;&#xA;&#x9;char keyValueSeparator;&#xA;&#xA;&#x9;std::vector&lt;std::string> fields;&#xA;&#x9;unsigned int fieldNumber;&#xA;&#x9;const std::vector&lt;std::string> split(const std::string data,&#xA;&#x9;&#x9;&#x9;const char separator) const;&#xA;&#xA;protected:&#xA;&#x9;const std::string getField(const std::string field,&#xA;&#x9;&#x9;&#x9;const Event&amp; event) const;&#xA;&#x9;void setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;&#x9;Event&amp; event) const;&#xA;&#xA;public:&#xA;&#x9;Text();&#xA;&#x9;virtual ~Text();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const std::string serialize(const Event event) const;&#xA;&#x9;const std::string serializeParams(const Event event) const;&#xA;&#x9;virtual Event parse(const std::string data) const;&#xA;&#x9;void parseParameters(Event&amp; event, const std::string data) const;&#xA;&#x9;void setFormat(const std::string format);&#xA;&#x9;const std::string getFormat() const;&#xA;&#x9;void setSeparator(const char separator);&#xA;&#x9;void setParamSeparator(const char paramSeparator);&#xA;&#x9;void setKeyValueSeparator(const char keyValueSeparator);&#xA;};&#xA;&#xA;#endif /* TEXT_HH_ */" sourceFile="/*&#xA; * Text.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Text.hh&quot;&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;iostream>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;algorithm>&#xA;&#xA;Text::Text() :&#xA;&#x9;&#x9;Serializer() {&#xA;&#x9;this->setSeparator('|');&#xA;&#x9;this->setParamSeparator(';');&#xA;&#x9;this->setKeyValueSeparator(':');&#xA;&#x9;this->setFormat(&#xA;&#x9;&#x9;&#x9;&quot;eventId|sourceName|capsuleInstance|eventSource|eventKind|seconds|nanoseconds|params&quot;);&#xA;}&#xA;&#xA;Text::~Text() {&#xA;}&#xA;&#xA;void Text::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#x9;std::string separator, paramSeparator, keyValueSeparator, format;&#xA;&#xA;&#x9;separator = this->getConfig(configList, &quot;text.separator&quot;);&#xA;&#x9;paramSeparator = this->getConfig(configList, &quot;text.paramSeparator&quot;);&#xA;&#x9;keyValueSeparator = this->getConfig(configList, &quot;text.keyValueSeparator&quot;);&#xA;&#x9;format = this->getConfig(configList, &quot;text.format&quot;);&#xA;&#xA;&#x9;if (!separator.empty())&#xA;&#x9;&#x9;this->setSeparator(separator[0]);&#xA;&#xA;&#x9;if (!paramSeparator.empty())&#xA;&#x9;&#x9;this->setParamSeparator(paramSeparator[0]);&#xA;&#xA;&#x9;if (!keyValueSeparator.empty())&#xA;&#x9;&#x9;this->setKeyValueSeparator(keyValueSeparator[0]);&#xA;&#xA;&#x9;if (!format.empty())&#xA;&#x9;&#x9;this->setFormat(format);&#xA;&#xA;}&#xA;&#xA;void Text::setFormat(const std::string format) {&#xA;&#x9;this->format = format;&#xA;&#x9;std::vector&lt;std::string> v = this->split(format, this->separator);&#xA;&#xA;&#x9;if (!v.size())&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;this->fields.clear();&#xA;&#x9;this->fields = v;&#xA;&#x9;this->fieldNumber = this->fields.size();&#xA;}&#xA;&#xA;const std::string Text::getFormat() const {&#xA;&#x9;return this->format;&#xA;}&#xA;&#xA;void Text::setSeparator(const char separator) {&#xA;&#x9;this->separator = separator;&#xA;}&#xA;&#xA;void Text::setParamSeparator(const char paramSeparator) {&#xA;&#x9;this->paramSeparator = paramSeparator;&#xA;}&#xA;&#xA;void Text::setKeyValueSeparator(const char keyValueSeparator) {&#xA;&#x9;this->keyValueSeparator = keyValueSeparator;&#xA;}&#xA;&#xA;const std::string Text::serialize(Event event) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it1;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#xA;&#x9;for (it1 = v.begin(); it1 != v.end(); ++it1) {&#xA;&#x9;&#x9;std::string field = *it1;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;out &lt;&lt; this->getField(field, event) &lt;&lt; fieldSeparator;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;const std::string Text::serializeParams(Event event) const {&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;// params&#xA;&#x9;std::map&lt;std::string, std::string>::const_iterator it2;&#xA;&#x9;std::map&lt;std::string, std::string> params = event.getParams();&#xA;&#xA;&#x9;if (params.empty())&#xA;&#x9;&#x9;return out.str();&#xA;&#xA;&#x9;it2 = params.begin();&#xA;&#x9;out &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;&#x9;++it2;&#xA;&#xA;&#x9;for (; it2 != params.end(); ++it2) {&#xA;&#x9;&#x9;out &lt;&lt; this->paramSeparator &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; it2->second;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;Event Text::parse(const std::string data) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;&#x9;std::vector&lt;std::string> values = this->split(data, fieldSeparator);&#xA;&#x9;Event event;&#xA;&#xA;&#x9;if (values.size() &lt; fieldNumber) {&#xA;&#x9;&#x9;std::cout &lt;&lt; &quot;Error in parsing event stream, only &quot; &lt;&lt; values.size()&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; &quot; are parsed \n&quot;;&#xA;&#x9;&#x9;return event;&#xA;&#x9;}&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;for (it = v.begin(); it != v.end(); ++it) {&#xA;&#x9;&#x9;std::string field = *it;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;this->setField(field, values[i], event);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#xA;&#x9;return event;&#xA;}&#xA;&#xA;void Text::parseParameters(Event&amp; event, const std::string data) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v = this->split(data, this->paramSeparator);&#xA;&#x9;std::string temp;&#xA;&#xA;&#x9;if (v.size() == 0)&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;event.clearParams();&#xA;&#xA;&#x9;for (unsigned i = 0; i &lt; v.size(); i++) {&#xA;&#xA;&#x9;&#x9;std::string::size_type sepIndex = 0;&#xA;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;temp = v[i];&#xA;&#xA;&#x9;&#x9;sepIndex = temp.find(this->keyValueSeparator, 0);&#xA;&#x9;&#x9;key = temp.substr(0, sepIndex);&#xA;&#x9;&#x9;value = temp.substr(sepIndex + 1, temp.length());&#xA;&#xA;&#x9;&#x9;event.setParam(key, value);&#xA;&#xA;&#x9;}&#xA;}&#xA;&#xA;const std::vector&lt;std::string> Text::split(const std::string data,&#xA;&#x9;&#x9;const char separator) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v;&#xA;&#x9;std::string temp = &quot;&quot;;&#xA;&#x9;bool newField = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; data.length(); i++) {&#xA;&#x9;&#x9;if (data[i] == separator) {&#xA;&#x9;&#x9;&#x9;newField = false;&#xA;&#x9;&#x9;&#x9;v.push_back(temp);&#xA;&#x9;&#x9;&#x9;temp = &quot;&quot;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;temp = temp + (data[i]);&#xA;&#x9;&#x9;&#x9;newField = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newField)&#xA;&#x9;&#x9;v.push_back(temp);&#xA;&#xA;&#x9;return v;&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the observer&#xA;const std::string Text::getField(const std::string field,&#xA;&#x9;&#x9;const Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;return event.getEventId();&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;return event.getSourceName();&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;return event.getCapsuleInstance();&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventSource();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventKind();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getSeconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getNanoseconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;return this->serializeParams(event);&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Text::setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;event.setEventId(value);&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;event.setSourceName(value);&#xA;        else if (field == &quot;capsuleinstance&quot;)&#xA;                event.setCapsuleInstance(value);&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;event.setEventSource((Event::EventSource) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;event.setEventKind((Event::EventKind) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;event.setSeconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;event.setNanoseconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;this->parseParameters(event, value);&#xA;&#x9;}&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_oRehgqoxEeiNHY6qjNhZ4w" includeFile="/*&#xA; * Socket.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SOCKET_HH_&#xA;#define SOCKET_HH_&#xA;&#xA;#include &lt;arpa/inet.h>&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;sys/select.h>&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Socket: public Method {&#xA;&#xA;private:&#xA;&#x9;int port;&#xA;&#x9;std::string address;&#xA;&#xA;&#x9;fd_set master;    // master file descriptor list&#xA;&#x9;fd_set read_fds;  // temp file descriptor list for select()&#xA;&#x9;int fdmax;        // maximum file descriptor number&#xA;&#xA;&#x9;int listener;     // listening socket descriptor&#xA;&#x9;struct sockaddr_storage remoteaddr; // client address&#xA;&#x9;socklen_t addrlen;&#xA;&#xA;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;struct timeval tv;&#xA;&#xA;public:&#xA;&#x9;Socket();&#xA;&#x9;virtual ~Socket();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect();&#xA;&#x9;virtual void disconnect();&#xA;&#x9;virtual std::string read();&#xA;&#x9;virtual void sendData(std::string data);&#xA;&#xA;&#x9;const int getPort() const;&#xA;&#x9;void setPort(const int port);&#xA;&#xA;&#x9;const std::string getAddress() const;&#xA;&#x9;void setAddress(const std::string address);&#xA;};&#xA;&#xA;#endif /* SOCKET_HH_ */" sourceFile="/*&#xA; * Socket.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Socket.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;string.h>&#xA;#include &lt;unistd.h>&#xA;#include &lt;sys/types.h>&#xA;#include &lt;sys/socket.h>&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;arpa/inet.h>&#xA;#include &lt;netdb.h>&#xA;#include &lt;sstream>&#xA;&#xA;// get sockaddr, IPv4 or IPv6:&#xA;void *get_in_addr(struct sockaddr *sa) {&#xA;&#x9;if (sa->sa_family == AF_INET) {&#xA;&#x9;&#x9;return &amp;(((struct sockaddr_in*) sa)->sin_addr);&#xA;&#x9;}&#xA;&#xA;&#x9;return &amp;(((struct sockaddr_in6*) sa)->sin6_addr);&#xA;}&#xA;&#xA;Socket::Socket() :&#xA;&#x9;&#x9;Method() {&#xA;&#x9;this->setPort(8080);&#xA;&#x9;this->setAddress(&quot;localhost&quot;);&#xA;}&#xA;&#xA;Socket::~Socket() {&#xA;}&#xA;&#xA;void Socket::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;&#x9;std::string port, address;&#xA;&#x9;port = this->getConfig(configList, &quot;port&quot;);&#xA;&#x9;address = this->getConfig(configList, &quot;address&quot;);&#xA;&#xA;&#x9;if (!port.empty())&#xA;&#x9;&#x9;this->setPort(atoi(port.c_str()));&#xA;&#xA;&#x9;if (!address.empty())&#xA;&#x9;&#x9;this->setAddress(address);&#xA;&#xA;&#x9;printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xA;}&#xA;&#xA;const bool Socket::canConnect() const {&#xA;&#x9;return true;&#xA;}&#xA;&#xA;int Socket::connect() {&#xA;&#xA;&#x9;int rv, result = -1;&#xA;&#x9;struct addrinfo hints, *ai, *p;&#xA;&#x9;int yes = 1;   // for setsockopt&#xA;&#xA;&#x9;std::stringstream port;&#xA;&#x9;port &lt;&lt; this->getPort();&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;FD_ZERO(&amp;master);    // clear the master and temp sets&#xA;&#x9;FD_ZERO(&amp;read_fds);&#xA;&#xA;&#x9;// get us a socket and bind it&#xA;&#x9;memset(&amp;hints, 0, sizeof hints);&#xA;&#x9;hints.ai_family = AF_UNSPEC;&#xA;&#x9;hints.ai_socktype = SOCK_STREAM;&#xA;&#x9;hints.ai_flags = AI_PASSIVE;&#xA;&#x9;if ((rv = getaddrinfo(NULL, port.str().c_str(), &amp;hints, &amp;ai)) != 0) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));&#xA;&#x9;&#x9;exit(1);&#xA;&#x9;}&#xA;&#xA;&#x9;for (p = ai; p != NULL; p = p->ai_next) {&#xA;&#x9;&#x9;listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);&#xA;&#x9;&#x9;if (listener &lt; 0) {&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// lose the pesky &quot;address already in use&quot; error message&#xA;&#x9;&#x9;setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));&#xA;&#xA;&#x9;&#x9;if (bind(listener, p->ai_addr, p->ai_addrlen) &lt; 0) {&#xA;&#x9;&#x9;&#x9;close(listener);&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#xA;&#x9;&#x9;// if we got here, it means we didn't get bound&#xA;&#x9;if (p == NULL) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);&#xA;&#x9;&#x9;exit(2);&#xA;&#x9;}&#xA;&#xA;&#x9;freeaddrinfo(ai); // all done with this&#xA;&#xA;&#x9;// listen&#xA;&#x9;if (listen(listener, 10) == -1) {&#xA;&#x9;&#x9;perror(&quot;listen&quot;);&#xA;&#x9;&#x9;exit(3);&#xA;&#x9;}&#xA;&#xA;&#x9;// add the listener to the master set&#xA;&#x9;FD_SET(listener, &amp;master);&#xA;&#xA;&#x9;// keep track of the biggest file descriptor&#xA;&#x9;fdmax = listener; // so far, it's this one&#xA;&#xA;&#x9;return result;&#xA;&#xA;}&#xA;&#xA;void Socket::disconnect() {&#xA;}&#xA;&#xA;std::string Socket::read() {&#xA;&#xA;&#x9;// main loop&#xA;&#x9;read_fds = master; // copy it&#xA;&#x9;int rc = select(fdmax + 1, &amp;read_fds, NULL, NULL, &amp;tv);&#xA;&#x9;if (rc == -1) {&#xA;&#x9;&#x9;perror(&quot;select&quot;);&#xA;&#x9;&#x9;exit(4);&#xA;&#x9;}&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;if (rc == 0) {&#xA;&#x9;&#x9;//   printf(&quot;timeout\n&quot;);&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;// run through the existing connections looking for data to read&#xA;&#x9;for (i = 0; i &lt;= fdmax; i++) {&#xA;&#x9;&#x9;if (FD_ISSET(i, &amp;read_fds)) { // we got one!!&#xA;&#x9;&#x9;&#x9;if (i == listener) {&#xA;&#x9;&#x9;&#x9;&#x9;// handle new connections&#xA;&#x9;&#x9;&#x9;&#x9;addrlen = sizeof remoteaddr;&#xA;&#x9;&#x9;&#x9;&#x9;int newfd = accept(listener, (struct sockaddr *) &amp;remoteaddr,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;addrlen);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (newfd == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;accept&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_SET(newfd, &amp;master); // add to master set&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newfd > fdmax) {    // keep track of the max&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fdmax = newfd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;new connection from %s on &quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;socket %d\n&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inet_ntop(remoteaddr.ss_family,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;get_in_addr((struct sockaddr*) &amp;remoteaddr),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;remoteIP, INET6_ADDRSTRLEN), newfd);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;char buf[256];    // buffer for client data&#xA;&#x9;&#x9;&#x9;&#x9;int nbytes;&#xA;&#x9;&#x9;&#x9;&#x9;// handle data from a client&#xA;&#x9;&#x9;&#x9;&#x9;if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// got error or connection closed by client&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// connection closed&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;socket %d hung up\n&quot;, i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;recv&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;close(i); // bye!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_CLR(i, &amp;master); // remove from master set&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::string str(buf, buf + nbytes - 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return str;&#xA;//    printf(&quot;new data: %s\n&quot;, buf);&#xA;//    // we got some data from a client&#xA;//    int j = 0;&#xA;//    for(j = 0; j &lt;= fdmax; j++) {&#xA;//        // send to everyone!&#xA;//        if (FD_ISSET(j, &amp;master)) {&#xA;//            // except the listener and ourselves&#xA;//            if (j != listener &amp;&amp; j != i) {&#xA;//                if (send(j, buf, nbytes, 0) == -1) {&#xA;//                    perror(&quot;send&quot;);&#xA;//                }&#xA;//            }&#xA;//        }&#xA;//    }&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} // END handle data from client&#xA;&#x9;&#x9;} // END got new incoming connection&#xA;&#x9;} // END looping through file descriptors&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Socket::sendData(std::string data) {&#xA;&#x9;int j = 0;&#xA;&#x9;for (j = 0; j &lt;= fdmax; j++) {&#xA;&#x9;&#x9;// send to everyone&#xA;&#x9;&#x9;if (FD_ISSET(j, &amp;master)) {&#xA;&#x9;&#x9;&#x9;// no exception&#xA;&#x9;&#x9;&#x9;if (j != listener) {&#xA;&#x9;&#x9;&#x9;&#x9;if (write(j, data.c_str(), data.length()) == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//    perror(&quot;does not work\n&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;const int Socket::getPort() const {&#xA;&#x9;return this->port;&#xA;}&#xA;&#xA;void Socket::setPort(const int port) {&#xA;&#x9;this->port = port;&#xA;}&#xA;&#xA;const std::string Socket::getAddress() const {&#xA;&#x9;return this->address;&#xA;}&#xA;&#xA;void Socket::setAddress(const std::string address) {&#xA;&#x9;this->address = address;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_oRfIkKoxEeiNHY6qjNhZ4w" includeFile="/*&#xA; * Config.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CONFIG_HH_&#xA;#define CONFIG_HH_&#xA;&#xA;#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;private:&#xA;&#x9;std::string configFileName;&#xA;&#x9;std::string fieldSeparator;&#xA;&#x9;std::string commentStr;&#xA;&#x9;std::string getConfigPath();&#xA;&#x9;std::map&lt;std::string, std::string> configList;&#xA;&#xA;public:&#xA;&#x9;Config();&#xA;&#x9;~Config();&#xA;&#x9;int load();&#xA;&#x9;void append(std::string key, std::string value);&#xA;&#x9;std::string get(std::string key);&#xA;&#x9;void setConfigFileName(const std::string configFileName);&#xA;&#x9;const std::string getConfigFileName() const;&#xA;&#xA;&#x9;void setFieldSeparator(const std::string fieldSeparator);&#xA;&#x9;const std::string getFieldSeparator() const;&#xA;&#xA;&#x9;void setCommentStr(const std::string commentStr);&#xA;&#x9;const std::string getCommentStr() const;&#xA;&#xA;&#x9;const std::map&lt;std::string, std::string> getConfigList() const;&#xA;};&#xA;&#xA;#endif /* CONFIG_HH_ */" sourceFile="/*&#xA; * Config.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Config.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;&#x9;this->setConfigFileName(&quot;config&quot;);&#xA;&#x9;this->setFieldSeparator(&quot;=&quot;);&#xA;&#x9;this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;&#x9;int result = 0;&#xA;&#x9;std::string prefix = &quot;&quot;;&#xA;&#x9;std::string configPath = this->getConfigPath();&#xA;&#x9;std::ifstream configFile(configPath.c_str());&#xA;&#x9;std::string line;&#xA;&#xA;&#x9;if (configFile.is_open()) {&#xA;&#x9;&#x9;while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;&#x9;// skip the space and comment line&#xA;&#x9;&#x9;&#x9;std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex])&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;!= std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;&#x9;&#x9;&#x9;// Check if it is a definition of a specific rule&#xA;&#x9;&#x9;&#x9;std::string::size_type prefixIndex = line.find(&quot;[&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (prefixIndex != std::string::npos) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;&#x9;&#x9;&#x9;&#x9;std::string p = line.substr(valueNonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#x9;&#x9;&#x9;&#x9;prefix = p;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;&#x9;&#x9;&#x9;if (sepIndex + 1 == line.length())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (valueNonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;&#x9;&#x9;&#x9;if (!prefix.empty())&#xA;&#x9;&#x9;&#x9;&#x9;key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key, value);&#xA;&#x9;&#x9;&#x9;printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; std::endl;&#xA;&#x9;&#x9;result = -1;&#xA;&#x9;}&#xA;&#x9;configFile.close();&#xA;&#x9;return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;&#x9;std::string path;&#xA;&#xA;&#x9;ssize_t len = ::readlink(&quot;/proc/self/exe&quot;, result, sizeof(result));&#xA;&#x9;if (len != -1) {&#xA;&#x9;&#x9;path = std::string(result);&#xA;&#x9;}&#xA;&#xA;// find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;// remove the last fragment of the path&#xA;&#x9;path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;// return the full path&#xA;&#x9;return (path != &quot;&quot;) ?&#xA;&#x9;&#x9;&#x9;path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;&#x9;this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;&#x9;return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;&#x9;this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;&#x9;return this->fieldSeparator;&#xA;}&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;&#x9;this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;&#x9;return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
  <RTCppProperties:AttributeProperties xmi:id="_oRfvoKoxEeiNHY6qjNhZ4w" type="std::deque&lt;std::string>"/>
  <UMLRealTime:RTPort xmi:id="_oRfvoaoxEeiNHY6qjNhZ4w" isWired="false"/>
  <RTCppProperties:ParameterProperties xmi:id="_oRgWsKoxEeiNHY6qjNhZ4w" type="Event"/>
  <RTCppProperties:ParameterProperties xmi:id="_oRgWsaoxEeiNHY6qjNhZ4w" type="Event"/>
  <RTCppProperties:ParameterProperties xmi:id="_oRg9wKoxEeiNHY6qjNhZ4w" type="Event"/>
  <RTCppProperties:ParameterProperties xmi:id="_oRg9waoxEeiNHY6qjNhZ4w" type="Event"/>
  <RTCppProperties:ParameterProperties xmi:id="_oRhk0KoxEeiNHY6qjNhZ4w" type="std::string"/>
  <UMLRealTime:CapsulePart xmi:id="_oU-hcKoxEeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_oVA9sKoxEeiNHY6qjNhZ4w" isNotification="true" isWired="false"/>
  <RTCppProperties:ParameterProperties xmi:id="_oVKusKoxEeiNHY6qjNhZ4w" type="Event::EventSource"/>
  <RTCppProperties:ParameterProperties xmi:id="_oVYxIKoxEeiNHY6qjNhZ4w" type="Event::EventKind"/>
  <RTCppProperties:ParameterProperties xmi:id="_oVkXUKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oVxLoKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oWY2sKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oWm5IKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oW2wwKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <UMLRealTime:RTPort xmi:id="_oYDqoKoxEeiNHY6qjNhZ4w" isNotification="true" isWired="false"/>
  <RTCppProperties:ParameterProperties xmi:id="_oYH8EKoxEeiNHY6qjNhZ4w" type="Event::EventSource"/>
  <RTCppProperties:ParameterProperties xmi:id="_oYOCsKoxEeiNHY6qjNhZ4w" type="Event::EventKind"/>
  <RTCppProperties:ParameterProperties xmi:id="_oYWlkKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oYiLwKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oYz4kKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oY-QoKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oZIosKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <UMLRealTime:RTPort xmi:id="_oZq0MKoxEeiNHY6qjNhZ4w" isNotification="true" isWired="false"/>
  <RTCppProperties:ParameterProperties xmi:id="_oZw60KoxEeiNHY6qjNhZ4w" type="Event::EventSource"/>
  <RTCppProperties:ParameterProperties xmi:id="_oZ5dsKoxEeiNHY6qjNhZ4w" type="Event::EventKind"/>
  <RTCppProperties:ParameterProperties xmi:id="_oaO04KoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oaeFcKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oalaMKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oa48MKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_obCGIKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <UMLRealTime:RTPort xmi:id="_ocQOIKoxEeiNHY6qjNhZ4w" isNotification="true" isWired="false"/>
  <RTCppProperties:ParameterProperties xmi:id="_ocbNQKoxEeiNHY6qjNhZ4w" type="Event::EventSource"/>
  <RTCppProperties:ParameterProperties xmi:id="_ocllUKoxEeiNHY6qjNhZ4w" type="Event::EventKind"/>
  <RTCppProperties:ParameterProperties xmi:id="_ocsTAKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oc8KoKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_odFUkKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_odSv8KoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_odp8UKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <UMLRealTime:RTPort xmi:id="_oeK5sKoxEeiNHY6qjNhZ4w" isNotification="true" isWired="false"/>
  <RTCppProperties:ParameterProperties xmi:id="_oePLIKoxEeiNHY6qjNhZ4w" type="Event::EventSource"/>
  <RTCppProperties:ParameterProperties xmi:id="_oeXuAKoxEeiNHY6qjNhZ4w" type="Event::EventKind"/>
  <RTCppProperties:ParameterProperties xmi:id="_oeg38KoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oeqB4KoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oeykwKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_oe_ZEKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_ofOpoKoxEeiNHY6qjNhZ4w" type="const char *"/>
  <RTCppProperties:ParameterProperties xmi:id="_ohprgKoxEeiNHY6qjNhZ4w" type="Event"/>
  <RTCppProperties:ParameterProperties xmi:id="_ohq5oKoxEeiNHY6qjNhZ4w" type="std::string"/>
  <UMLRealTime:Capsule xmi:id="_7xgWEKr2EeiNHY6qjNhZ4w" base_Class="_7xdS0Kr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:ProtocolContainer xmi:id="_7xg9IKr2EeiNHY6qjNhZ4w" base_Package="_7xdSw6r2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTMessageSet xmi:id="_7xg9Iar2EeiNHY6qjNhZ4w" base_Interface="_7xdSx6r2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTMessageSet xmi:id="_7xg9Iqr2EeiNHY6qjNhZ4w" base_Interface="_7xdSyKr2EeiNHY6qjNhZ4w" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_7xhkMKr2EeiNHY6qjNhZ4w" base_Interface="_7xdSzar2EeiNHY6qjNhZ4w" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_7xhkMar2EeiNHY6qjNhZ4w" base_Collaboration="_7xdSxKr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_7xiLQKr2EeiNHY6qjNhZ4w" isNotification="true" isPublish="true" isWired="false" base_Port="_7xdS0ar2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_7xiLQar2EeiNHY6qjNhZ4w" isWired="false" base_Port="_7xdS1Kr2EeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_7xiLQqr2EeiNHY6qjNhZ4w" base_Pseudostate="_7xdS6qr2EeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTState xmi:id="_7xiyUKr2EeiNHY6qjNhZ4w" base_State="_7xdS66r2EeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_7xiyUar2EeiNHY6qjNhZ4w" base_Region="_7xdS26r2EeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_7xiyUqr2EeiNHY6qjNhZ4w" base_StateMachine="_7xdS2qr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:CapsuleProperties xmi:id="_7xjZYKr2EeiNHY6qjNhZ4w" headerPreface="#include &quot;Method.hh&quot;&#xA;#include &quot;Socket.hh&quot;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Text.hh&quot;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;#include &quot;Config.hh&quot;&#xA;#include &lt;deque>" base_Class="_7xdS0Kr2EeiNHY6qjNhZ4w" privateDeclarations="Method* method;&#xA;Serializer* serializer;&#xA;std::map&lt;std::string, size_t> capsules;&#xA;std::map&lt;std::string, std::string> capsuleTypes;&#xA;Config config;"/>
  <UMLRealTime:RTPort xmi:id="_7xjZYar2EeiNHY6qjNhZ4w" isWired="false" base_Port="_7xdS1ar2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:CapsuleProperties xmi:id="_7xpgAKr2EeiNHY6qjNhZ4w" headerPreface="#include &quot;Event.hh&quot;" implementationPreface="" base_Class="_7xdTAKr2EeiNHY6qjNhZ4w" publicDeclarations="Event event;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_7xr8QKr2EeiNHY6qjNhZ4w" base_Artifact="_7xdS-ar2EeiNHY6qjNhZ4w" includeFile="/*&#xA; * Event.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef EVENT_HH_&#xA;#define EVENT_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;&#xA;class Event {&#xA;&#xA;public:&#xA;typedef enum {&#xA;&#x9;&#x9;Signal,&#xA;&#x9;&#x9;Method,&#xA;&#x9;&#x9;ActionCode,&#xA;&#x9;&#x9;Transition,&#xA;&#x9;&#x9;State,&#xA;&#x9;&#x9;Capsule,&#xA;&#x9;&#x9;Attribute,&#xA;&#x9;&#x9;Timer,&#xA;&#x9;&#x9;UnknownSource, Command&#xA;&#x9;} EventSource;&#xA;&#xA;&#x9;typedef enum {&#xA;&#x9;&#x9;SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;&#x9;&#x9;MethodCall,&#xA;&#x9;&#x9;MethodCallReceive,&#xA;&#x9;&#x9;MethodStartExecute,&#xA;&#x9;&#x9;MethodReturn,&#xA;&#x9;&#x9;MethodFailed,&#xA;&#x9;&#x9;MethodReturnReceived, // Method events&#xA;&#x9;&#x9;ActionStart,&#xA;&#x9;&#x9;ActionEnd, // Action code events&#xA;&#x9;&#x9;TransitionStart,&#xA;&#x9;&#x9;TransitionEnd, // Transition events&#xA;&#x9;&#x9;StateEntryStart,&#xA;&#x9;&#x9;StateEntryEnd,&#xA;&#x9;&#x9;StateExitStart,&#xA;&#x9;&#x9;StateExitEnd,&#xA;&#x9;&#x9;StateIdleStart,&#xA;&#x9;&#x9;StateIdleEnd, // State events&#xA;&#x9;&#x9;CapsuleInstantiate,&#xA;&#x9;&#x9;CapsuleFree, // Capsule events&#xA;&#x9;&#x9;AttributeInstantiate,&#xA;&#x9;&#x9;AttributeFree,&#xA;&#x9;&#x9;AttributeChange, // Attribute events&#xA;&#x9;&#x9;TimerStart,&#xA;&#x9;&#x9;TimerSet,&#xA;&#x9;&#x9;TimerCancel,&#xA;&#x9;&#x9;TimerTimeout, // Timer events&#xA;&#x9;&#x9;UnknownKind, List, Show, Trigger&#xA;&#x9;} EventKind;&#xA;&#xA;private:&#xA;&#x9;std::string capsuleInstance;&#xA;&#x9;std::string sourceName;&#xA;&#x9;std::string eventId;&#xA;&#x9;long seconds;&#xA;&#x9;long nanoseconds;&#xA;&#x9;EventSource eventSource;&#xA;&#x9;EventKind eventKind;&#xA;&#x9;std::map&lt;std::string, std::string> params;&#xA;&#xA;public:&#xA;&#x9;Event(std::string capsuleInstance = &quot;&quot;, std::string sourceName = &quot;&quot;,&#xA;&#x9;&#x9;&#x9;EventSource eventSource = UnknownSource, EventKind eventKind =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;UnknownKind, long seconds = 0, long nanoseconds = 0);&#xA;&#x9;const std::string getCapsuleInstance() const;&#xA;&#x9;void setCapsuleInstance(const std::string capsuleInstance);&#xA;&#x9;const std::string getSourceName() const;&#xA;&#x9;void setSourceName(const std::string sourceName);&#xA;&#x9;const EventSource getEventSource() const;&#xA;&#x9;void setEventSource(const Event::EventSource source);&#xA;&#x9;const EventKind getEventKind() const;&#xA;&#x9;void setEventKind(const Event::EventKind kind);&#xA;&#x9;const long getSeconds() const;&#xA;&#x9;const long getNanoseconds() const;&#xA;&#x9;void setTimestamp();&#xA;&#x9;void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;&#x9;void setSeconds(const long seconds);&#xA;&#x9;void setNanoseconds(const long nanoseconds = 0);&#xA;&#x9;void setEventId(const std::string eventId);&#xA;&#x9;const std::string getEventId() const;&#xA;&#x9;void generateEventId();&#xA;&#x9;const std::map&lt;std::string, std::string> getParams() const;&#xA;&#x9;const std::string getParam(std::string key) const;&#xA;&#x9;void setParams(const std::map&lt;std::string, std::string> params);&#xA;&#x9;void setParam(const std::string key, const std::string value);&#xA;&#x9;void setParam(const std::string key, const int value);&#xA;&#x9;void clearParams();&#xA;};&#xA;&#xA;#endif /* EVENT_HH_ */" sourceFile="/*&#xA; * Event.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;&#xA;Event::Event(std::string capsuleInstance, std::string sourceName,&#xA;&#x9;&#x9;EventSource eventSource, EventKind eventKind, long seconds,&#xA;&#x9;&#x9;long nanoseconds) {&#xA;&#xA;&#x9;this->generateEventId();&#xA;&#x9;this->setCapsuleInstance(capsuleInstance);&#xA;&#x9;this->setSourceName(sourceName);&#xA;&#x9;this->setEventSource(eventSource);&#xA;&#x9;this->setEventKind(eventKind);&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;&#x9;return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;&#x9;this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;const std::string Event::getSourceName() const {&#xA;&#x9;return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;&#x9;this->sourceName = sourceName;&#xA;}&#xA;&#xA;const Event::EventSource Event::getEventSource() const {&#xA;&#x9;return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;&#x9;this->eventSource = source;&#xA;}&#xA;&#xA;const Event::EventKind Event::getEventKind() const {&#xA;&#x9;return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;&#x9;this->eventKind = kind;&#xA;}&#xA;&#xA;const long Event::getSeconds() const {&#xA;&#x9;return this->seconds;&#xA;}&#xA;&#xA;const long Event::getNanoseconds() const {&#xA;&#x9;return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;&#x9;setSeconds(seconds);&#xA;&#x9;this->setNanoseconds(nanoseconds);&#xA;&#x9;this->seconds = seconds;&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;&#x9;this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;&#x9;return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;&#x9;this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;std::stringstream ss;&#xA;&#x9;int r;&#xA;&#x9;r = random();&#xA;&#xA;&#x9;ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;&#x9;this->eventId = ss.str();&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;&#x9;return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;&#x9;bool n = this->params.count(key);&#xA;&#x9;return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const std::map&lt;std::string, std::string> params) {&#xA;&#x9;this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const std::string value) {&#xA;&#x9;if (key.length() >= 1)&#xA;&#x9;&#x9;this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const int value) {&#xA;&#x9;std::stringstream v;&#xA;&#x9;v &lt;&lt; value;&#xA;&#x9;this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;&#x9;this->params.clear();&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_7xsjUKr2EeiNHY6qjNhZ4w" base_Artifact="_7xdS-qr2EeiNHY6qjNhZ4w" includeFile="/*&#xA; * CLIUtils.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CLIUTILS_HH_&#xA;#define CLIUTILS_HH_&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str);&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd);&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;#endif /* CLIUTILS_HH_ */" sourceFile="/*&#xA; * CLIUtils.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str) {&#xA;&#x9;size_t strBegin = str.find_first_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;if (strBegin == std::string::npos)&#xA;&#x9;&#x9;return &quot;&quot;; // no content&#xA;&#xA;&#x9;size_t strEnd = str.find_last_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;size_t strRange = strEnd - strBegin + 1;&#xA;&#x9;return str.substr(strBegin, strRange);&#xA;}&#xA;&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd) {&#xA;&#x9;std::vector&lt;std::string> cmdTokens;&#xA;&#xA;&#x9;std::string command = trim(cmd);&#xA;&#xA;&#x9;if (command.length() == 0)&#xA;&#x9;&#x9;return cmdTokens;&#xA;&#xA;&#x9;std::string tempS = &quot;&quot;;&#xA;&#x9;bool newVar = false;&#xA;&#x9;bool quotation = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; command.length(); i++) {&#xA;&#xA;&#x9;&#x9;char c = command[i];&#xA;&#x9;&#x9;bool isSpaceOrEOL = (c == ' ' || c == '\n');&#xA;&#xA;&#x9;&#x9;if (isSpaceOrEOL) {&#xA;&#xA;&#x9;&#x9;&#x9;if (!newVar)&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (c == '&quot;') {&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;// open a quotation&#xA;&#x9;&#x9;&#x9;&#x9;quotation = true;&#xA;&#x9;&#x9;&#x9;&#x9;if (newVar) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;quotation = false;&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newVar)&#xA;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#xA;&#x9;return cmdTokens;&#xA;}&#xA;&#xA;}&#xA;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_7xsjUar2EeiNHY6qjNhZ4w" base_Artifact="_7xdS-6r2EeiNHY6qjNhZ4w" includeFile="/*&#xA; * Serializer.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SERIALIZER_HH_&#xA;#define SERIALIZER_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;public:&#xA;&#x9;Serializer();&#xA;&#x9;virtual ~Serializer();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const std::string serialize(const Event event) const = 0;&#xA;&#x9;virtual Event parse(const std::string data) const = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* SERIALIZER_HH_ */" sourceFile="/*&#xA; * Serializer.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;&#xA;Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_7xsjUqr2EeiNHY6qjNhZ4w" base_Artifact="_7xdS_Kr2EeiNHY6qjNhZ4w" includeFile="/*&#xA; * Method.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef METHOD_HH_&#xA;#define METHOD_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Method {&#xA;&#xA;public:&#xA;&#x9;Method();&#xA;&#x9;virtual ~Method();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect() = 0;&#xA;&#x9;virtual void disconnect() = 0;&#xA;&#x9;virtual std::string read() = 0;&#xA;&#x9;virtual void sendData(std::string) = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* METHOD_HH_ */&#xA;" sourceFile="/*&#xA; * Method.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;const bool Method::canConnect() const {&#xA;&#x9;return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_7xsjU6r2EeiNHY6qjNhZ4w" base_Artifact="_7xdS_ar2EeiNHY6qjNhZ4w" includeFile="/*&#xA; * Text.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef TEXT_HH_&#xA;#define TEXT_HH_&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Event.hh&quot;&#xA;#include &lt;string>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;unistd.h>&#xA;&#xA;class Text: public Serializer {&#xA;&#xA;private:&#xA;&#x9;std::string format;&#xA;&#xA;&#x9;// separators&#xA;&#x9;char separator;&#xA;&#x9;char paramSeparator;&#xA;&#x9;char keyValueSeparator;&#xA;&#xA;&#x9;std::vector&lt;std::string> fields;&#xA;&#x9;unsigned int fieldNumber;&#xA;&#x9;const std::vector&lt;std::string> split(const std::string data,&#xA;&#x9;&#x9;&#x9;const char separator) const;&#xA;&#xA;protected:&#xA;&#x9;const std::string getField(const std::string field,&#xA;&#x9;&#x9;&#x9;const Event&amp; event) const;&#xA;&#x9;void setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;&#x9;Event&amp; event) const;&#xA;&#xA;public:&#xA;&#x9;Text();&#xA;&#x9;virtual ~Text();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const std::string serialize(const Event event) const;&#xA;&#x9;const std::string serializeParams(const Event event) const;&#xA;&#x9;virtual Event parse(const std::string data) const;&#xA;&#x9;void parseParameters(Event&amp; event, const std::string data) const;&#xA;&#x9;void setFormat(const std::string format);&#xA;&#x9;const std::string getFormat() const;&#xA;&#x9;void setSeparator(const char separator);&#xA;&#x9;void setParamSeparator(const char paramSeparator);&#xA;&#x9;void setKeyValueSeparator(const char keyValueSeparator);&#xA;};&#xA;&#xA;#endif /* TEXT_HH_ */" sourceFile="/*&#xA; * Text.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Text.hh&quot;&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;iostream>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;algorithm>&#xA;&#xA;Text::Text() :&#xA;&#x9;&#x9;Serializer() {&#xA;&#x9;this->setSeparator('|');&#xA;&#x9;this->setParamSeparator(';');&#xA;&#x9;this->setKeyValueSeparator(':');&#xA;&#x9;this->setFormat(&#xA;&#x9;&#x9;&#x9;&quot;eventId|sourceName|capsuleInstance|eventSource|eventKind|seconds|nanoseconds|params&quot;);&#xA;}&#xA;&#xA;Text::~Text() {&#xA;}&#xA;&#xA;void Text::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#x9;std::string separator, paramSeparator, keyValueSeparator, format;&#xA;&#xA;&#x9;separator = this->getConfig(configList, &quot;text.separator&quot;);&#xA;&#x9;paramSeparator = this->getConfig(configList, &quot;text.paramSeparator&quot;);&#xA;&#x9;keyValueSeparator = this->getConfig(configList, &quot;text.keyValueSeparator&quot;);&#xA;&#x9;format = this->getConfig(configList, &quot;text.format&quot;);&#xA;&#xA;&#x9;if (!separator.empty())&#xA;&#x9;&#x9;this->setSeparator(separator[0]);&#xA;&#xA;&#x9;if (!paramSeparator.empty())&#xA;&#x9;&#x9;this->setParamSeparator(paramSeparator[0]);&#xA;&#xA;&#x9;if (!keyValueSeparator.empty())&#xA;&#x9;&#x9;this->setKeyValueSeparator(keyValueSeparator[0]);&#xA;&#xA;&#x9;if (!format.empty())&#xA;&#x9;&#x9;this->setFormat(format);&#xA;&#xA;}&#xA;&#xA;void Text::setFormat(const std::string format) {&#xA;&#x9;this->format = format;&#xA;&#x9;std::vector&lt;std::string> v = this->split(format, this->separator);&#xA;&#xA;&#x9;if (!v.size())&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;this->fields.clear();&#xA;&#x9;this->fields = v;&#xA;&#x9;this->fieldNumber = this->fields.size();&#xA;}&#xA;&#xA;const std::string Text::getFormat() const {&#xA;&#x9;return this->format;&#xA;}&#xA;&#xA;void Text::setSeparator(const char separator) {&#xA;&#x9;this->separator = separator;&#xA;}&#xA;&#xA;void Text::setParamSeparator(const char paramSeparator) {&#xA;&#x9;this->paramSeparator = paramSeparator;&#xA;}&#xA;&#xA;void Text::setKeyValueSeparator(const char keyValueSeparator) {&#xA;&#x9;this->keyValueSeparator = keyValueSeparator;&#xA;}&#xA;&#xA;const std::string Text::serialize(Event event) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it1;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#xA;&#x9;for (it1 = v.begin(); it1 != v.end(); ++it1) {&#xA;&#x9;&#x9;std::string field = *it1;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;out &lt;&lt; this->getField(field, event) &lt;&lt; fieldSeparator;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;const std::string Text::serializeParams(Event event) const {&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;// params&#xA;&#x9;std::map&lt;std::string, std::string>::const_iterator it2;&#xA;&#x9;std::map&lt;std::string, std::string> params = event.getParams();&#xA;&#xA;&#x9;if (params.empty())&#xA;&#x9;&#x9;return out.str();&#xA;&#xA;&#x9;it2 = params.begin();&#xA;&#x9;out &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;&#x9;++it2;&#xA;&#xA;&#x9;for (; it2 != params.end(); ++it2) {&#xA;&#x9;&#x9;out &lt;&lt; this->paramSeparator &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; it2->second;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;Event Text::parse(const std::string data) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;&#x9;std::vector&lt;std::string> values = this->split(data, fieldSeparator);&#xA;&#x9;Event event;&#xA;&#xA;&#x9;if (values.size() &lt; fieldNumber) {&#xA;&#x9;&#x9;std::cout &lt;&lt; &quot;Error in parsing event stream, only &quot; &lt;&lt; values.size()&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; &quot; are parsed \n&quot;;&#xA;&#x9;&#x9;return event;&#xA;&#x9;}&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;for (it = v.begin(); it != v.end(); ++it) {&#xA;&#x9;&#x9;std::string field = *it;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;this->setField(field, values[i], event);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#xA;&#x9;return event;&#xA;}&#xA;&#xA;void Text::parseParameters(Event&amp; event, const std::string data) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v = this->split(data, this->paramSeparator);&#xA;&#x9;std::string temp;&#xA;&#xA;&#x9;if (v.size() == 0)&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;event.clearParams();&#xA;&#xA;&#x9;for (unsigned i = 0; i &lt; v.size(); i++) {&#xA;&#xA;&#x9;&#x9;std::string::size_type sepIndex = 0;&#xA;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;temp = v[i];&#xA;&#xA;&#x9;&#x9;sepIndex = temp.find(this->keyValueSeparator, 0);&#xA;&#x9;&#x9;key = temp.substr(0, sepIndex);&#xA;&#x9;&#x9;value = temp.substr(sepIndex + 1, temp.length());&#xA;&#xA;&#x9;&#x9;event.setParam(key, value);&#xA;&#xA;&#x9;}&#xA;}&#xA;&#xA;const std::vector&lt;std::string> Text::split(const std::string data,&#xA;&#x9;&#x9;const char separator) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v;&#xA;&#x9;std::string temp = &quot;&quot;;&#xA;&#x9;bool newField = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; data.length(); i++) {&#xA;&#x9;&#x9;if (data[i] == separator) {&#xA;&#x9;&#x9;&#x9;newField = false;&#xA;&#x9;&#x9;&#x9;v.push_back(temp);&#xA;&#x9;&#x9;&#x9;temp = &quot;&quot;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;temp = temp + (data[i]);&#xA;&#x9;&#x9;&#x9;newField = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newField)&#xA;&#x9;&#x9;v.push_back(temp);&#xA;&#xA;&#x9;return v;&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the observer&#xA;const std::string Text::getField(const std::string field,&#xA;&#x9;&#x9;const Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;return event.getEventId();&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;return event.getSourceName();&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;return event.getCapsuleInstance();&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventSource();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventKind();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getSeconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getNanoseconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;return this->serializeParams(event);&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Text::setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;event.setEventId(value);&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;event.setSourceName(value);&#xA;        else if (field == &quot;capsuleinstance&quot;)&#xA;                event.setCapsuleInstance(value);&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;event.setEventSource((Event::EventSource) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;event.setEventKind((Event::EventKind) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;event.setSeconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;event.setNanoseconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;this->parseParameters(event, value);&#xA;&#x9;}&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_7xsjVKr2EeiNHY6qjNhZ4w" base_Artifact="_7xdS_qr2EeiNHY6qjNhZ4w" includeFile="/*&#xA; * Socket.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SOCKET_HH_&#xA;#define SOCKET_HH_&#xA;&#xA;#include &lt;arpa/inet.h>&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;sys/select.h>&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Socket: public Method {&#xA;&#xA;private:&#xA;&#x9;int port;&#xA;&#x9;std::string address;&#xA;&#xA;&#x9;fd_set master;    // master file descriptor list&#xA;&#x9;fd_set read_fds;  // temp file descriptor list for select()&#xA;&#x9;int fdmax;        // maximum file descriptor number&#xA;&#xA;&#x9;int listener;     // listening socket descriptor&#xA;&#x9;struct sockaddr_storage remoteaddr; // client address&#xA;&#x9;socklen_t addrlen;&#xA;&#xA;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;struct timeval tv;&#xA;&#xA;public:&#xA;&#x9;Socket();&#xA;&#x9;virtual ~Socket();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect();&#xA;&#x9;virtual void disconnect();&#xA;&#x9;virtual std::string read();&#xA;&#x9;virtual void sendData(std::string data);&#xA;&#xA;&#x9;const int getPort() const;&#xA;&#x9;void setPort(const int port);&#xA;&#xA;&#x9;const std::string getAddress() const;&#xA;&#x9;void setAddress(const std::string address);&#xA;};&#xA;&#xA;#endif /* SOCKET_HH_ */" sourceFile="/*&#xA; * Socket.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Socket.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;string.h>&#xA;#include &lt;unistd.h>&#xA;#include &lt;sys/types.h>&#xA;#include &lt;sys/socket.h>&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;arpa/inet.h>&#xA;#include &lt;netdb.h>&#xA;#include &lt;sstream>&#xA;&#xA;// get sockaddr, IPv4 or IPv6:&#xA;void *get_in_addr(struct sockaddr *sa) {&#xA;&#x9;if (sa->sa_family == AF_INET) {&#xA;&#x9;&#x9;return &amp;(((struct sockaddr_in*) sa)->sin_addr);&#xA;&#x9;}&#xA;&#xA;&#x9;return &amp;(((struct sockaddr_in6*) sa)->sin6_addr);&#xA;}&#xA;&#xA;Socket::Socket() :&#xA;&#x9;&#x9;Method() {&#xA;&#x9;this->setPort(8080);&#xA;&#x9;this->setAddress(&quot;localhost&quot;);&#xA;}&#xA;&#xA;Socket::~Socket() {&#xA;}&#xA;&#xA;void Socket::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;&#x9;std::string port, address;&#xA;&#x9;port = this->getConfig(configList, &quot;port&quot;);&#xA;&#x9;address = this->getConfig(configList, &quot;address&quot;);&#xA;&#xA;&#x9;if (!port.empty())&#xA;&#x9;&#x9;this->setPort(atoi(port.c_str()));&#xA;&#xA;&#x9;if (!address.empty())&#xA;&#x9;&#x9;this->setAddress(address);&#xA;&#xA;&#x9;printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xA;}&#xA;&#xA;const bool Socket::canConnect() const {&#xA;&#x9;return true;&#xA;}&#xA;&#xA;int Socket::connect() {&#xA;&#xA;&#x9;int rv, result = -1;&#xA;&#x9;struct addrinfo hints, *ai, *p;&#xA;&#x9;int yes = 1;   // for setsockopt&#xA;&#xA;&#x9;std::stringstream port;&#xA;&#x9;port &lt;&lt; this->getPort();&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;FD_ZERO(&amp;master);    // clear the master and temp sets&#xA;&#x9;FD_ZERO(&amp;read_fds);&#xA;&#xA;&#x9;// get us a socket and bind it&#xA;&#x9;memset(&amp;hints, 0, sizeof hints);&#xA;&#x9;hints.ai_family = AF_UNSPEC;&#xA;&#x9;hints.ai_socktype = SOCK_STREAM;&#xA;&#x9;hints.ai_flags = AI_PASSIVE;&#xA;&#x9;if ((rv = getaddrinfo(NULL, port.str().c_str(), &amp;hints, &amp;ai)) != 0) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));&#xA;&#x9;&#x9;exit(1);&#xA;&#x9;}&#xA;&#xA;&#x9;for (p = ai; p != NULL; p = p->ai_next) {&#xA;&#x9;&#x9;listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);&#xA;&#x9;&#x9;if (listener &lt; 0) {&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// lose the pesky &quot;address already in use&quot; error message&#xA;&#x9;&#x9;setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));&#xA;&#xA;&#x9;&#x9;if (bind(listener, p->ai_addr, p->ai_addrlen) &lt; 0) {&#xA;&#x9;&#x9;&#x9;close(listener);&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#xA;&#x9;&#x9;// if we got here, it means we didn't get bound&#xA;&#x9;if (p == NULL) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);&#xA;&#x9;&#x9;exit(2);&#xA;&#x9;}&#xA;&#xA;&#x9;freeaddrinfo(ai); // all done with this&#xA;&#xA;&#x9;// listen&#xA;&#x9;if (listen(listener, 10) == -1) {&#xA;&#x9;&#x9;perror(&quot;listen&quot;);&#xA;&#x9;&#x9;exit(3);&#xA;&#x9;}&#xA;&#xA;&#x9;// add the listener to the master set&#xA;&#x9;FD_SET(listener, &amp;master);&#xA;&#xA;&#x9;// keep track of the biggest file descriptor&#xA;&#x9;fdmax = listener; // so far, it's this one&#xA;&#xA;&#x9;return result;&#xA;&#xA;}&#xA;&#xA;void Socket::disconnect() {&#xA;}&#xA;&#xA;std::string Socket::read() {&#xA;&#xA;&#x9;// main loop&#xA;&#x9;read_fds = master; // copy it&#xA;&#x9;int rc = select(fdmax + 1, &amp;read_fds, NULL, NULL, &amp;tv);&#xA;&#x9;if (rc == -1) {&#xA;&#x9;&#x9;perror(&quot;select&quot;);&#xA;&#x9;&#x9;exit(4);&#xA;&#x9;}&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;if (rc == 0) {&#xA;&#x9;&#x9;//   printf(&quot;timeout\n&quot;);&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;// run through the existing connections looking for data to read&#xA;&#x9;for (i = 0; i &lt;= fdmax; i++) {&#xA;&#x9;&#x9;if (FD_ISSET(i, &amp;read_fds)) { // we got one!!&#xA;&#x9;&#x9;&#x9;if (i == listener) {&#xA;&#x9;&#x9;&#x9;&#x9;// handle new connections&#xA;&#x9;&#x9;&#x9;&#x9;addrlen = sizeof remoteaddr;&#xA;&#x9;&#x9;&#x9;&#x9;int newfd = accept(listener, (struct sockaddr *) &amp;remoteaddr,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;addrlen);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (newfd == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;accept&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_SET(newfd, &amp;master); // add to master set&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newfd > fdmax) {    // keep track of the max&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fdmax = newfd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;new connection from %s on &quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;socket %d\n&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inet_ntop(remoteaddr.ss_family,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;get_in_addr((struct sockaddr*) &amp;remoteaddr),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;remoteIP, INET6_ADDRSTRLEN), newfd);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;char buf[256];    // buffer for client data&#xA;&#x9;&#x9;&#x9;&#x9;int nbytes;&#xA;&#x9;&#x9;&#x9;&#x9;// handle data from a client&#xA;&#x9;&#x9;&#x9;&#x9;if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// got error or connection closed by client&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// connection closed&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;socket %d hung up\n&quot;, i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;recv&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;close(i); // bye!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_CLR(i, &amp;master); // remove from master set&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::string str(buf, buf + nbytes - 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return str;&#xA;//    printf(&quot;new data: %s\n&quot;, buf);&#xA;//    // we got some data from a client&#xA;//    int j = 0;&#xA;//    for(j = 0; j &lt;= fdmax; j++) {&#xA;//        // send to everyone!&#xA;//        if (FD_ISSET(j, &amp;master)) {&#xA;//            // except the listener and ourselves&#xA;//            if (j != listener &amp;&amp; j != i) {&#xA;//                if (send(j, buf, nbytes, 0) == -1) {&#xA;//                    perror(&quot;send&quot;);&#xA;//                }&#xA;//            }&#xA;//        }&#xA;//    }&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} // END handle data from client&#xA;&#x9;&#x9;} // END got new incoming connection&#xA;&#x9;} // END looping through file descriptors&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Socket::sendData(std::string data) {&#xA;&#x9;int j = 0;&#xA;&#x9;for (j = 0; j &lt;= fdmax; j++) {&#xA;&#x9;&#x9;// send to everyone&#xA;&#x9;&#x9;if (FD_ISSET(j, &amp;master)) {&#xA;&#x9;&#x9;&#x9;// no exception&#xA;&#x9;&#x9;&#x9;if (j != listener) {&#xA;&#x9;&#x9;&#x9;&#x9;if (write(j, data.c_str(), data.length()) == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//    perror(&quot;does not work\n&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;const int Socket::getPort() const {&#xA;&#x9;return this->port;&#xA;}&#xA;&#xA;void Socket::setPort(const int port) {&#xA;&#x9;this->port = port;&#xA;}&#xA;&#xA;const std::string Socket::getAddress() const {&#xA;&#x9;return this->address;&#xA;}&#xA;&#xA;void Socket::setAddress(const std::string address) {&#xA;&#x9;this->address = address;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_7xsjVar2EeiNHY6qjNhZ4w" base_Artifact="_7xdS_6r2EeiNHY6qjNhZ4w" includeFile="/*&#xA; * Config.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CONFIG_HH_&#xA;#define CONFIG_HH_&#xA;&#xA;#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;private:&#xA;&#x9;std::string configFileName;&#xA;&#x9;std::string fieldSeparator;&#xA;&#x9;std::string commentStr;&#xA;&#x9;std::string getConfigPath();&#xA;&#x9;std::map&lt;std::string, std::string> configList;&#xA;&#xA;public:&#xA;&#x9;Config();&#xA;&#x9;~Config();&#xA;&#x9;int load();&#xA;&#x9;void append(std::string key, std::string value);&#xA;&#x9;std::string get(std::string key);&#xA;&#x9;void setConfigFileName(const std::string configFileName);&#xA;&#x9;const std::string getConfigFileName() const;&#xA;&#xA;&#x9;void setFieldSeparator(const std::string fieldSeparator);&#xA;&#x9;const std::string getFieldSeparator() const;&#xA;&#xA;&#x9;void setCommentStr(const std::string commentStr);&#xA;&#x9;const std::string getCommentStr() const;&#xA;&#xA;&#x9;const std::map&lt;std::string, std::string> getConfigList() const;&#xA;};&#xA;&#xA;#endif /* CONFIG_HH_ */" sourceFile="/*&#xA; * Config.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Config.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;&#x9;this->setConfigFileName(&quot;config&quot;);&#xA;&#x9;this->setFieldSeparator(&quot;=&quot;);&#xA;&#x9;this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;&#x9;int result = 0;&#xA;&#x9;std::string prefix = &quot;&quot;;&#xA;&#x9;std::string configPath = this->getConfigPath();&#xA;&#x9;std::ifstream configFile(configPath.c_str());&#xA;&#x9;std::string line;&#xA;&#xA;&#x9;if (configFile.is_open()) {&#xA;&#x9;&#x9;while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;&#x9;// skip the space and comment line&#xA;&#x9;&#x9;&#x9;std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex])&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;!= std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;&#x9;&#x9;&#x9;// Check if it is a definition of a specific rule&#xA;&#x9;&#x9;&#x9;std::string::size_type prefixIndex = line.find(&quot;[&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (prefixIndex != std::string::npos) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;&#x9;&#x9;&#x9;&#x9;std::string p = line.substr(valueNonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#x9;&#x9;&#x9;&#x9;prefix = p;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;&#x9;&#x9;&#x9;if (sepIndex + 1 == line.length())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (valueNonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;&#x9;&#x9;&#x9;if (!prefix.empty())&#xA;&#x9;&#x9;&#x9;&#x9;key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key, value);&#xA;&#x9;&#x9;&#x9;printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; std::endl;&#xA;&#x9;&#x9;result = -1;&#xA;&#x9;}&#xA;&#x9;configFile.close();&#xA;&#x9;return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;&#x9;std::string path;&#xA;&#xA;&#x9;ssize_t len = ::readlink(&quot;/proc/self/exe&quot;, result, sizeof(result));&#xA;&#x9;if (len != -1) {&#xA;&#x9;&#x9;path = std::string(result);&#xA;&#x9;}&#xA;&#xA;// find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;// remove the last fragment of the path&#xA;&#x9;path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;// return the full path&#xA;&#x9;return (path != &quot;&quot;) ?&#xA;&#x9;&#x9;&#x9;path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;&#x9;this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;&#x9;return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;&#x9;this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;&#x9;return this->fieldSeparator;&#xA;}&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;&#x9;this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;&#x9;return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
  <RTCppProperties:AttributeProperties xmi:id="_7xtKYKr2EeiNHY6qjNhZ4w" type="std::deque&lt;std::string>" base_Property="_7xdS1qr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_7xtKYar2EeiNHY6qjNhZ4w" isWired="false" base_Port="_7xdS16r2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7xtKYqr2EeiNHY6qjNhZ4w" type="Event" base_Parameter="_7xdS8Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7xtxcKr2EeiNHY6qjNhZ4w" type="Event" base_Parameter="_7xdS8ar2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7xtxcar2EeiNHY6qjNhZ4w" type="Event" base_Parameter="_7xdS86r2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7xtxcqr2EeiNHY6qjNhZ4w" type="Event" base_Parameter="_7xdS9Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7xtxc6r2EeiNHY6qjNhZ4w" type="std::string" base_Parameter="_7xdS9qr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:CapsulePart xmi:id="_7x27YKr2EeiNHY6qjNhZ4w" base_Property="_7xxb0Kr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_7x5XoKr2EeiNHY6qjNhZ4w" isNotification="true" isWired="false" base_Port="_7x3icKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7yLrgKr2EeiNHY6qjNhZ4w" type="Event::EventSource" base_Parameter="_7yJ2UKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7ydYUKr2EeiNHY6qjNhZ4w" type="Event::EventKind" base_Parameter="_7yZt8Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7yso4Kr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_7ysB0Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7y0ksar2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_7y0ksKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7y9HkKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_7y8ggKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7zLxEKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_7zLKAKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_7zU7AKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_7zTs4Kr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_70VnoKr2EeiNHY6qjNhZ4w" isNotification="true" isWired="false" base_Port="_70QIEKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_70ZSAKr2EeiNHY6qjNhZ4w" type="Event::EventSource" base_Parameter="_70Yq8Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_70k4MKr2EeiNHY6qjNhZ4w" type="Event::EventKind" base_Parameter="_70jqEKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_70zhsKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_70yTkKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_71A9EKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_709Ssar2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_71L8MKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_71LVIKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_71W7UKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_71VtMar2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_71gFQKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_71feMKr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_72VLsar2EeiNHY6qjNhZ4w" isNotification="true" isWired="false" base_Port="_72VLsKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_72dukKr2EeiNHY6qjNhZ4w" type="Event::EventSource" base_Parameter="_72dHgKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_72j1MKr2EeiNHY6qjNhZ4w" type="Event::EventKind" base_Parameter="_72jOIKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_72rJ8Kr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_72qi4Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_72xQkar2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_72xQkKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_726agKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_725zcKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_73ELgar2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_73ELgKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_73MuYKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_73K5MKr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_73dNEKr2EeiNHY6qjNhZ4w" isNotification="true" isWired="false" base_Port="_73cmAKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_73fCQKr2EeiNHY6qjNhZ4w" type="Event::EventSource" base_Parameter="_73ebMKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_73mXAKr2EeiNHY6qjNhZ4w" type="Event::EventKind" base_Parameter="_73lv8Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_73u54Kr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_73sdoKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_731AgKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_730Zcar2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_737uMKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_737HIKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_74E4IKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_74EREqr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_74OCEKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_74NbAKr2EeiNHY6qjNhZ4w"/>
  <UMLRealTime:RTPort xmi:id="_74egwKr2EeiNHY6qjNhZ4w" isNotification="true" isWired="false" base_Port="_74dSoKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_74g9AKr2EeiNHY6qjNhZ4w" type="Event::EventSource" base_Parameter="_74gV8Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_74mckKr2EeiNHY6qjNhZ4w" type="Event::EventKind" base_Parameter="_74l1gKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_74uYYKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_74txUKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_741tIKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_741GEKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_749B4Kr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_748a0Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_75JPIKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_75IoEKr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_75RyAKr2EeiNHY6qjNhZ4w" type="const char *" base_Parameter="_75RK8Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_76AKwKr2EeiNHY6qjNhZ4w" type="Event" base_Parameter="_753n4Kr2EeiNHY6qjNhZ4w"/>
  <RTCppProperties:ParameterProperties xmi:id="_76AKwar2EeiNHY6qjNhZ4w" type="std::string" base_Parameter="_75-VkKr2EeiNHY6qjNhZ4w"/>
</xmi:XMI>
