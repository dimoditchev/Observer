<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Model xmi:id="_lYTBoAggEea_md0mpENoqg" name="Replication">
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_4HZrcAgoEea_md0mpENoqg" source="UMLRT_Default_top">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_4Ha5kAgoEea_md0mpENoqg" key="top_name" value="Simulator"/>
    </eAnnotations>
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_Lcp5MKpbEeiNHY6qjNhZ4w" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_LcruYKpbEeiNHY6qjNhZ4w" key="language" value="umlrt-cpp"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Package" xmi:id="_rPgFkAggEea_md0mpENoqg" name="ENV">
      <packagedElement xmi:type="uml:Dependency" xmi:id="_vj5dgAghEea_md0mpENoqg" client="_rPgFkAggEea_md0mpENoqg" supplier="_OiTE0AghEea_md0mpENoqg"/>
      <packagedElement xmi:type="uml:Class" xmi:id="_sMZ5EAgoEea_md0mpENoqg" name="ENV" visibility="public" classifierBehavior="_gU8CMAgwEea_md0mpENoqg" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_GXsSgAgvEea_md0mpENoqg" name="ConfigComm" visibility="public" type="_v000cAgsEea_md0mpENoqg" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_NBhGMAgvEea_md0mpENoqg" value="7"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_NBssYAgvEea_md0mpENoqg" value="7"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_b1NrIAjLEea_md0mpENoqg" name="FailureTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_wQHCAAjLEea_md0mpENoqg" name="BITTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_X4ceIAjMEea_md0mpENoqg" name="GeneralTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_lxs5kApkEeaGqPUk-4V4qQ" name="AnnouncmentServer1" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_rXZWwApkEeaGqPUk-4V4qQ" name="AnnouncmentServer2" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_Iq9iAApmEeaGqPUk-4V4qQ" name="AnnouncementServer1Id">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_UZHLMApmEeaGqPUk-4V4qQ" name="AnnouncmentServerTimeout">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_UZHLMQpmEeaGqPUk-4V4qQ" value="6"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_bmibMApmEeaGqPUk-4V4qQ" name="AnnouncementServer2Id">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_fXb_wAxwEeaB2MeL96fedA" name="systemConfig" type="_Y1UDYAg6Eea_md0mpENoqg" aggregation="composite" association="_fXXuUAxwEeaB2MeL96fedA"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_mKfGEOM2EeaTpaLNj-zYpw" name="configTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_G9XLcKuwEeiF8vQsMi0qMg" name="observation" visibility="protected" type="_G3d-1KuwEeiF8vQsMi0qMg" aggregation="composite" isBehavior="true" isService="false">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_G9XygauwEeiF8vQsMi0qMg" value="1"/>
          <upperValue xmi:type="uml:LiteralInteger" xmi:id="_G9YZkKuwEeiF8vQsMi0qMg" value="1"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_gU8CMAgwEea_md0mpENoqg" name="StateMachine1">
          <region xmi:type="uml:Region" xmi:id="_jSIzIAgwEea_md0mpENoqg" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_3Cms8AgwEea_md0mpENoqg" name="Init__ReadConfig__11" source="_npsCMAgwEea_md0mpENoqg" target="_sdehUAgwEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_B6hioAg6Eea_md0mpENoqg" name="ENVInit">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: Intialization\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::Init__ReadConfig__11&quot;,(char *)&quot;Init&quot;,(char *)&quot;ReadConfig&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_nn9HYAgxEea_md0mpENoqg" name="RetryConfig" source="_NvBagAgxEea_md0mpENoqg" target="_sdehUAgwEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_4q_JgAkAEea_md0mpENoqg" name="retry">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: retrying configuation, The transtion Failure -> readConfig was taken \n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::RetryConfig&quot;,(char *)&quot;ConfigFailure&quot;,(char *)&quot;ReadConfig&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_eihL0AkAEea_md0mpENoqg" port="_b1NrIAjLEea_md0mpENoqg">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_G_OzsKuwEeiF8vQsMi0qMg" event="_G_OMoauwEeiF8vQsMi0qMg" port="_G9XLcKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_su1hoAgxEea_md0mpENoqg" name="configLoaded" source="_sdehUAgwEea_md0mpENoqg" target="_dWznsAgxEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_rKgosAigEea_md0mpENoqg" name="LogTransition">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: The transition from ReadConfig -> Config was taken\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::configLoaded&quot;,(char *)&quot;ReadConfig&quot;,(char *)&quot;Config&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_AvcsEAg5Eea_md0mpENoqg" name="configLoaded" port="_mKfGEOM2EeaTpaLNj-zYpw">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_G_1QoKuwEeiF8vQsMi0qMg" event="_G_0CgauwEeiF8vQsMi0qMg" port="_G9XLcKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_zlOKoAgxEea_md0mpENoqg" name="configOK" guard="_24BOUAjEEea_md0mpENoqg" source="_dWznsAgxEea_md0mpENoqg" target="__kywcAgwEea_md0mpENoqg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_24BOUAjEEea_md0mpENoqg" name="checkConfig">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_m0dZMAjGEea_md0mpENoqg" name="checkConfig">
                  <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
                  <language>C++</language>
                  <body>    return systemConfig.ConfigOK;
</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Sw7kAAjHEea_md0mpENoqg" name="configCheckL">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: The configuration is OK, the transition config-> Running was taken, sending signal to servers and clients \n&quot;;
    ConfigComm.StartUp(this->systemConfig).send();
    std::cout&lt;&lt;&quot;ENV: ENV is in  Running State\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::configOK&quot;,(char *)&quot;Config&quot;,(char *)&quot;Running&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_32w4UAgxEea_md0mpENoqg" name="ConfigNOK" source="_dWznsAgxEea_md0mpENoqg" target="_NvBagAgxEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_r3tJQAjJEea_md0mpENoqg" name="LogFailure">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: The configuration is not OK, the transition configCheck-> ConfigFailure was taken\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::ConfigNOK&quot;,(char *)&quot;Config&quot;,(char *)&quot;ConfigFailure&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_BiTZIAmpEea_md0mpENoqg" name="MasterAnnouncment" source="__kywcAgwEea_md0mpENoqg" target="__kywcAgwEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_2u7rQAmqEea_md0mpENoqg" name="RegisterMaster">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Master Annoucment from &quot;&lt;&lt; MasterName&lt;&lt;&quot;\n&quot;;
    if (strcmp((char *)MasterName,&quot;server1&quot;)==0)
    {
    systemConfig.MasterList[0]=true;
    if (AnnouncementServer1Id.isValid())
    AnnouncmentServer1.cancelTimer(AnnouncementServer1Id);
    AnnouncementServer1Id=AnnouncmentServer1.informEvery(UMLRTTimespec(AnnouncmentServerTimeout,0),4);
    }
    else if (strcmp((char *)MasterName,&quot;server2&quot;)==0)
    {
    systemConfig.MasterList[1]=true;
    if (AnnouncementServer2Id.isValid())
    AnnouncmentServer2.cancelTimer(AnnouncementServer2Id);
    AnnouncementServer2Id=AnnouncmentServer2.informEvery(UMLRTTimespec(AnnouncmentServerTimeout,0),4);
    }
    // the following code has been generated
    if ((systemConfig.RunningMode==1)&amp;&amp; (systemConfig.MasterList[0] ) &amp;&amp; (systemConfig.MasterList[1]))
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Violation, there are 2 master in passive mode\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::MasterAnnouncment&quot;,(char *)&quot;Running&quot;,(char *)&quot;Running&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_UGqsMAmpEea_md0mpENoqg" name="MasterAnnouncment" event="_xu1hMgl4Eea_md0mpENoqg" port="_GXsSgAgvEea_md0mpENoqg"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_G_vKAKuwEeiF8vQsMi0qMg" event="_G_ui8quwEeiF8vQsMi0qMg" port="_G9XLcKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WsCs0AnGEeaGqPUk-4V4qQ" name="QueryConfig" source="__kywcAgwEea_md0mpENoqg" target="__kywcAgwEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_488xQAnGEeaGqPUk-4V4qQ" name="configReply">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: The Config request replied at index&quot; &lt;&lt; msg->sapIndex0_&lt;&lt; &quot;\n&quot;;
    int tempid=msg->sapIndex0_;
    ConfigComm.ReplyConfig(systemConfig).sendAt(tempid);


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::QueryConfig&quot;,(char *)&quot;Running&quot;,(char *)&quot;Running&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_nF2QAAnKEeaGqPUk-4V4qQ" name="QueryConfig" event="_BB3b0Al4Eea_md0mpENoqg" port="_GXsSgAgvEea_md0mpENoqg"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_G_VhYauwEeiF8vQsMi0qMg" event="_G_VhYKuwEeiF8vQsMi0qMg" port="_G9XLcKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_J02wAAprEeaGqPUk-4V4qQ" name="Server1Failure" source="__kywcAgwEea_md0mpENoqg" target="__kywcAgwEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_jzDXYAprEeaGqPUk-4V4qQ" name="Server1failure">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: No announcment from server1, remove server1 from masters list\n&quot;;
    systemConfig.MasterList[0]=false;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::Server1Failure&quot;,(char *)&quot;Running&quot;,(char *)&quot;Running&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_X5K_UAprEeaGqPUk-4V4qQ" name="Server1Failure" event="_xM6tkApBEeaGqPUk-4V4qQ" port="_lxs5kApkEeaGqPUk-4V4qQ"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_G_ddMKuwEeiF8vQsMi0qMg" event="_G_boAKuwEeiF8vQsMi0qMg" port="_G9XLcKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_FVtOsApsEeaGqPUk-4V4qQ" name="server2Failure" source="__kywcAgwEea_md0mpENoqg" target="__kywcAgwEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_BjKUsAptEeaGqPUk-4V4qQ" name="Server2Failure">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: No announcment from server2, remove Server2 from masters list\n&quot;;
    systemConfig.MasterList[1]=false;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::server2Failure&quot;,(char *)&quot;Running&quot;,(char *)&quot;Running&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_IX_MkApvEeaGqPUk-4V4qQ" name="server2Failure" event="_xM6tkApBEeaGqPUk-4V4qQ" port="_rXZWwApkEeaGqPUk-4V4qQ"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_G_lZAKuwEeiF8vQsMi0qMg" event="_G_kx8quwEeiF8vQsMi0qMg" port="_G9XLcKuwEeiF8vQsMi0qMg"/>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_npsCMAgwEea_md0mpENoqg" name="Init"/>
            <subvertex xmi:type="uml:State" xmi:id="_sdehUAgwEea_md0mpENoqg" name="ReadConfig">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_EE4RAAigEea_md0mpENoqg" name="ReadConfig">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: Reading the configuration \n&quot;;
    configTimer.informIn(UMLRTTimespec(3,0));
    systemConfig.loadConfig();
    std::cout&lt;&lt;&quot;ENV: Reading the configuration was done\n&quot;;


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::ReadConfig&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_GviZkKuqEeii-Z6YoPPP7w" name="ReadConfig__8">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::ReadConfig&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="__kywcAgwEea_md0mpENoqg" name="Running">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_BfusgAjIEea_md0mpENoqg" name="runningEntry">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::Running&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_GvhygKuqEeii-Z6YoPPP7w" name="Running__7">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::Running&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_NvBagAgxEea_md0mpENoqg" name="ConfigFailure">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_TasAwAjJEea_md0mpENoqg" name="failurEntry">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;ENV: The system is in Failure State, try to reload the config after 10 second\n&quot;;
    FailureTimer.informIn(UMLRTTimespec(10,0),4);


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::ConfigFailure&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_GviZkauqEeii-Z6YoPPP7w" name="ConfigFailure__9">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::ENV::ENV::StateMachine1::Region1::ConfigFailure&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_dWznsAgxEea_md0mpENoqg" name="Config" kind="choice"/>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_G_DNgKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" specification="_G9ZnsKuwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_G9ZnsKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_G_DNgKuwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G9aOwKuwEeiF8vQsMi0qMg" name="source">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G9qtcKuwEeiF8vQsMi0qMg" name="kind">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G91skKuwEeiF8vQsMi0qMg" name="capsuleInstance">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-E9IKuwEeiF8vQsMi0qMg" name="capsuleIndex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-FkMKuwEeiF8vQsMi0qMg" name="signalName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-cJgKuwEeiF8vQsMi0qMg" name="capsuleName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-qL8KuwEeiF8vQsMi0qMg" name="sourceName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-sBIKuwEeiF8vQsMi0qMg" name="reserve1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-soMKuwEeiF8vQsMi0qMg" name="reserve2">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-tPQKuwEeiF8vQsMi0qMg" name="reserve3">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G-3AQKuwEeiF8vQsMi0qMg" name="reserve4">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Dependency" xmi:id="_Y0NjUAxwEeaB2MeL96fedA" client="_sMZ5EAgoEea_md0mpENoqg" supplier="_nk_BAAgzEea_md0mpENoqg"/>
      <packagedElement xmi:type="uml:Dependency" xmi:id="_aaXBwAxwEeaB2MeL96fedA" client="_sMZ5EAgoEea_md0mpENoqg" supplier="_v000cAgsEea_md0mpENoqg"/>
      <packagedElement xmi:type="uml:Association" xmi:id="_fXXuUAxwEeaB2MeL96fedA" memberEnd="_fXb_wAxwEeaB2MeL96fedA _fXcm0AxwEeaB2MeL96fedA">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fXaKkAxwEeaB2MeL96fedA" source="org.eclipse.papyrus">
          <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_fXaxoAxwEeaB2MeL96fedA" key="nature" value="UML_Nature"/>
        </eAnnotations>
        <ownedEnd xmi:type="uml:Property" xmi:id="_fXcm0AxwEeaB2MeL96fedA" name="env" type="_sMZ5EAgoEea_md0mpENoqg" association="_fXXuUAxwEeaB2MeL96fedA"/>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_z1vioAggEea_md0mpENoqg" name="Hosts">
      <packagedElement xmi:type="uml:Dependency" xmi:id="_wVFC0AghEea_md0mpENoqg" client="_z1vioAggEea_md0mpENoqg" supplier="_OiTE0AghEea_md0mpENoqg"/>
      <packagedElement xmi:type="uml:Class" xmi:id="_4_oYIAghEea_md0mpENoqg" name="Host" isActive="true">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_qKL_IAgnEea_md0mpENoqg" name="hostInfo" type="_JesyoAgiEea_md0mpENoqg"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_wp2QEAltEea_md0mpENoqg" name="hostConfig" type="_Y1UDYAg6Eea_md0mpENoqg"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_MFku4Ao-EeaGqPUk-4V4qQ" name="TimerId">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_yqPtMgxwEeaB2MeL96fedA" name="hostinfo" type="_JesyoAgiEea_md0mpENoqg" aggregation="composite" association="_yqOfEAxwEeaB2MeL96fedA"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_z8hNYQxwEeaB2MeL96fedA" name="configuration" type="_Y1UDYAg6Eea_md0mpENoqg" aggregation="composite" association="_z8f_QAxwEeaB2MeL96fedA"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_dCa_wPMYEeauO5SNGpOV7w" name="logfile"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_nU84IPMbEeauO5SNGpOV7w" name="ts">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IWYV4G6NEeSyDdTKostG4Q"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_G0bAoPMlEeauO5SNGpOV7w" name="messageID">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Real"/>
          <defaultValue xmi:type="uml:LiteralReal" xmi:id="_G0bAofMlEeauO5SNGpOV7w"/>
        </ownedAttribute>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_xCGHkAgmEea_md0mpENoqg" name="Server" classifierBehavior="_lT4V0AlLEea_md0mpENoqg" isActive="true">
        <generalization xmi:type="uml:Generalization" xmi:id="_6zESYAgmEea_md0mpENoqg" general="_4_oYIAghEea_md0mpENoqg"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_-3KD0AgvEea_md0mpENoqg" name="ConfigComm" visibility="protected" type="_v000cAgsEea_md0mpENoqg" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_xByucAlLEea_md0mpENoqg" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_xB_iwAlLEea_md0mpENoqg" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_pQ6HcAnMEeaGqPUk-4V4qQ" name="ServerComm" visibility="public" type="_4--ccAnEEeaGqPUk-4V4qQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_etWXMAnOEeaGqPUk-4V4qQ" value="5"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_euWcwAnOEeaGqPUk-4V4qQ" value="5"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_HIvrsApCEeaGqPUk-4V4qQ" name="Master" visibility="public" type="_f2ud0ApBEeaGqPUk-4V4qQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_ZDrx0ApDEeaGqPUk-4V4qQ" name="KeepAliveTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_Vj1U4ApFEeaGqPUk-4V4qQ" name="MasterAnnounceTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_6YR3oApGEeaGqPUk-4V4qQ" name="KeepAliveTimerId">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_Ceg-8ApHEeaGqPUk-4V4qQ" name="KeepAliveTimeOut">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_Ceg-8QpHEeaGqPUk-4V4qQ" value="5"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_N795sApHEeaGqPUk-4V4qQ" name="AnnouncementTimerId">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_YVMXUApHEeaGqPUk-4V4qQ" name="AnnouncementTimeOut">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_YVMXUQpHEeaGqPUk-4V4qQ" value="4"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_855RMAs1EeaGqPUk-4V4qQ" name="Timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_rmnI0OM8EeaTpaLNj-zYpw" name="Slave" visibility="public" type="_f2ud0ApBEeaGqPUk-4V4qQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_G4qRoKuwEeiF8vQsMi0qMg" name="observation" visibility="protected" type="_G3d-1KuwEeiF8vQsMi0qMg" aggregation="composite" isBehavior="true" isService="false">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_G44UEKuwEeiF8vQsMi0qMg" value="1"/>
          <upperValue xmi:type="uml:LiteralInteger" xmi:id="_G44UEauwEeiF8vQsMi0qMg" value="1"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_lT4V0AlLEea_md0mpENoqg" name="ServerStateMachine">
          <region xmi:type="uml:Region" xmi:id="_lvCAwAlLEea_md0mpENoqg" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_myR7kAlNEea_md0mpENoqg" name="Init__StandBy__51" source="_hY-7oAlNEea_md0mpENoqg" target="_jLPjcAlNEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_vR0TsAlNEea_md0mpENoqg" name="InitLog">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: Intialization\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Init__StandBy__51&quot;,(char *)&quot;Init&quot;,(char *)&quot;StandBy&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_fhk4oAlOEea_md0mpENoqg" name="StandBy__CheckConfig__61" source="_jLPjcAlNEea_md0mpENoqg" target="_Rrrc0AlvEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_jEMbEAlfEea_md0mpENoqg" name="StartupServer">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: StartingUp\n&quot;;
    this->hostConfig=config;
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Configuration is:&quot;&lt;&lt; config.RunningMode&lt;&lt;&quot;\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::StandBy__CheckConfig__61&quot;,(char *)&quot;StandBy&quot;,(char *)&quot;CheckConfig&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_aihU8AlfEea_md0mpENoqg" event="_MloQ4AguEea_md0mpENoqg" port="_-3KD0AgvEea_md0mpENoqg"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_G8PxIKuwEeiF8vQsMi0qMg" event="_G8PKEquwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_l1V8wAlOEea_md0mpENoqg" name="ServerFaliure" source="_UrcckAlOEea_md0mpENoqg" target="_hgSoEAlOEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_xgwrEApLEeaGqPUk-4V4qQ" name="CancellTimer">
                <language>C++</language>
                <body>    if (KeepAliveTimerId.isValid())
    KeepAliveTimer.cancelTimer(KeepAliveTimerId);
    if (AnnouncementTimerId.isValid())
    MasterAnnounceTimer.cancelTimer(AnnouncementTimerId);
    if (TimerId.isValid())
    Timer.cancelTimer(TimerId);
    int r=random()%30+5;
    Timer.informEvery(UMLRTTimespec(r,0),4);
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Failure,  will recover after &quot; &lt;&lt; r &lt;&lt; &quot; seconds\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::ServerFaliure&quot;,(char *)&quot;RunAsMaster&quot;,(char *)&quot;Failure&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_qt8XoApEEeaGqPUk-4V4qQ" name="Failure" port="_855RMAs1EeaGqPUk-4V4qQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_G8-w8auwEeiF8vQsMi0qMg" event="_G8-w8KuwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_pku_oAlOEea_md0mpENoqg" name="Recover" source="_hgSoEAlOEea_md0mpENoqg" target="_Pyhf8Ap5EeaGqPUk-4V4qQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_yH_CUAp7EeaGqPUk-4V4qQ" name="Recover">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: is recovering\n&quot;;
    if (TimerId.isValid())
    Timer.cancelTimer(TimerId);


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Recover&quot;,(char *)&quot;Failure&quot;,(char *)&quot;Choice1&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_uSw5sAp6EeaGqPUk-4V4qQ" name="Timeout" port="_855RMAs1EeaGqPUk-4V4qQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_G9V9UKuwEeiF8vQsMi0qMg" event="_G8-w8KuwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_iM5MYAlvEea_md0mpENoqg" name="initTimer" guard="_zq0b0AlvEea_md0mpENoqg" source="_Rrrc0AlvEea_md0mpENoqg" target="_UrcckAlOEea_md0mpENoqg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_zq0b0AlvEea_md0mpENoqg" name="CheckConfig">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_XImjEAlwEea_md0mpENoqg" name="CheckConfig">
                  <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
                  <language>C++</language>
                  <body>    if ((hostConfig.RunningMode==0) ||
    ((hostConfig.RunningMode==1) &amp;&amp; (strcmp(hostConfig.MasterName,this->getName())==0)))
    return true;
    else 
    return false;
</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_nB58AApKEeaGqPUk-4V4qQ" name="InitTimer">
                <language>C++</language>
                <body>logfile&lt;&lt;&quot;capsuleName&quot;&lt;&lt;&quot;,messageType,&quot;&lt;&lt;&quot;messageID&quot;&lt;&lt;&quot;,&quot;&lt;&lt;&quot;second&quot;&lt;&lt;&quot;,&quot;&lt;&lt;&quot;nano&quot;&lt;&lt;&quot;\n&quot;;    
//UMLRTTimespec ts;
    //ts.getclock(ts);
    //this->setTimePointSecond();
    logfile.open(this->getName());
    //if (logfile.is_open())
    //	logfile&lt;&lt;ts.tv_sec&lt;&lt;&quot;:&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;
    //logfile.close();
    int r=random()%30+5;
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: will go fail state after &quot;&lt;&lt; r &lt;&lt; &quot;second\n&quot;;
    //TimerId=Timer.informEvery(UMLRTTimespec(r,0),4);
   TimerId=Timer.informEvery(UMLRTTimespec(3600000,0),4);
    KeepAliveTimerId=KeepAliveTimer.informEvery(UMLRTTimespec(KeepAliveTimeOut,0),4);
    AnnouncementTimerId=MasterAnnounceTimer.informEvery(UMLRTTimespec(AnnouncementTimeOut,0),4);


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::initTimer&quot;,(char *)&quot;CheckConfig&quot;,(char *)&quot;RunAsMaster&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_pWyMEApzEeaGqPUk-4V4qQ" port="_Vj1U4ApFEeaGqPUk-4V4qQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_kdt_gAlvEea_md0mpENoqg" name="BeSlave" source="_Rrrc0AlvEea_md0mpENoqg" target="_88oQAKozEeiNHY6qjNhZ4w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HPo186uqEeii-Z6YoPPP7w" name="BeSlave__29">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::BeSlave&quot;,(char *)&quot;CheckConfig&quot;,(char *)&quot;Pseudo1&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_aRWloAnREeaGqPUk-4V4qQ" name="ServiceRequest" source="_UrcckAlOEea_md0mpENoqg" target="_UrcckAlOEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_jf2tMAosEeaGqPUk-4V4qQ" name="ReplyRequest">
                <language>C++</language>
                <body>   //messageID=messageID+1;
    ts.getclock(ts);
    if (logfile.is_open())
	logfile&lt;&lt;this->getName()&lt;&lt;&quot;,ClientRequest,&quot;&lt;&lt;messageID&lt;&lt;&quot;,,&quot;&lt;&lt;&quot;\n&quot;;
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Message from client replied at index &quot;&lt;&lt;msg->sapIndex0_&lt;&lt;&quot;\n&quot;;
    int tempid=msg->sapIndex0_;
    ServerComm.Reply(0).sendAt(tempid);
    int j=1;
    for (int i=0;i&lt;=1000000;i++)
	j=j+1;
    j=j+1;
    std::cout&lt;&lt;j&lt;&lt;&quot;\n&quot;;
    //ts.getclock(ts);
    //if (logfile.is_open())
    //logfile&lt;&lt;&quot;CleintReply,&quot;&lt;&lt;messageID&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_sec&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;
    //logfile.flush();


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::ServiceRequest&quot;,(char *)&quot;RunAsMaster&quot;,(char *)&quot;RunAsMaster&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_2NJiIAnREeaGqPUk-4V4qQ" event="_G3K7UAnFEeaGqPUk-4V4qQ" port="_pQ6HcAnMEeaGqPUk-4V4qQ"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_G78PIKuwEeiF8vQsMi0qMg" event="_G77oE6uwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_2jFDsApyEeaGqPUk-4V4qQ" name="MasterAnnounce" source="_UrcckAlOEea_md0mpENoqg" target="_UrcckAlOEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_1qc9IApzEeaGqPUk-4V4qQ" name="MasterAnnounce">
                <language>C++</language>
                <body>    //messageID=messageID+1;
    ts.getclock(ts);
    if (logfile.is_open())
	logfile&lt;&lt;&quot;keepAliveStart,&quot;&lt;&lt;messageID&lt;&lt;&quot;,,&quot;&lt;&lt;&quot;\n&quot;;
    if (AnnouncementTimerId.isValid())
    MasterAnnounceTimer.cancelTimer(AnnouncementTimerId);
    AnnouncementTimerId=MasterAnnounceTimer.informEvery(UMLRTTimespec(AnnouncementTimeOut,0),4);
    int j=1;
    for (int i=0;i&lt;=1000000;i++)
	j=j+1;
    j=j+1;
    std::cout&lt;&lt;j&lt;&lt;&quot;\n&quot;;



Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::MasterAnnounce&quot;,(char *)&quot;RunAsMaster&quot;,(char *)&quot;RunAsMaster&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_8oV_gAp3EeaGqPUk-4V4qQ" name="MasterAnnouncment" port="_Vj1U4ApFEeaGqPUk-4V4qQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_G9Rr4KuwEeiF8vQsMi0qMg" event="_G9RE0auwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_ElyUAAp0EeaGqPUk-4V4qQ" name="KeepAlive" source="_UrcckAlOEea_md0mpENoqg" target="_UrcckAlOEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_9ovXcAp1EeaGqPUk-4V4qQ" name="SendKeepAlive">
                <language>C++</language>
                <body>    if (KeepAliveTimerId.isValid())
    KeepAliveTimer.cancelTimer(KeepAliveTimerId);
    KeepAliveTimerId=KeepAliveTimer.informEvery(UMLRTTimespec(KeepAliveTimeOut,0),4);
    if (hostConfig.RunningMode==1)
    Master.IAmAlive((char *)this->getName()).send();
    std::cout&lt;&lt;&quot;Master: Keep Alive is sent\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::KeepAlive&quot;,(char *)&quot;RunAsMaster&quot;,(char *)&quot;RunAsMaster&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_RAsgEAp1EeaGqPUk-4V4qQ" name="KeppAlive" port="_ZDrx0ApDEeaGqPUk-4V4qQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_G8oLoKuwEeiF8vQsMi0qMg" event="_G8nkkauwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_i_dO4Ap5EeaGqPUk-4V4qQ" name="ActiveMode" guard="_OyNyIAp8EeaGqPUk-4V4qQ" source="_Pyhf8Ap5EeaGqPUk-4V4qQ" target="_kLngAAp5EeaGqPUk-4V4qQ">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_OyNyIAp8EeaGqPUk-4V4qQ" name="checkConfig">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_OyOZMAp8EeaGqPUk-4V4qQ" name="checkConfig">
                  <language>C++</language>
                  <body>    if (hostConfig.RunningMode==0)
    return true;
    else return false;
</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HP5UoKuqEeii-Z6YoPPP7w" name="ActiveMode__49">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::ActiveMode&quot;,(char *)&quot;Choice1&quot;,(char *)&quot;BeMaster&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_pYtP8Ap5EeaGqPUk-4V4qQ" name="BeingMaster" source="_kLngAAp5EeaGqPUk-4V4qQ" target="_UrcckAlOEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_lf6aoAqTEeaGqPUk-4V4qQ" name="BeMaster">
                <language>C++</language>
                <body>    int r=random()%30+5;
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: will go fail state after &quot;&lt;&lt; r &lt;&lt; &quot;second\n&quot;;
    //TimerId=Timer.informEvery(360000);
    TimerId=Timer.informEvery(UMLRTTimespec(3600000,0),4);
    KeepAliveTimerId=KeepAliveTimer.informEvery(UMLRTTimespec(KeepAliveTimeOut,0),4);
    AnnouncementTimerId=MasterAnnounceTimer.informEvery(UMLRTTimespec(AnnouncementTimeOut,0),4);


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::BeingMaster&quot;,(char *)&quot;BeMaster&quot;,(char *)&quot;RunAsMaster&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_wPvR0Ap8EeaGqPUk-4V4qQ" name="PassiveMode" source="_Pyhf8Ap5EeaGqPUk-4V4qQ" target="_887yAKozEeiNHY6qjNhZ4w">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HPsgUKuqEeii-Z6YoPPP7w" name="PassiveMode__32">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::PassiveMode&quot;,(char *)&quot;Choice1&quot;,(char *)&quot;Pseudo2&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_QEtu0AsLEeaGqPUk-4V4qQ" name="purgeotherMessage" source="_hgSoEAlOEea_md0mpENoqg" target="_hgSoEAlOEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HP2RUKuqEeii-Z6YoPPP7w" name="purgeotherMessage__43">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::purgeotherMessage&quot;,(char *)&quot;Failure&quot;,(char *)&quot;Failure&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_WQkXoAsMEeaGqPUk-4V4qQ" name="purge" event="_f4LPUApBEeaGqPUk-4V4qQ" port="_pQ6HcAnMEeaGqPUk-4V4qQ _HIvrsApCEeaGqPUk-4V4qQ"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_bHEIAONOEeaTpaLNj-zYpw" name="ExitPoint1__BeMaster__45" source="_M8iZcONCEeaTpaLNj-zYpw" target="_kLngAAp5EeaGqPUk-4V4qQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HP3fcKuqEeii-Z6YoPPP7w" name="ExitPoint1__BeMaster__45__46">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::ExitPoint1__BeMaster__45&quot;,(char *)&quot;ExitPoint1&quot;,(char *)&quot;BeMaster&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_hY-7oAlNEea_md0mpENoqg" name="Init"/>
            <subvertex xmi:type="uml:State" xmi:id="_jLPjcAlNEea_md0mpENoqg" name="StandBy">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_HPfE8KuqEeii-Z6YoPPP7w" name="StandBy__20">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::StandBy&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HPfE8auqEeii-Z6YoPPP7w" name="StandBy__21">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::StandBy&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_UrcckAlOEea_md0mpENoqg" name="RunAsMaster">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_YzyAkAlyEea_md0mpENoqg" name="RunAsMasterEntry">
                <language>C++</language>
                <body>    
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Run as Master now\n&quot;;
    ConfigComm.IAMMaster((char *)this->getName()).send();
    ts.getclock(ts);
    //messageID=messageID+1;
    if (logfile.is_open())
	logfile&lt;&lt;this->getName()&lt;&lt;&quot;,TranstionEnd,&quot;&lt;&lt;messageID&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_sec&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;
     logfile.flush();


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::RunAsMaster&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_cjKg0PMsEeauO5SNGpOV7w" name="startTransition">
                <language>C++</language>
                <body>    ts.getclock(ts);
    messageID=messageID+1;
    if (logfile.is_open())
	logfile&lt;&lt;this->getName()&lt;&lt;&quot;,TranstionStart,&quot;&lt;&lt;messageID&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_sec&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;
     //logfile.flush();

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::RunAsMaster&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_hgSoEAlOEea_md0mpENoqg" name="Failure">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_GNo-cAp7EeaGqPUk-4V4qQ" name="SetTimer">
                <language>C++</language>
                <body>    //------


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Failure&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HPfsAKuqEeii-Z6YoPPP7w" name="Failure__22">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Failure&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_Rrrc0AlvEea_md0mpENoqg" name="CheckConfig" kind="choice"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_Pyhf8Ap5EeaGqPUk-4V4qQ" name="Choice1" kind="choice"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_kLngAAp5EeaGqPUk-4V4qQ" name="BeMaster" kind="junction"/>
            <subvertex xmi:type="uml:State" xmi:id="_2g5S0ONBEeaTpaLNj-zYpw" name="Backup">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_M8iZcONCEeaTpaLNj-zYpw" name="ExitPoint1" kind="exitPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_88oQAKozEeiNHY6qjNhZ4w" name="Pseudo1" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_887yAKozEeiNHY6qjNhZ4w" name="Pseudo2" kind="entryPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_HPg6IKuqEeii-Z6YoPPP7w" name="Backup__23">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HPg6IauqEeii-Z6YoPPP7w" name="Backup__24">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
              <region xmi:type="uml:Region" xmi:id="_ThAzEONCEeaTpaLNj-zYpw" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_LmVmEONDEeaTpaLNj-zYpw" name="NokeepAlive" source="_ZaK1gAlOEea_md0mpENoqg" target="_Px2BIAqSEeaGqPUk-4V4qQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_LmWNIONDEeaTpaLNj-zYpw" name="CancellTimer">
                    <language>C++</language>
                    <body>    //if (KeepAliveTimerId.isValid())
    //	KeepAliveTimer.cancelTimer(KeepAliveTimerId);
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: No keep Alive message from Master, Try to be Master-------\n&quot;;
    //TimerId=Timer.informEvery(UMLRTTimespec(2,0),4);
    ConfigComm.QueryConfig().send();
    //std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: trying to be Master\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::NokeepAlive&quot;,(char *)&quot;RunAsSlave&quot;,(char *)&quot;TryBeMaster&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_LmWNIeNDEeaTpaLNj-zYpw" name="KeepAliveTimer" port="_ZDrx0ApDEeaGqPUk-4V4qQ">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                  <trigger xmi:type="uml:Trigger" xmi:id="_G821IKuwEeiF8vQsMi0qMg" event="_G8nkkauwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_R_7lYONDEeaTpaLNj-zYpw" name="BackToSlave" source="_Px2BIAqSEeaGqPUk-4V4qQ" target="_ZaK1gAlOEea_md0mpENoqg">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_R_7lYeNDEeaTpaLNj-zYpw" name="MasterRecovered">
                    <language>C++</language>
                    <body>    //std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: The Master recovered itself, backing to slave mode\n&quot;;
    //if (TimerId.isValid())
    //	Timer.cancelTimer(TimerId);


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::BackToSlave&quot;,(char *)&quot;TryBeMaster&quot;,(char *)&quot;RunAsSlave&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_R_7lYuNDEeaTpaLNj-zYpw" name="BackToSlave" event="_xM6tkApBEeaGqPUk-4V4qQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_XafJkONDEeaTpaLNj-zYpw" name="ReplyConfig" source="_Px2BIAqSEeaGqPUk-4V4qQ" target="_NU8OsAszEeaGqPUk-4V4qQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HQFh4KuqEeii-Z6YoPPP7w" name="ReplyConfig__59">
                    <language>C++</language>
                    <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::ReplyConfig&quot;,(char *)&quot;TryBeMaster&quot;,(char *)&quot;Choice2&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_XafJkeNDEeaTpaLNj-zYpw" name="ConfigReply" event="_Iv3CQAl4Eea_md0mpENoqg" port="_-3KD0AgvEea_md0mpENoqg"/>
                  <trigger xmi:type="uml:Trigger" xmi:id="_G8Xs8auwEeiF8vQsMi0qMg" event="_G8Xs8KuwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_dg_NwONDEeaTpaLNj-zYpw" name="backtoslave1" source="_NU8OsAszEeaGqPUk-4V4qQ" target="_5yefMAszEeaGqPUk-4V4qQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HPvjoKuqEeii-Z6YoPPP7w" name="backtoslave1__37">
                    <language>C++</language>
                    <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::backtoslave1&quot;,(char *)&quot;Choice2&quot;,(char *)&quot;Slave&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_dg_NweNDEeaTpaLNj-zYpw" name="backtoslave" source="_5yefMAszEeaGqPUk-4V4qQ" target="_ZaK1gAlOEea_md0mpENoqg">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HQBQcKuqEeii-Z6YoPPP7w" name="backtoslave__56">
                    <language>C++</language>
                    <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::backtoslave&quot;,(char *)&quot;Slave&quot;,(char *)&quot;RunAsSlave&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_mHBPcONDEeaTpaLNj-zYpw" name="KeepAliveMsg" source="_ZaK1gAlOEea_md0mpENoqg" target="_ZaK1gAlOEea_md0mpENoqg">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_mHBPceNDEeaTpaLNj-zYpw" name="ProcessKeppAlive">
                    <language>C++</language>
                    <body>    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Keep Alive Message from &quot;&lt;&lt; ServerName&lt;&lt;&quot;\n&quot;;
    //if (KeepAliveTimerId.isValid())
    //	KeepAliveTimer.cancelTimer(KeepAliveTimerId);
    //KeepAliveTimerId=KeepAliveTimer.informEvery(UMLRTTimespec(6,0),4);


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::KeepAliveMsg&quot;,(char *)&quot;RunAsSlave&quot;,(char *)&quot;RunAsSlave&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_mHBPcuNDEeaTpaLNj-zYpw" name="IAmlive" event="_xM6tkApBEeaGqPUk-4V4qQ" port="_rmnI0OM8EeaTpaLNj-zYpw"/>
                  <trigger xmi:type="uml:Trigger" xmi:id="_G7tloKuwEeiF8vQsMi0qMg" event="_G7s-kquwEeiF8vQsMi0qMg" port="_G4qRoKuwEeiF8vQsMi0qMg"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_-mdZ0ONDEeaTpaLNj-zYpw" name="Initial1__RunAsSlave__34" source="_8WMAUONDEeaTpaLNj-zYpw" target="_ZaK1gAlOEea_md0mpENoqg">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HPtHYKuqEeii-Z6YoPPP7w" name="Initial1__RunAsSlave__34__35">
                    <language>C++</language>
                    <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::Initial1__RunAsSlave__34&quot;,(char *)&quot;Initial1&quot;,(char *)&quot;RunAsSlave&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_CPd8UONOEeaTpaLNj-zYpw" name="CheckNoMaster" guard="_CPd8UeNOEeaTpaLNj-zYpw" source="_NU8OsAszEeaGqPUk-4V4qQ" target="_M8iZcONCEeaTpaLNj-zYpw">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_CPd8UeNOEeaTpaLNj-zYpw" name="CheckNoServer">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_CPd8UuNOEeaTpaLNj-zYpw" name="checkNoServer">
                      <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
                      <language>C++</language>
                      <body>    std::cout&lt;&lt;&quot;00000----------------------------------------------------000000\n&quot;;
    this->hostConfig=config;
    if (!(this->hostConfig.MasterList[0] || this->hostConfig.MasterList[1]))
    {
    //Echo.Echo().send();
    //Timer.cancelTimer(TimerId);
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: No one is Master, I am going to Be master\n&quot;;
    return true;
    }
    else if ((strcmp((char*)this->getName(),&quot;server1&quot;)==0) &amp;&amp; (config.MasterList[1]==false))
    {
    //Echo.Echo().send();
    //Timer.cancelTimer(TimerId);
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: No one is Master, I am going to Be master\n&quot;;
    return true;
    }
    else if ((strcmp((char *)this->getName(),&quot;server2&quot;))==0 &amp;&amp; (config.MasterList[0]==false))
    {
    //Echo.Echo().send();
    //Timer.cancelTimer(TimerId);
    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: No one is Master, I am going to Be master\n&quot;;
    return true;
    }
    std::cout&lt;&lt;&quot;11111111-----------------------------------------111111111111\n&quot;;
    return false;
</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HP1qQKuqEeii-Z6YoPPP7w" name="CheckNoMaster__41">
                    <language>C++</language>
                    <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::CheckNoMaster&quot;,(char *)&quot;Choice2&quot;,(char *)&quot;ExitPoint1&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
                  </effect>
                </transition>
                <subvertex xmi:type="uml:State" xmi:id="_Px2BIAqSEeaGqPUk-4V4qQ" name="TryBeMaster">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_6FKVcAqVEeaGqPUk-4V4qQ" name="trytobemasterinit">
                    <language>C++</language>
                    <body>    //std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: trying to Be Master ------------\n&quot;;


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::TryBeMaster&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
                  </entry>
                  <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HPivUKuqEeii-Z6YoPPP7w" name="TryBeMaster__26">
                    <language>C++</language>
                    <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::TryBeMaster&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
                  </exit>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_NU8OsAszEeaGqPUk-4V4qQ" name="Choice2" kind="choice"/>
                <subvertex xmi:type="uml:State" xmi:id="_ZaK1gAlOEea_md0mpENoqg" name="RunAsSlave">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_JeHBoAlzEea_md0mpENoqg" name="RunAsSlaveEntry">
                    <language>C++</language>
                    <body>    std::cout&lt;&lt;this->getName()&lt;&lt;&quot;: Running as Slave now\n&quot;;
    //if (KeepAliveTimerId.isValid())
    //	KeepAliveTimer.cancelTimer(KeepAliveTimerId);
    KeepAliveTimerId=KeepAliveTimer.informIn(UMLRTTimespec(6,0),4);


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::RunAsSlave&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
                  </entry>
                  <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HPhhMKuqEeii-Z6YoPPP7w" name="RunAsSlave__25">
                    <language>C++</language>
                    <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Server::ServerStateMachine::Region1::Backup::Region1::RunAsSlave&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
                  </exit>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_5yefMAszEeaGqPUk-4V4qQ" name="Slave" kind="junction"/>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_8WMAUONDEeaTpaLNj-zYpw" name="Initial1"/>
              </region>
            </subvertex>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_G7PEgKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" specification="_G5EhUKuwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_G5EhUKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_G7PEgKuwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G5OSUKuwEeiF8vQsMi0qMg" name="source">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G5qXMKuwEeiF8vQsMi0qMg" name="kind">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G5_HUKuwEeiF8vQsMi0qMg" name="capsuleInstance">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G6alIKuwEeiF8vQsMi0qMg" name="capsuleIndex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G6bMMKuwEeiF8vQsMi0qMg" name="signalName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G6myYKuwEeiF8vQsMi0qMg" name="capsuleName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G6zmsKuwEeiF8vQsMi0qMg" name="sourceName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G6zmsauwEeiF8vQsMi0qMg" name="reserve1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G60NwKuwEeiF8vQsMi0qMg" name="reserve2">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G634IKuwEeiF8vQsMi0qMg" name="reserve3">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G7CQMKuwEeiF8vQsMi0qMg" name="reserve4">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_zpdLYAgmEea_md0mpENoqg" name="Client" classifierBehavior="_BKT8EAlKEea_md0mpENoqg" isActive="true">
        <generalization xmi:type="uml:Generalization" xmi:id="_5utSYAgmEea_md0mpENoqg" general="_4_oYIAghEea_md0mpENoqg"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_g3nG4AgvEea_md0mpENoqg" name="ConfigComm" visibility="protected" type="_v000cAgsEea_md0mpENoqg" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_kSO0IAliEea_md0mpENoqg" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_kSfS0AliEea_md0mpENoqg" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_iLeRcAmuEea_md0mpENoqg" name="RequestTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_oWg3YAmuEea_md0mpENoqg" name="ConfigTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_tP9SkAmuEea_md0mpENoqg" name="ResponseTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_fL3OQAnFEeaGqPUk-4V4qQ" name="Server1Comm" visibility="public" type="_4--ccAnEEeaGqPUk-4V4qQ" isOrdered="true" aggregation="composite" isBehavior="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_jNC1oAnOEeaGqPUk-4V4qQ" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_jNNNsAnOEeaGqPUk-4V4qQ" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_lRZpIAnFEeaGqPUk-4V4qQ" name="Server2Comm" visibility="public" type="_4--ccAnEEeaGqPUk-4V4qQ" isOrdered="true" aggregation="composite" isBehavior="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_pIHs8AnOEeaGqPUk-4V4qQ" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_pIOaoAnOEeaGqPUk-4V4qQ" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_8sGy4AovEeaGqPUk-4V4qQ" name="Timer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_HBhSsKuwEeiF8vQsMi0qMg" name="observation" visibility="protected" type="_G3d-1KuwEeiF8vQsMi0qMg" aggregation="composite" isBehavior="true" isService="false">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_HBh5wauwEeiF8vQsMi0qMg" value="1"/>
          <upperValue xmi:type="uml:LiteralInteger" xmi:id="_HBjH4KuwEeiF8vQsMi0qMg" value="1"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_BKT8EAlKEea_md0mpENoqg" name="ClientStateMachine">
          <region xmi:type="uml:Region" xmi:id="_Bk0GwAlKEea_md0mpENoqg" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_UScqkAlKEea_md0mpENoqg" name="inittrans" source="_Oll1cAlKEea_md0mpENoqg" target="_Q5-S4AlKEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ptLt0AlKEea_md0mpENoqg" name="InitLog">
                <language>C++</language>
                <body>      std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: Intialization\n&quot;;
     char  fileName[30];
     char  clientIndex[5];
     //itoa(clientIndex,this->getIndex(),10);

	sprintf(clientIndex, &quot;%d&quot;, this->getIndex());
     strcpy(fileName,this->getName());
     strcat(fileName, clientIndex);
     logfile.open(fileName);
     logfile&lt;&lt;&quot;capsuleName&quot;&lt;&lt;&quot;,messageType,&quot;&lt;&lt;&quot;messageID&quot;&lt;&lt;&quot;,&quot;&lt;&lt;&quot;second&quot;&lt;&lt;&quot;,&quot;&lt;&lt;&quot;nano&quot;&lt;&lt;&quot;\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::inittrans&quot;,(char *)&quot;init&quot;,(char *)&quot;StandBY&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_LR5_sAlhEea_md0mpENoqg" name="StarupTransition" source="_Q5-S4AlKEea_md0mpENoqg" target="_IjppsAlhEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_h7nXgAlhEea_md0mpENoqg" name="StartUPClient">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot; Client is startingUP \n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::StarupTransition&quot;,(char *)&quot;StandBY&quot;,(char *)&quot;Ready&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_TP2tsAlhEea_md0mpENoqg" name="startUp" event="_MloQ4AguEea_md0mpENoqg" port="_g3nG4AgvEea_md0mpENoqg"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_HD7tg6uwEeiF8vQsMi0qMg" event="_HD7tgquwEeiF8vQsMi0qMg" port="_HBhSsKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_7y_ToAmtEea_md0mpENoqg" name="reqFlowInit" source="_IjppsAlhEea_md0mpENoqg" target="_aVMuMAmtEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HQ72cauqEeii-Z6YoPPP7w" name="reqFlowInit__70">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::reqFlowInit&quot;,(char *)&quot;Ready&quot;,(char *)&quot;getMasterName&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_JtvGgAnKEeaGqPUk-4V4qQ" name="RequestTimer" port="_iLeRcAmuEea_md0mpENoqg">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_HD3cEKuwEeiF8vQsMi0qMg" event="_HD21AauwEeiF8vQsMi0qMg" port="_HBhSsKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_9CvEQAmtEea_md0mpENoqg" name="getMasterName__checkConfig__76" source="_aVMuMAmtEea_md0mpENoqg" target="_qr_J4AnCEeaGqPUk-4V4qQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HRKf8KuqEeii-Z6YoPPP7w" name="getMasterName__checkConfig__76__77">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::getMasterName__checkConfig__76&quot;,(char *)&quot;getMasterName&quot;,(char *)&quot;checkConfig&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_fW6vEAnCEeaGqPUk-4V4qQ" name="ConfigReply" event="_Iv3CQAl4Eea_md0mpENoqg" port="_g3nG4AgvEea_md0mpENoqg"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_HDJDUKuwEeiF8vQsMi0qMg" event="_HDIcQquwEeiF8vQsMi0qMg" port="_HBhSsKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_BanqgAmuEea_md0mpENoqg" name="ServiceResult" source="_fO-gkAmtEea_md0mpENoqg" target="_uScfwAmtEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_CC7jEAovEeaGqPUk-4V4qQ" name="getResponse">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: got reponse from server, go to process response state\n&quot;;
    int j=0;
    for (int i=0;i&lt;=100000;i++)
	j=j+1;
    std::cout&lt;&lt;j;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::ServiceResult&quot;,(char *)&quot;WaitingForReply&quot;,(char *)&quot;ProcessResponse&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_DEh6sAnGEeaGqPUk-4V4qQ" name="Result" event="_P4-6EAnFEeaGqPUk-4V4qQ" port="_fL3OQAnFEeaGqPUk-4V4qQ _lRZpIAnFEeaGqPUk-4V4qQ"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_HDZiBKuwEeiF8vQsMi0qMg" event="_HDZiA6uwEeiF8vQsMi0qMg" port="_HBhSsKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_Cf20QAmuEea_md0mpENoqg" name="ReqFlowDone" source="_uScfwAmtEea_md0mpENoqg" target="_IjppsAlhEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_PDYPsAoxEeaGqPUk-4V4qQ" name="AllIsDone">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: The service Request has been done sucessfully\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::ReqFlowDone&quot;,(char *)&quot;ProcessResponse&quot;,(char *)&quot;Ready&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_rVlzAAovEeaGqPUk-4V4qQ" port="_8sGy4AovEeaGqPUk-4V4qQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_HDxVcquwEeiF8vQsMi0qMg" event="_HDxVcauwEeiF8vQsMi0qMg" port="_HBhSsKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_xsxFAAnCEeaGqPUk-4V4qQ" name="NoMaster" source="_qr_J4AnCEeaGqPUk-4V4qQ" target="_KwFHIAo0EeaGqPUk-4V4qQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HRTp4KuqEeii-Z6YoPPP7w" name="NoMaster__80">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::NoMaster&quot;,(char *)&quot;checkConfig&quot;,(char *)&quot;Retry&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_6NrWIAnCEeaGqPUk-4V4qQ" name="reqService" guard="_BkmgYAnDEeaGqPUk-4V4qQ" source="_qr_J4AnCEeaGqPUk-4V4qQ" target="_fO-gkAmtEea_md0mpENoqg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_BkmgYAnDEeaGqPUk-4V4qQ" name="MasterIsAvailable">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_Ro31QAnDEeaGqPUk-4V4qQ" name="checkMaster">
                  <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
                  <language>C++</language>
                  <body>    hostConfig=config;
    if (hostConfig.MasterList[0] || hostConfig.MasterList[1])
    return true;
    else 
    return false;
</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_xvuAcAnEEeaGqPUk-4V4qQ" name="requestserive">
                <language>C++</language>
                <body>    
    messageID=messageID+1;
    ts.getclock(ts);
    if (logfile.is_open())
	logfile&lt;&lt;this->getName()&lt;&lt;&quot;,SendingMessage,&quot;&lt;&lt;messageID&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_sec&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;
    if (hostConfig.MasterList[0] &amp;&amp; hostConfig.MasterList[1])
    {
    int r=rand()%2;
    if (r==0)
    {
    Server1Comm.Request(0).send();
    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: sending Request to Server1\n&quot;;
    }
    else{
    Server2Comm.Request(0).send();
    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: sending Request to Server2\n&quot;;
    }
    }
    else if (hostConfig.MasterList[0]){
    Server1Comm.Request(0).send();
    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: sending Request to Server1\n&quot;;
    }
    else
    {
    Server2Comm.Request(0).send();
    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: sending Request to Server2\n&quot;;
    }


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::reqService&quot;,(char *)&quot;checkConfig&quot;,(char *)&quot;WaitingForReply&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_QnYuMAozEeaGqPUk-4V4qQ" name="NoResponseFromServer" source="_fO-gkAmtEea_md0mpENoqg" target="_IjppsAlhEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WkrVwApkEeaGqPUk-4V4qQ" name="ServiceFailure">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: Service Failur.....\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::NoResponseFromServer&quot;,(char *)&quot;WaitingForReply&quot;,(char *)&quot;Ready&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_ZV1SwAo4EeaGqPUk-4V4qQ" port="_tP9SkAmuEea_md0mpENoqg">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_HDtEAKuwEeiF8vQsMi0qMg" event="_HDsc8auwEeiF8vQsMi0qMg" port="_HBhSsKuwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_KpN_QAo2EeaGqPUk-4V4qQ" name="Retry" source="_KwFHIAo0EeaGqPUk-4V4qQ" target="_aVMuMAmtEea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HRFndKuqEeii-Z6YoPPP7w" name="Retry__74">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::Retry&quot;,(char *)&quot;Retry&quot;,(char *)&quot;getMasterName&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_2jDQUAo3EeaGqPUk-4V4qQ" name="Retry" port="_8sGy4AovEeaGqPUk-4V4qQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
              <trigger xmi:type="uml:Trigger" xmi:id="_HD_-8KuwEeiF8vQsMi0qMg" event="_HDxVcauwEeiF8vQsMi0qMg" port="_HBhSsKuwEeiF8vQsMi0qMg"/>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_Oll1cAlKEea_md0mpENoqg" name="init"/>
            <subvertex xmi:type="uml:State" xmi:id="_Q5-S4AlKEea_md0mpENoqg" name="StandBY">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_HQ6BQKuqEeii-Z6YoPPP7w" name="StandBY__64">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::StandBY&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HQ6BQauqEeii-Z6YoPPP7w" name="StandBY__65">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::StandBY&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_IjppsAlhEea_md0mpENoqg" name="Ready">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_fmLpMAm5Eea_md0mpENoqg" name="ReadyEntry">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: is in Ready State\n&quot;;
    //int r=rand()%11;
    int r=1;
    RequestTimer.informIn(UMLRTTimespec(0,1000),4);
    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: will try to request service after &quot;&lt;&lt; r&lt;&lt;&quot; second \n&quot;;


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::Ready&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HQ72cKuqEeii-Z6YoPPP7w" name="Ready__68">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::Ready&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_aVMuMAmtEea_md0mpENoqg" name="getMasterName">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_nvRWkAnBEea_md0mpENoqg" name="GetMasterNameEntry">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;:  Request Master Information from ENV\n&quot;;
    ConfigComm.QueryConfig().send();


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::getMasterName&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HQ6oUauqEeii-Z6YoPPP7w" name="getMasterName__67">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::getMasterName&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_fO-gkAmtEea_md0mpENoqg" name="WaitingForReply">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_SJEfMAo6EeaGqPUk-4V4qQ" name="WaitForReply">
                <language>C++</language>
                <body>    
    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: Waiting for Response, The timeout is 60 Second\n&quot;;
    TimerId=ResponseTimer.informIn(UMLRTTimespec(60,0),4);
    ts.getclock(ts);
    if (logfile.is_open())
	logfile&lt;&lt;this->getName()&lt;&lt;&quot;,MessageSent,&quot;&lt;&lt;messageID&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_sec&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::WaitingForReply&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_r05c0Ao9EeaGqPUk-4V4qQ" name="CancellTimer">
                <language>C++</language>
                <body>ResponseTimer.cancelTimer(TimerId);
messageID=messageID+1; 
ts.getclock(ts);
    if (logfile.is_open())
	logfile&lt;&lt;this->getName()&lt;&lt;&quot;,ProcessingMessage,&quot;&lt;&lt;messageID&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_sec&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;   



Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::WaitingForReply&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_uScfwAmtEea_md0mpENoqg" name="ProcessResponse">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_u-x1UAoxEeaGqPUk-4V4qQ" name="ProcessMessage">
                <language>C++</language>
                <body>    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot; : Processing Response .....\n&quot;;
    //int r=rand()%10;
    
    Timer.informIn(UMLRTTimespec(0,500),4);
    //messageID=messageID+1; 
    ts.getclock(ts);
    if (logfile.is_open())
	logfile&lt;&lt;this->getName()&lt;&lt;&quot;,MessageProcessed,&quot;&lt;&lt;messageID&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_sec&lt;&lt;&quot;,&quot;&lt;&lt;ts.tv_nsec&lt;&lt;&quot;\n&quot;;


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::ProcessResponse&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HQ5aMKuqEeii-Z6YoPPP7w" name="ProcessResponse__63">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::ProcessResponse&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_qr_J4AnCEeaGqPUk-4V4qQ" name="checkConfig" kind="choice"/>
            <subvertex xmi:type="uml:State" xmi:id="_KwFHIAo0EeaGqPUk-4V4qQ" name="Retry">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_1CJTsAo2EeaGqPUk-4V4qQ" name="RetryConfig">
                <language>C++</language>
                <body>    int r=rand()%5;
    std::cout&lt;&lt;this->getName()&lt;&lt;this->getIndex()&lt;&lt;&quot;: The master is not available, retry in &quot;&lt;&lt;r&lt;&lt; &quot; second\n&quot;;
    Timer.informIn(UMLRTTimespec(r,0),4);


Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::Retry&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_HQ6oUKuqEeii-Z6YoPPP7w" name="Retry__66">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Hosts::Client::ClientStateMachine::Region1::Retry&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_HC39kKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" specification="_HBkWAKuwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_HBkWAKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_HC39kKuwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HBlkIKuwEeiF8vQsMi0qMg" name="source">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HBxxYKuwEeiF8vQsMi0qMg" name="kind">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HB8JcKuwEeiF8vQsMi0qMg" name="capsuleInstance">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCF6cKuwEeiF8vQsMi0qMg" name="capsuleIndex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCHvoKuwEeiF8vQsMi0qMg" name="signalName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCYOUKuwEeiF8vQsMi0qMg" name="capsuleName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCimYKuwEeiF8vQsMi0qMg" name="sourceName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCjNcKuwEeiF8vQsMi0qMg" name="reserve1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCjNcauwEeiF8vQsMi0qMg" name="reserve2">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCj0gKuwEeiF8vQsMi0qMg" name="reserve3">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HCtlgKuwEeiF8vQsMi0qMg" name="reserve4">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Association" xmi:id="_yqOfEAxwEeaB2MeL96fedA" memberEnd="_yqPtMgxwEeaB2MeL96fedA _yqQUQAxwEeaB2MeL96fedA">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_yqPtMAxwEeaB2MeL96fedA" source="org.eclipse.papyrus">
          <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_yqPtMQxwEeaB2MeL96fedA" key="nature" value="UML_Nature"/>
        </eAnnotations>
        <ownedEnd xmi:type="uml:Property" xmi:id="_yqQUQAxwEeaB2MeL96fedA" name="host" type="_4_oYIAghEea_md0mpENoqg" association="_yqOfEAxwEeaB2MeL96fedA"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Association" xmi:id="_z8f_QAxwEeaB2MeL96fedA" memberEnd="_z8hNYQxwEeaB2MeL96fedA _z8hNYgxwEeaB2MeL96fedA">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_z8gmUAxwEeaB2MeL96fedA" source="org.eclipse.papyrus">
          <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_z8hNYAxwEeaB2MeL96fedA" key="nature" value="UML_Nature"/>
        </eAnnotations>
        <ownedEnd xmi:type="uml:Property" xmi:id="_z8hNYgxwEeaB2MeL96fedA" name="host" type="_4_oYIAghEea_md0mpENoqg" association="_z8f_QAxwEeaB2MeL96fedA"/>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_OiTE0AghEea_md0mpENoqg" name="Utility">
      <packagedElement xmi:type="uml:Class" xmi:id="_JesyoAgiEea_md0mpENoqg" name="HostInfo" visibility="public">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_l4sHAAgiEea_md0mpENoqg" name="hostType" type="_TE8UIAgiEea_md0mpENoqg"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_6EOE0AglEea_md0mpENoqg" name="status" type="_gf1EkAglEea_md0mpENoqg"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Enumeration" xmi:id="_TE8UIAgiEea_md0mpENoqg" name="HostType">
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_Y-NNkAgiEea_md0mpENoqg" name="CLI"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_aJOPMAgiEea_md0mpENoqg" name="SRV"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Enumeration" xmi:id="_gf1EkAglEea_md0mpENoqg" name="HostStatus" visibility="public">
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_ygyIkAglEea_md0mpENoqg" name="Active"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_0Co84AglEea_md0mpENoqg" name="Deactive"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Enumeration" xmi:id="_-VDn4AglEea_md0mpENoqg" name="ServerRole">
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_GJYf0AgmEea_md0mpENoqg" name="Master"/>
        <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_HZTPkAgmEea_md0mpENoqg" name="Slave"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_T635wAgmEea_md0mpENoqg" name="ServerInfo">
        <generalization xmi:type="uml:Generalization" xmi:id="_jCuQYAgrEea_md0mpENoqg" general="_JesyoAgiEea_md0mpENoqg"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_Y5vngAgmEea_md0mpENoqg" name="role" type="_-VDn4AglEea_md0mpENoqg"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_v04e0AgsEea_md0mpENoqg" name="ConfigProtocol">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_v000cAgsEea_md0mpENoqg" name="ConfigProtocol">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_v0_zkAgsEea_md0mpENoqg" client="_v000cAgsEea_md0mpENoqg" supplier="_v09XUAgsEea_md0mpENoqg" contract="_v09XUAgsEea_md0mpENoqg">
            <name xsi:nil="true"/>
          </interfaceRealization>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_v1SHcAgsEea_md0mpENoqg" client="_v000cAgsEea_md0mpENoqg" supplier="_v1PrMAgsEea_md0mpENoqg" contract="_v1PrMAgsEea_md0mpENoqg">
            <name xsi:nil="true"/>
          </interfaceRealization>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_v09XUAgsEea_md0mpENoqg" name="ConfigProtocol">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_Mnix4AgtEea_md0mpENoqg" name="ReplyReplicationMode">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_Mnix4QgtEea_md0mpENoqg" name="RunningMode">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_GvEtMAguEea_md0mpENoqg" name="ReplyServerRole">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_GvEtMQguEea_md0mpENoqg" name="ServerRole">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_MlnCwAguEea_md0mpENoqg" name="StartUp">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_oGfrwAlpEea_md0mpENoqg" name="config" type="_Y1UDYAg6Eea_md0mpENoqg"/>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_OMA_4AguEea_md0mpENoqg" name="Shutdown"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_QoJEEAguEea_md0mpENoqg" name="BIT"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_mLtTMAguEea_md0mpENoqg" name="ReplyMasterId">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_s-1M0AguEea_md0mpENoqg" name="MasterId">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_Iv10IAl4Eea_md0mpENoqg" name="ReplyConfig">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_Iv10IQl4Eea_md0mpENoqg" name="config" type="_Y1UDYAg6Eea_md0mpENoqg"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_v1I9gAgsEea_md0mpENoqg" name="ConfigProtocol~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_AW3DYAgtEea_md0mpENoqg" name="QueryReplicationMode"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_yDGNYAgtEea_md0mpENoqg" name="QueryServerRole">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_yDGNYQgtEea_md0mpENoqg" name="ServerName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_hZgIcAguEea_md0mpENoqg" name="QueryMasterId"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_BB20wAl4Eea_md0mpENoqg" name="QueryConfig"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_xu1hMAl4Eea_md0mpENoqg" name="IAMMaster">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_xu1hMQl4Eea_md0mpENoqg" name="MasterName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_v1MA0AgsEea_md0mpENoqg" client="_v000cAgsEea_md0mpENoqg" supplier="_v1I9gAgsEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_v1N2AAgsEea_md0mpENoqg" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_v1PrMAgsEea_md0mpENoqg" name="ConfigProtocolIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_v1SugAgsEea_md0mpENoqg" client="_v000cAgsEea_md0mpENoqg" supplier="_v1PrMAgsEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_AW3qcAgtEea_md0mpENoqg" operation="_AW3DYAgtEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_MnkAAAgtEea_md0mpENoqg" operation="_Mnix4AgtEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_yDG0cAgtEea_md0mpENoqg" operation="_yDGNYAgtEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_GvF7UAguEea_md0mpENoqg" operation="_GvEtMAguEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_MloQ4AguEea_md0mpENoqg" operation="_MlnCwAguEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_OMBm8AguEea_md0mpENoqg" operation="_OMA_4AguEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_QoLgUAguEea_md0mpENoqg" operation="_QoJEEAguEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_hZh9oAguEea_md0mpENoqg" operation="_hZgIcAguEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_mLvIYAguEea_md0mpENoqg" operation="_mLtTMAguEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_BB3b0Al4Eea_md0mpENoqg" operation="_BB20wAl4Eea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_Iv3CQAl4Eea_md0mpENoqg" operation="_Iv10IAl4Eea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_xu1hMgl4Eea_md0mpENoqg" operation="_xu1hMAl4Eea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_RLyKYAgzEea_md0mpENoqg" name="EchoCapsule" classifierBehavior="_WlNQsAg0Eea_md0mpENoqg" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_PdYSYAg0Eea_md0mpENoqg" name="Echo" visibility="public" type="_nk_BAAgzEea_md0mpENoqg" isOrdered="true" aggregation="composite" isBehavior="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_WNSukAm2Eea_md0mpENoqg" value="8"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_WOSNEAm2Eea_md0mpENoqg" value="8"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_G_2ewKuwEeiF8vQsMi0qMg" name="observation" visibility="protected" type="_G3d-1KuwEeiF8vQsMi0qMg" aggregation="composite" isBehavior="true" isService="false">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_G_3s4KuwEeiF8vQsMi0qMg" value="1"/>
          <upperValue xmi:type="uml:LiteralInteger" xmi:id="_G_3s4auwEeiF8vQsMi0qMg" value="1"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_WlNQsAg0Eea_md0mpENoqg" name="StateMachine1">
          <region xmi:type="uml:Region" xmi:id="_abLcsAg0Eea_md0mpENoqg" name="Region1">
            <transition xmi:type="uml:Transition" xmi:id="_ftWg8Ag0Eea_md0mpENoqg" name="init__WaitForEcho__5" source="_bHyrEAg0Eea_md0mpENoqg" target="_cfbzcAg0Eea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Izo0QAiiEea_md0mpENoqg" name="init">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;EchoCapsule: Intializing\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),(char *)&quot;&quot;,this->getTypeName(),(char *)&quot;Replication::Utility::EchoCapsule::StateMachine1::Region1::init__WaitForEcho__5&quot;,(char *)&quot;init&quot;,(char *)&quot;WaitForEcho&quot;,(char *)&quot;null&quot;,(char *)&quot;null&quot;);
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_kUUFAAg0Eea_md0mpENoqg" name="DoEcho" source="_cfbzcAg0Eea_md0mpENoqg" target="_cfbzcAg0Eea_md0mpENoqg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_L4RXcAg1Eea_md0mpENoqg" name="DoEcho">
                <language>C++</language>
                <body>    std::cout&lt;&lt;&quot;EchoCapsule: The Echo message was recieved\n&quot;;
    int tempid=msg->sapIndex0_;
    Echo.Echo().sendAt(tempid);
    std::cout&lt;&lt;&quot;EchoCapsule: The Echo message was replied\n&quot;;


Observation__sendEvent(Event::Transition,Event::TransitionEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Utility::EchoCapsule::StateMachine1::Region1::DoEcho&quot;,(char *)&quot;WaitForEcho&quot;,(char *)&quot;WaitForEcho&quot;,msg->signal.getSrcPort()->containerClass->name,msg->signal.getSrcPort()->getName());
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_2CMcAAg0Eea_md0mpENoqg" name="Echo" event="_7w0oMAgzEea_md0mpENoqg" port="_PdYSYAg0Eea_md0mpENoqg"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_HBgEkquwEeiF8vQsMi0qMg" event="_HBgEkauwEeiF8vQsMi0qMg" port="_G_2ewKuwEeiF8vQsMi0qMg"/>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_bHyrEAg0Eea_md0mpENoqg" name="init"/>
            <subvertex xmi:type="uml:State" xmi:id="_cfbzcAg0Eea_md0mpENoqg" name="WaitForEcho">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_GuvIUKuqEeii-Z6YoPPP7w" name="WaitForEcho__2">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateEntryEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Utility::EchoCapsule::StateMachine1::Region1::WaitForEcho&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </entry>
              <exit xmi:type="uml:OpaqueBehavior" xmi:id="_GuvIUauqEeii-Z6YoPPP7w" name="WaitForEcho__3">
                <language>C++</language>
                <body>

Observation__sendEvent(Event::State,Event::StateExitEnd,this->getName(),this->getIndex(),msg->getSignalName(),this->getTypeName(),(char *)&quot;Replication::Utility::EchoCapsule::StateMachine1::Region1::WaitForEcho&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;,(char *)&quot;&quot;);
</body>
              </exit>
            </subvertex>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_HBSpMKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" specification="_G_6JIKuwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>EventObj evtObj;
evtObj.event.generateEventId();
evtObj.event.setTimestamp();
evtObj.event.setEventKind(kind);
evtObj.event.setEventSource(source);
evtObj.event.setCapsuleInstance(capsuleInstance);
evtObj.event.setSourceName(sourceName);
if (source==Event::EventSource::Transition){
evtObj.event.setParam(&quot;Source&quot;,reserve1);
evtObj.event.setParam(&quot;Target&quot;,reserve2);
evtObj.event.setParam(&quot;Signal&quot;,signalName);
evtObj.event.setParam(&quot;SenderCapsule&quot;,reserve3);
evtObj.event.setParam(&quot;Port&quot;,reserve4);
}
observation.event(evtObj).send();
</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_G_6JIKuwEeiF8vQsMi0qMg" name="Observation__sendEvent" visibility="private" concurrency="guarded" method="_HBSpMKuwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G_7-UKuwEeiF8vQsMi0qMg" name="source">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HAFvUKuwEeiF8vQsMi0qMg" name="kind">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HAPgUKuwEeiF8vQsMi0qMg" name="capsuleInstance">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HAc7sKuwEeiF8vQsMi0qMg" name="capsuleIndex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HAdiwKuwEeiF8vQsMi0qMg" name="signalName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HAq-IKuwEeiF8vQsMi0qMg" name="capsuleName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HA3LYKuwEeiF8vQsMi0qMg" name="sourceName">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HA3ycKuwEeiF8vQsMi0qMg" name="reserve1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HA4ZgKuwEeiF8vQsMi0qMg" name="reserve2">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HA5AkKuwEeiF8vQsMi0qMg" name="reserve3">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HBGb8KuwEeiF8vQsMi0qMg" name="reserve4">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_nlBdQAgzEea_md0mpENoqg" name="Echo">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_nk_BAAgzEea_md0mpENoqg" name="Echo">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_nlGVwAgzEea_md0mpENoqg" client="_nk_BAAgzEea_md0mpENoqg" supplier="_nlD5gAgzEea_md0mpENoqg" contract="_nlD5gAgzEea_md0mpENoqg">
            <name xsi:nil="true"/>
          </interfaceRealization>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_nlZQsAgzEea_md0mpENoqg" client="_nk_BAAgzEea_md0mpENoqg" supplier="_nlTKEAgzEea_md0mpENoqg" contract="_nlTKEAgzEea_md0mpENoqg">
            <name xsi:nil="true"/>
          </interfaceRealization>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_nlD5gAgzEea_md0mpENoqg" name="Echo"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_nlL1UAgzEea_md0mpENoqg" name="Echo~"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_nlQGwAgzEea_md0mpENoqg" client="_nk_BAAgzEea_md0mpENoqg" supplier="_nlL1UAgzEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_nlR78AgzEea_md0mpENoqg" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_nlTKEAgzEea_md0mpENoqg" name="EchoIO">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_7w0BIAgzEea_md0mpENoqg" name="Echo"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_nlae0AgzEea_md0mpENoqg" client="_nk_BAAgzEea_md0mpENoqg" supplier="_nlTKEAgzEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_7w0oMAgzEea_md0mpENoqg" operation="_7w0BIAgzEea_md0mpENoqg">
          <name xsi:nil="true"/>
        </packagedElement>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_Y1UDYAg6Eea_md0mpENoqg" name="SystemConfig">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_lX6oUAg6Eea_md0mpENoqg" name="ConfigOK">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_lX6oUQg6Eea_md0mpENoqg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_rA4b8Ag6Eea_md0mpENoqg" name="RunningMode">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_xR7jQAg6Eea_md0mpENoqg" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_4Gg1cAg6Eea_md0mpENoqg" name="MasterId">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_7FhkQAg6Eea_md0mpENoqg" name="MasterName">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_6tXsMAmpEea_md0mpENoqg" name="MasterList">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_Hzi4QAmqEea_md0mpENoqg" value="2"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_HzxhwAmqEea_md0mpENoqg" value="2"/>
          <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_JwlzwAmqEea_md0mpENoqg"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_cYIKwAimEea_md0mpENoqg" name="loadConfig" specification="_QF0roAimEea_md0mpENoqg">
          <language>C++</language>
          <body>{
    /* UMLRTGEN-USERREGION-BEGIN platform:/resource/Replication/Replication.uml Replication::Configuration operation loadConfig */
    std::cout&lt;&lt;&quot;Config Class: load configuration from file\n&quot;;
    char result[PATH_MAX];
    readlink( &quot;/proc/self/exe&quot;, result, PATH_MAX );
    string temps=string(result);
    size_t tempP=temps.rfind('/');
    if (tempP>0)
    {
    temps=temps.substr(0,tempP);
    }
    else
    temps=&quot;&quot;;
    string MasterConfigFileName=&quot;./Master.config&quot;;
    string RunningModeConfigFileName=&quot;./RunningMode.config&quot;;
    string MasterConfigPath=temps+MasterConfigFileName;
    string RunningModeConfigPath=temps+RunningModeConfigFileName;
    cout &lt;&lt; RunningModeConfigPath &lt;&lt; endl;
    //ifstream RunningModeConfigFile(RunningModeConfigPath.c_str());
    ifstream RunningModeConfigFile(&quot;./RunningMode.config&quot;);
    string line;
    if (RunningModeConfigFile.is_open())
    {
    (getline(RunningModeConfigFile,line));
    {
    if (atoi(line.c_str())==0)
    {
    this->RunningMode=0;
    this->ConfigOK=true;
    RunningModeConfigFile.close();
    cout&lt;&lt;&quot;Configuration Loaded successfully, the running mode is active\n&quot;;
    //            			return true;
    }
    else if (atoi(line.c_str())==1)
    {
    this->RunningMode=1;
    //ifstream MasterConfigFile(MasterConfigPath.c_str());
    ifstream MasterConfigFile(&quot;Master.config&quot;);

    if (MasterConfigFile.is_open() &amp;&amp; (getline(MasterConfigFile,line)))
    if (line==&quot;server1&quot; || line==&quot;server2&quot;)
    {
    this->MasterName= new char[line.size()+1];
    strcpy(this->MasterName,line.c_str());
    cout &lt;&lt;&quot;Master Name is:&quot;&lt;&lt; this->MasterName&lt;&lt;endl;
    this->ConfigOK=true;
    cout &lt;&lt; &quot;configuration Loaded successfully, the running mode is passive|&quot;
    &lt;&lt;&quot; Master name is : &quot;&lt;&lt;this->MasterName&lt;&lt;endl;
    RunningModeConfigFile.close();
    MasterConfigFile.close();
    //           					return true;
    }
    else
    {
    cout&lt;&lt;&quot;Master Name is wrong, please fix it\n&quot;;
    this->ConfigOK=false;
    //           					return false;
    }
    else
    {
    cout&lt;&lt;&quot;Master config file(Master.config) cann't be loaded, please fix it\n&quot;;
    this->ConfigOK=false;
    //         				return false;
    }
    }
    else
    {
    cout&lt;&lt; &quot;The running mode value is incorrect, please fix that\n&quot;;
    this->ConfigOK=false;
    //       			return false;
    }
    }
    }
    else
    {
    cout&lt;&lt;&quot;The Running Mode config(RunningMode.config) file can't be loaded, please fix it\n&quot;;
    this->ConfigOK=false;
    //     	return false;
    }/* UMLRTGEN-USERREGION-END */
}
</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_QF0roAimEea_md0mpENoqg" name="loadConfig" method="_cYIKwAimEea_md0mpENoqg"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_4_QwUAnEEeaGqPUk-4V4qQ" name="Services">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_4--ccAnEEeaGqPUk-4V4qQ" name="Services">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_5AwlIAnEEeaGqPUk-4V4qQ" client="_4--ccAnEEeaGqPUk-4V4qQ" supplier="_5AqegAnEEeaGqPUk-4V4qQ" contract="_5AqegAnEEeaGqPUk-4V4qQ">
            <name xsi:nil="true"/>
          </interfaceRealization>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_5A8LUAnEEeaGqPUk-4V4qQ" client="_4--ccAnEEeaGqPUk-4V4qQ" supplier="_5A5IAAnEEeaGqPUk-4V4qQ" contract="_5A5IAAnEEeaGqPUk-4V4qQ">
            <name xsi:nil="true"/>
          </interfaceRealization>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_5AqegAnEEeaGqPUk-4V4qQ" name="Services">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_P49E4AnFEeaGqPUk-4V4qQ" name="Reply">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_P49E4QnFEeaGqPUk-4V4qQ" name="Result">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
              <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_P49E4gnFEeaGqPUk-4V4qQ" value="0"/>
            </ownedParameter>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_5AzBYAnEEeaGqPUk-4V4qQ" name="Services~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G3ENoAnFEeaGqPUk-4V4qQ" name="Request">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3ENoQnFEeaGqPUk-4V4qQ" name="ServiceID">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
              <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_G3ENognFEeaGqPUk-4V4qQ" value="0"/>
            </ownedParameter>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_5A3S0AnEEeaGqPUk-4V4qQ" client="_4--ccAnEEeaGqPUk-4V4qQ" supplier="_5AzBYAnEEeaGqPUk-4V4qQ">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_5A354AnEEeaGqPUk-4V4qQ" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_5A5IAAnEEeaGqPUk-4V4qQ" name="ServicesIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_5A_1sAnEEeaGqPUk-4V4qQ" client="_4--ccAnEEeaGqPUk-4V4qQ" supplier="_5A5IAAnEEeaGqPUk-4V4qQ">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G3K7UAnFEeaGqPUk-4V4qQ" operation="_G3ENoAnFEeaGqPUk-4V4qQ">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_P4-6EAnFEeaGqPUk-4V4qQ" operation="_P49E4AnFEeaGqPUk-4V4qQ">
          <name xsi:nil="true"/>
        </packagedElement>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_f2zWUApBEeaGqPUk-4V4qQ" name="FailOver">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_f2ud0ApBEeaGqPUk-4V4qQ" name="FailOver">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_f4EhoApBEeaGqPUk-4V4qQ" client="_f2ud0ApBEeaGqPUk-4V4qQ" supplier="_f39z8ApBEeaGqPUk-4V4qQ" contract="_f39z8ApBEeaGqPUk-4V4qQ">
            <name xsi:nil="true"/>
          </interfaceRealization>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_f4O5sApBEeaGqPUk-4V4qQ" client="_f2ud0ApBEeaGqPUk-4V4qQ" supplier="_f4L2YApBEeaGqPUk-4V4qQ" contract="_f4L2YApBEeaGqPUk-4V4qQ">
            <name xsi:nil="true"/>
          </interfaceRealization>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_f39z8ApBEeaGqPUk-4V4qQ" name="FailOver"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_f4FvwApBEeaGqPUk-4V4qQ" name="FailOver~"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_f4KoQApBEeaGqPUk-4V4qQ" client="_f2ud0ApBEeaGqPUk-4V4qQ" supplier="_f4FvwApBEeaGqPUk-4V4qQ">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_f4LPUApBEeaGqPUk-4V4qQ" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_f4L2YApBEeaGqPUk-4V4qQ" name="FailOverIO">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_xM6GgApBEeaGqPUk-4V4qQ" name="IAmAlive">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_xM6GgQpBEeaGqPUk-4V4qQ" name="ServerName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_f4Qu4ApBEeaGqPUk-4V4qQ" client="_f2ud0ApBEeaGqPUk-4V4qQ" supplier="_f4L2YApBEeaGqPUk-4V4qQ">
          <name xsi:nil="true"/>
        </packagedElement>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_xM6tkApBEeaGqPUk-4V4qQ" operation="_xM6GgApBEeaGqPUk-4V4qQ">
          <name xsi:nil="true"/>
        </packagedElement>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_gDfqsAghEea_md0mpENoqg" name="Simulator">
      <packagedElement xmi:type="uml:Dependency" xmi:id="_m1qiEAghEea_md0mpENoqg" client="_lYTBoAggEea_md0mpENoqg" supplier="_rPgFkAggEea_md0mpENoqg"/>
      <packagedElement xmi:type="uml:Dependency" xmi:id="_nyBcoAghEea_md0mpENoqg" client="_gDfqsAghEea_md0mpENoqg" supplier="_z1vioAggEea_md0mpENoqg"/>
      <packagedElement xmi:type="uml:Class" xmi:id="_d9MBUAgoEea_md0mpENoqg" name="Simulator" isActive="true">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_ljfrYAgoEea_md0mpENoqg" name="server1" visibility="protected" type="_xCGHkAgmEea_md0mpENoqg" isOrdered="true" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_ljjVwAgoEea_md0mpENoqg" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ljjVwQgoEea_md0mpENoqg" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_odv2AAgoEea_md0mpENoqg" name="client" visibility="protected" type="_zpdLYAgmEea_md0mpENoqg" isOrdered="true" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_odySQQgoEea_md0mpENoqg" value="5"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_ody5UAgoEea_md0mpENoqg" value="5"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_trcC4AgoEea_md0mpENoqg" name="ENV" visibility="protected" type="_sMZ5EAgoEea_md0mpENoqg" isOrdered="true" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_trfGMAgoEea_md0mpENoqg" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_trfGMQgoEea_md0mpENoqg" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_6qCFoAg7Eea_md0mpENoqg" name="server2" visibility="protected" type="_xCGHkAgmEea_md0mpENoqg" isOrdered="true" aggregation="composite">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_6qGXEAg7Eea_md0mpENoqg" value="1"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_6qGXEQg7Eea_md0mpENoqg" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_G4Yk0KuwEeiF8vQsMi0qMg" name="observer" type="_G3d-4KuwEeiF8vQsMi0qMg" aggregation="composite"/>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_O1v3cOM6EeaTpaLNj-zYpw" name="RTConnector6">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_O1xsoOM6EeaTpaLNj-zYpw" partWithPort="_odv2AAgoEea_md0mpENoqg" role="_fL3OQAnFEeaGqPUk-4V4qQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_O1xsoeM6EeaTpaLNj-zYpw" partWithPort="_ljfrYAgoEea_md0mpENoqg" role="_pQ6HcAnMEeaGqPUk-4V4qQ"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_P9Q5IOM6EeaTpaLNj-zYpw" name="RTConnector7">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_P9SHQOM6EeaTpaLNj-zYpw" partWithPort="_odv2AAgoEea_md0mpENoqg" role="_lRZpIAnFEeaGqPUk-4V4qQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_P9SHQeM6EeaTpaLNj-zYpw" partWithPort="_6qCFoAg7Eea_md0mpENoqg" role="_pQ6HcAnMEeaGqPUk-4V4qQ"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_zuXWQONAEeaTpaLNj-zYpw" name="RTConnector8">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_zuZygONAEeaTpaLNj-zYpw" partWithPort="_ljfrYAgoEea_md0mpENoqg" role="_HIvrsApCEeaGqPUk-4V4qQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_zuZygeNAEeaTpaLNj-zYpw" partWithPort="_6qCFoAg7Eea_md0mpENoqg" role="_rmnI0OM8EeaTpaLNj-zYpw"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_0bs9YONAEeaTpaLNj-zYpw" name="RTConnector9">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_0buLgONAEeaTpaLNj-zYpw" partWithPort="_6qCFoAg7Eea_md0mpENoqg" role="_HIvrsApCEeaGqPUk-4V4qQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_0buLgeNAEeaTpaLNj-zYpw" partWithPort="_ljfrYAgoEea_md0mpENoqg" role="_rmnI0OM8EeaTpaLNj-zYpw"/>
        </ownedConnector>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_G3d-0KuwEeiF8vQsMi0qMg" name="Observation">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_G3d-0auwEeiF8vQsMi0qMg" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_G3d-0quwEeiF8vQsMi0qMg" key="language" value="umlrt-cpp"/>
      </eAnnotations>
      <packagedElement xmi:type="uml:Package" xmi:id="_G3d-06uwEeiF8vQsMi0qMg" name="Observation">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_G3d-1KuwEeiF8vQsMi0qMg" name="Observation">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_G4Pa4KuwEeiF8vQsMi0qMg" client="_G3d-1KuwEeiF8vQsMi0qMg" supplier="_G3d-16uwEeiF8vQsMi0qMg" contract="_G3d-16uwEeiF8vQsMi0qMg"/>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_G4Pa4auwEeiF8vQsMi0qMg" client="_G3d-1KuwEeiF8vQsMi0qMg" supplier="_G3d-3auwEeiF8vQsMi0qMg" contract="_G3d-3auwEeiF8vQsMi0qMg"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_G3d-16uwEeiF8vQsMi0qMg" name="Observation">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G7s-kKuwEeiF8vQsMi0qMg" name="Server_Slave_IAmAlive">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G7s-kauwEeiF8vQsMi0qMg" name="ServerName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G77oEKuwEeiF8vQsMi0qMg" name="Server_ServerComm_Request">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G77oEauwEeiF8vQsMi0qMg" name="ServiceID">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
              <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_G77oEquwEeiF8vQsMi0qMg" value="0"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G8PKEKuwEeiF8vQsMi0qMg" name="Server_ConfigComm_StartUp">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G8PKEauwEeiF8vQsMi0qMg" name="config" type="_Y1UDYAg6Eea_md0mpENoqg"/>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G8XF4KuwEeiF8vQsMi0qMg" name="Server_ConfigComm_ReplyConfig">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G8XF4auwEeiF8vQsMi0qMg" name="config" type="_Y1UDYAg6Eea_md0mpENoqg"/>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G8nkkKuwEeiF8vQsMi0qMg" name="Server_KeepAliveTimer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G8-J4KuwEeiF8vQsMi0qMg" name="Server_Timer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G9RE0KuwEeiF8vQsMi0qMg" name="Server_MasterAnnounceTimer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G_OMoKuwEeiF8vQsMi0qMg" name="ENV_FailureTimer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G_U6UKuwEeiF8vQsMi0qMg" name="ENV_ConfigComm_QueryConfig"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G_bA8KuwEeiF8vQsMi0qMg" name="ENV_AnnouncmentServer1_IAmAlive">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G_bA8auwEeiF8vQsMi0qMg" name="ServerName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G_kx8KuwEeiF8vQsMi0qMg" name="ENV_AnnouncmentServer2_IAmAlive">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G_kx8auwEeiF8vQsMi0qMg" name="ServerName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G_ui8KuwEeiF8vQsMi0qMg" name="ENV_ConfigComm_IAMMaster">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G_ui8auwEeiF8vQsMi0qMg" name="MasterName">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G_0CgKuwEeiF8vQsMi0qMg" name="ENV_configTimer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_HBgEkKuwEeiF8vQsMi0qMg" name="EchoCapsule_Echo_Echo"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_HDIcQKuwEeiF8vQsMi0qMg" name="Client_ConfigComm_ReplyConfig">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_HDIcQauwEeiF8vQsMi0qMg" name="config" type="_Y1UDYAg6Eea_md0mpENoqg"/>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_HDZiAKuwEeiF8vQsMi0qMg" name="Client_Server1Comm_Reply">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_HDZiAauwEeiF8vQsMi0qMg" name="Result">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
              <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_HDZiAquwEeiF8vQsMi0qMg" value="0"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_HDsc8KuwEeiF8vQsMi0qMg" name="Client_ResponseTimer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_HDxVcKuwEeiF8vQsMi0qMg" name="Client_Timer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_HD21AKuwEeiF8vQsMi0qMg" name="Client_RequestTimer_timeout"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_HD7tgKuwEeiF8vQsMi0qMg" name="Client_ConfigComm_StartUp">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_HD7tgauwEeiF8vQsMi0qMg" name="config" type="_Y1UDYAg6Eea_md0mpENoqg"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_G3d-2KuwEeiF8vQsMi0qMg" name="Observation~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_G3d-2auwEeiF8vQsMi0qMg" name="event">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3d-2quwEeiF8vQsMi0qMg" name="data" type="_G3d_EKuwEeiF8vQsMi0qMg"/>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_G3d-26uwEeiF8vQsMi0qMg" client="_G3d-1KuwEeiF8vQsMi0qMg" supplier="_G3d-2KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_G3d-3KuwEeiF8vQsMi0qMg" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_G3d-3auwEeiF8vQsMi0qMg" name="ObservationIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_G3d-3quwEeiF8vQsMi0qMg" client="_G3d-1KuwEeiF8vQsMi0qMg" supplier="_G3d-3auwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G3d-36uwEeiF8vQsMi0qMg" operation="_G3d-2auwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G7s-kquwEeiF8vQsMi0qMg" name="Server_Slave_IAmAlive" operation="_G7s-kKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G77oE6uwEeiF8vQsMi0qMg" name="Server_ServerComm_Request" operation="_G77oEKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G8PKEquwEeiF8vQsMi0qMg" name="Server_ConfigComm_StartUp" operation="_G8PKEKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G8Xs8KuwEeiF8vQsMi0qMg" name="Server_ConfigComm_ReplyConfig" operation="_G8XF4KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G8nkkauwEeiF8vQsMi0qMg" name="Server_KeepAliveTimer_timeout" operation="_G8nkkKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G8-w8KuwEeiF8vQsMi0qMg" name="Server_Timer_timeout" operation="_G8-J4KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G9RE0auwEeiF8vQsMi0qMg" name="Server_MasterAnnounceTimer_timeout" operation="_G9RE0KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G_OMoauwEeiF8vQsMi0qMg" name="ENV_FailureTimer_timeout" operation="_G_OMoKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G_VhYKuwEeiF8vQsMi0qMg" name="ENV_ConfigComm_QueryConfig" operation="_G_U6UKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G_boAKuwEeiF8vQsMi0qMg" name="ENV_AnnouncmentServer1_IAmAlive" operation="_G_bA8KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G_kx8quwEeiF8vQsMi0qMg" name="ENV_AnnouncmentServer2_IAmAlive" operation="_G_kx8KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G_ui8quwEeiF8vQsMi0qMg" name="ENV_ConfigComm_IAMMaster" operation="_G_ui8KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_G_0CgauwEeiF8vQsMi0qMg" name="ENV_configTimer_timeout" operation="_G_0CgKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_HBgEkauwEeiF8vQsMi0qMg" name="EchoCapsule_Echo_Echo" operation="_HBgEkKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_HDIcQquwEeiF8vQsMi0qMg" name="Client_ConfigComm_ReplyConfig" operation="_HDIcQKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_HDZiA6uwEeiF8vQsMi0qMg" name="Client_Server1Comm_Reply" operation="_HDZiAKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_HDsc8auwEeiF8vQsMi0qMg" name="Client_ResponseTimer_timeout" operation="_HDsc8KuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_HDxVcauwEeiF8vQsMi0qMg" name="Client_Timer_timeout" operation="_HDxVcKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_HD21AauwEeiF8vQsMi0qMg" name="Client_RequestTimer_timeout" operation="_HD21AKuwEeiF8vQsMi0qMg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_HD7tgquwEeiF8vQsMi0qMg" name="Client_ConfigComm_StartUp" operation="_HD7tgKuwEeiF8vQsMi0qMg"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_G3d-4KuwEeiF8vQsMi0qMg" name="Observer" classifierBehavior="_G3d-6quwEeiF8vQsMi0qMg" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_G3d-4auwEeiF8vQsMi0qMg" name="observation" visibility="public" type="_G3d-1KuwEeiF8vQsMi0qMg" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true">
          <lowerValue xmi:type="uml:LiteralInteger" xmi:id="_G3d-4quwEeiF8vQsMi0qMg" value="20"/>
          <upperValue xmi:type="uml:LiteralUnlimitedNatural" xmi:id="_G3d-46uwEeiF8vQsMi0qMg" value="20"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_G3d-5KuwEeiF8vQsMi0qMg" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_G3d-5auwEeiF8vQsMi0qMg" name="commandTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_G3d-5quwEeiF8vQsMi0qMg" name="eventQueue" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_G3d-56uwEeiF8vQsMi0qMg" name="eventTimer" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_G3d-6KuwEeiF8vQsMi0qMg" name="isPeriodic">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          <defaultValue xmi:type="uml:LiteralBoolean" xmi:id="_G3d-6auwEeiF8vQsMi0qMg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_HEV9MKuwEeiF8vQsMi0qMg" name="systemconfig" type="_Y1UDYAg6Eea_md0mpENoqg"/>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_G3d-6quwEeiF8vQsMi0qMg" name="ObserverStateMachine" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_G3d-66uwEeiF8vQsMi0qMg" name="Region">
            <transition xmi:type="uml:Transition" xmi:id="_G3d-7KuwEeiF8vQsMi0qMg" name="configure" source="_G3d--quwEeiF8vQsMi0qMg" target="_G3d--6uwEeiF8vQsMi0qMg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_G3d-7auwEeiF8vQsMi0qMg">
                <language>C++</language>
                <body>int n = config.load();
log.show(&quot;Number of entries: %d\n&quot;, n);

// Socket
this->method = new Socket();
this->method->configure(config.getConfigList());
this->method->connect();

// Text 
this->serializer = new Text();
this->serializer->configure(config.getConfigList());

std::string mode = config.get(&quot;mode&quot;);
std::string periodicity = config.get(&quot;periodicity&quot;);

// If sending events is set as periodic
if (periodicity != &quot;&quot; &amp;&amp; mode == &quot;periodic&quot;) {
	this->isPeriodic = true;
	// Periodicity is set in microseconds
	// Multiplied by 1000 to get nanoseconds
	long nano = (long long)(atol(periodicity.c_str())*1000);
	long seconds = nano/1000000000;
	eventTimer.informEvery(UMLRTTimespec(seconds, (nano-1000000000*seconds)));
}

// Instantiating the command timer
commandTimer.informEvery(UMLRTTimespec(0,500000000));
</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_G3d-7quwEeiF8vQsMi0qMg" name="event received" source="_G3d--6uwEeiF8vQsMi0qMg" target="_G3d--6uwEeiF8vQsMi0qMg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_G3d-76uwEeiF8vQsMi0qMg">
                <language>C++</language>
                <body>std::string event = this->serializer->serialize(data.event) + &quot;\n&quot;;
if (this->isPeriodic) {
	eventQueue.push_back(event);
}
else {
	this->method->sendData(event);
}</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_G3d-8KuwEeiF8vQsMi0qMg" event="_G3d-36uwEeiF8vQsMi0qMg" port="_G3d-4auwEeiF8vQsMi0qMg"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_G3d-8auwEeiF8vQsMi0qMg" name="command received" source="_G3d--6uwEeiF8vQsMi0qMg" target="_G3d--6uwEeiF8vQsMi0qMg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_G3d-8quwEeiF8vQsMi0qMg">
                <language>C++</language>
                <body>std::string data = this->method->read();
    if (data != &quot;&quot;) {
    Event evt = this->serializer->parse(data);
    if (evt.getEventSource() == Event::EventSource::Command) {

      std::map&lt;std::string, size_t>::iterator iter;
      std::string sourceName = evt.getSourceName();

      switch(evt.getEventKind()) {
        case Event::EventKind::List:
          // List of capsule parts
          evt.setSourceName(&quot;Observer&quot;);
          for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
            evt.setParam(iter->first, capsuleTypes[iter->first]);
          }
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Show:
          // Show a specific capsule part
          this->method->sendData(this->serializer->serialize(listCapsuleMessage(evt)));
          this->method->sendData(&quot;\n&quot;);
        break;
        case Event::EventKind::Trigger:
          evt = this->triggerCapsuleMessage(evt);
          this->method->sendData(this->serializer->serialize(evt));
          this->method->sendData(&quot;\n&quot;);
        break;
        default:
        break;
      }
    }
}

/*std::string data = this->method->read();
    std::stringstream ss;
    if (data != &quot;&quot;) {

        std::istringstream iss(data);
        std::vector&lt;std::string> cmd;
        while (iss) {
            std::string subs;
            iss >> subs; 
            if (iss.str().empty()) {
                cmd.push_back(subs);
            }
        }

        if (cmd.size() == 0)
            return;

        if (cmd.size() > 1 &amp;&amp; cmd[0] == &quot;list&quot; &amp;&amp; cmd[1] == &quot;capsules&quot;) {
            ss  &lt;&lt; &quot;List of capsules:\n&quot;;
            std::map&lt;std::string, size_t>::iterator iter;
            for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; iter->first &lt;&lt; &quot; [&quot;&lt;&lt; capsuleTypes[iter->first]&lt;&lt; &quot;]\n&quot;;
            }
            this->method->sendData(ss.str());
        }
        else if (cmd.size() > 2 &amp;&amp; cmd[0] == &quot;show&quot; &amp;&amp; cmd[1] == &quot;capsule&quot;) {

            printf(&quot;capsule:%s|type:%s\n&quot;, cmd[1].c_str(), capsuleTypes[cmd[2]].c_str());
            if (capsuleTypes[cmd[2]] == &quot;&quot;) {
                printf(&quot;error: %s\n&quot;, capsuleTypes[cmd[2]].c_str());
                return;
            }
            std::string capsuleType = capsuleTypes[cmd[2]];
            ss  &lt;&lt; &quot;Capsule: &quot; &lt;&lt; cmd[2];
            ss  &lt;&lt; &quot; type: &quot; &lt;&lt; capsuleTypes[cmd[2]] &lt;&lt; &quot;\n&quot;;
            ss  &lt;&lt; &quot;List of triggers:\n&quot;;
            if (capsuleType == &quot;Gen&quot;) {
                ss &lt;&lt; &quot; - &quot; &lt;&lt; &quot;generate()\n&quot;;
                this->method->sendData(ss.str());
            }
        }

    }*/</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_G3d-86uwEeiF8vQsMi0qMg" port="_G3d-5auwEeiF8vQsMi0qMg">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_G3d-9KuwEeiF8vQsMi0qMg" name="register capsules" source="_G3d--6uwEeiF8vQsMi0qMg" target="_G3d--6uwEeiF8vQsMi0qMg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_G3d-9auwEeiF8vQsMi0qMg">
                <language>C++</language>
                <body>std::stringstream ss;
    ss &lt;&lt; msg->signal.getSrcPort()->slot->name &lt;&lt; &quot;:&quot; &lt;&lt; msg->signal.getSrcPort()->slot->capsuleIndex;
    printf(&quot;capsule name: %s at port %d\n&quot;, ss.str().c_str(), (int)msg->sapIndex0_);
    capsules[ss.str()] = msg->sapIndex0_;
    capsuleTypes[ss.str()] = msg->signal.getSrcPort()->slot->capsuleClass->name;</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_G3d-9quwEeiF8vQsMi0qMg" port="_G3d-4auwEeiF8vQsMi0qMg">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_PQtAwOzeEeSRtqCWFwOf8g"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_G3d-96uwEeiF8vQsMi0qMg" name="events periodically sent" source="_G3d--6uwEeiF8vQsMi0qMg" target="_G3d--6uwEeiF8vQsMi0qMg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_G3d--KuwEeiF8vQsMi0qMg" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>unsigned size = this->eventQueue.size();
for (unsigned int i = 0; i &lt; size; i++) {
	this->method->sendData(this->eventQueue.back());
	this->eventQueue.pop_back();
}</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_G3d--auwEeiF8vQsMi0qMg" port="_G3d-56uwEeiF8vQsMi0qMg">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_G3d--quwEeiF8vQsMi0qMg">
              <name xsi:nil="true"/>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_G3d--6uwEeiF8vQsMi0qMg" name="OBSERVING"/>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_G3d-_KuwEeiF8vQsMi0qMg" name="listCapsuleMessage" specification="_G3d-_6uwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>std::string sourceName = evt.getSourceName();
if (sourceName == &quot;EchoCapsule&quot;) {
	evt.setParam(&quot;0&quot;, &quot;Echo_Echo&quot;);
}
if (sourceName == &quot;Server&quot;) {
	evt.setParam(&quot;0&quot;, &quot;MasterAnnounceTimer_timeout&quot;);
	evt.setParam(&quot;1&quot;, &quot;ServerComm_Request&quot;);
	evt.setParam(&quot;2&quot;, &quot;ConfigComm_ReplyConfig&quot;);
	evt.setParam(&quot;3&quot;, &quot;Slave_IAmAlive&quot;);
	evt.setParam(&quot;4&quot;, &quot;Timer_timeout&quot;);
	evt.setParam(&quot;5&quot;, &quot;KeepAliveTimer_timeout&quot;);
	evt.setParam(&quot;6&quot;, &quot;ConfigComm_StartUp&quot;);
}
if (sourceName == &quot;ENV&quot;) {
	evt.setParam(&quot;0&quot;, &quot;ConfigComm_IAMMaster&quot;);
	evt.setParam(&quot;1&quot;, &quot;FailureTimer_timeout&quot;);
	evt.setParam(&quot;2&quot;, &quot;ConfigComm_QueryConfig&quot;);
	evt.setParam(&quot;3&quot;, &quot;AnnouncmentServer2_IAmAlive&quot;);
	evt.setParam(&quot;4&quot;, &quot;configTimer_timeout&quot;);
	evt.setParam(&quot;5&quot;, &quot;AnnouncmentServer1_IAmAlive&quot;);
}
if (sourceName == &quot;Client&quot;) {
	evt.setParam(&quot;0&quot;, &quot;ConfigComm_ReplyConfig&quot;);
	evt.setParam(&quot;1&quot;, &quot;RequestTimer_timeout&quot;);
	evt.setParam(&quot;2&quot;, &quot;Timer_timeout&quot;);
	evt.setParam(&quot;3&quot;, &quot;Server1Comm_Reply&quot;);
	evt.setParam(&quot;4&quot;, &quot;ResponseTimer_timeout&quot;);
	evt.setParam(&quot;5&quot;, &quot;ConfigComm_StartUp&quot;);
}
return evt;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_G3d-_auwEeiF8vQsMi0qMg" name="triggerCapsuleMessage" specification="_G3d_AquwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>std::map&lt;std::string, size_t>::iterator iter;
std::string instanceName = evt.getCapsuleInstance(); // name of the instance
std::string capsuleType = &quot;&quot;;     // name of the capsule
std::string opName    = evt.getParam(&quot;operation&quot;);
int portIndex = -1;
for(iter=capsules.begin(); iter!=capsules.end(); ++iter) {
if (iter->first == instanceName) {
portIndex = capsules[iter->first];
capsuleType = capsuleTypes[iter->first];
break;
}
}
// For debugging purpose
  printf(&quot;instanceName = %s, capsuleType = %s, portIndex = %d&quot;,      instanceName.c_str(),      capsuleType.c_str(),      (int)portIndex);
if (portIndex == -1) {
printf(&quot;Problem with instanceName = %s&quot;, instanceName.c_str());evt.setParam(&quot;success&quot;, 0);
return evt;
}
if (capsuleType == &quot;EchoCapsule&quot;) {
if (opName == &quot;Echo_Echo&quot;) {
observation.EchoCapsule_Echo_Echo().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Server&quot;) {
if (opName == &quot;MasterAnnounceTimer_timeout&quot;) {
observation.Server_MasterAnnounceTimer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;ServerComm_Request&quot;) {
observation.Server_ServerComm_Request(atoi(evt.getParam(&quot;ServiceID&quot;).c_str())).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;ConfigComm_ReplyConfig&quot;) {
init_systemconfig(evt, &quot;config&quot;);
observation.Server_ConfigComm_ReplyConfig(this->systemconfig).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;Slave_IAmAlive&quot;) {
observation.Server_Slave_IAmAlive(evt.getParam(&quot;ServerName&quot;)).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;Timer_timeout&quot;) {
observation.Server_Timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;KeepAliveTimer_timeout&quot;) {
observation.Server_KeepAliveTimer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;ConfigComm_StartUp&quot;) {
init_systemconfig(evt, &quot;config&quot;);
observation.Server_ConfigComm_StartUp(this->systemconfig).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;ENV&quot;) {
if (opName == &quot;ConfigComm_IAMMaster&quot;) {
observation.ENV_ConfigComm_IAMMaster(evt.getParam(&quot;MasterName&quot;)).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;FailureTimer_timeout&quot;) {
observation.ENV_FailureTimer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;ConfigComm_QueryConfig&quot;) {
observation.ENV_ConfigComm_QueryConfig().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;AnnouncmentServer2_IAmAlive&quot;) {
observation.ENV_AnnouncmentServer2_IAmAlive(evt.getParam(&quot;ServerName&quot;)).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;configTimer_timeout&quot;) {
observation.ENV_configTimer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;AnnouncmentServer1_IAmAlive&quot;) {
observation.ENV_AnnouncmentServer1_IAmAlive(evt.getParam(&quot;ServerName&quot;)).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
if (capsuleType == &quot;Client&quot;) {
if (opName == &quot;ConfigComm_ReplyConfig&quot;) {
init_systemconfig(evt, &quot;config&quot;);
observation.Client_ConfigComm_ReplyConfig(this->systemconfig).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;RequestTimer_timeout&quot;) {
observation.Client_RequestTimer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;Timer_timeout&quot;) {
observation.Client_Timer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;Server1Comm_Reply&quot;) {
observation.Client_Server1Comm_Reply(atoi(evt.getParam(&quot;Result&quot;).c_str())).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;ResponseTimer_timeout&quot;) {
observation.Client_ResponseTimer_timeout().sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
if (opName == &quot;ConfigComm_StartUp&quot;) {
init_systemconfig(evt, &quot;config&quot;);
observation.Client_ConfigComm_StartUp(this->systemconfig).sendAt(portIndex);
evt.setParam(&quot;success&quot;, 1);
}
}
return evt;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_G3d-_quwEeiF8vQsMi0qMg" name="to_bool" specification="_G3d_BauwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>return strcmp(s.c_str(),&quot;0&quot;) != 0 &amp;&amp; strcmp(s.c_str(), &quot;false&quot;) != 0;</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_HExbAauwEeiF8vQsMi0qMg" name="init_systemconfig" specification="_HEXyYKuwEeiF8vQsMi0qMg">
          <language>C++</language>
          <body>systemconfig.ConfigOK = to_bool(evt.getParam(prefix + &quot;.ConfigOK&quot;).c_str());
systemconfig.RunningMode = atoi(evt.getParam(prefix + &quot;.RunningMode&quot;).c_str());
systemconfig.MasterId = atoi(evt.getParam(prefix + &quot;.MasterId&quot;).c_str());
systemconfig.MasterName = getParam(prefix + &quot;.MasterName&quot;).c_str());
systemconfig.MasterList = to_bool(evt.getParam(prefix + &quot;.MasterList&quot;).c_str());
</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_G3d-_6uwEeiF8vQsMi0qMg" name="listCapsuleMessage" concurrency="guarded" method="_G3d-_KuwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3d_AKuwEeiF8vQsMi0qMg" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3d_AauwEeiF8vQsMi0qMg" name="response" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_G3d_AquwEeiF8vQsMi0qMg" name="triggerCapsuleMessage" concurrency="guarded" method="_G3d-_auwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3d_A6uwEeiF8vQsMi0qMg" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3d_BKuwEeiF8vQsMi0qMg" name="response" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_G3d_BauwEeiF8vQsMi0qMg" name="to_bool" concurrency="guarded" method="_G3d-_quwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3d_BquwEeiF8vQsMi0qMg" name="s">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_G3d_B6uwEeiF8vQsMi0qMg" name="result" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_HEXyYKuwEeiF8vQsMi0qMg" name="init_systemconfig" method="_HExbAauwEeiF8vQsMi0qMg">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HEnC8KuwEeiF8vQsMi0qMg" name="evt">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_HExbAKuwEeiF8vQsMi0qMg" name="prefix">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_G3d_CKuwEeiF8vQsMi0qMg" name="internal">
        <packagedElement xmi:type="uml:Artifact" xmi:id="_G3d_CauwEeiF8vQsMi0qMg" name="Event" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_G3d_CquwEeiF8vQsMi0qMg" name="CLIUtils"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_G3d_C6uwEeiF8vQsMi0qMg" name="Serializer"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_G3d_DKuwEeiF8vQsMi0qMg" name="Method"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_G3d_DauwEeiF8vQsMi0qMg" name="Text" fileName=""/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_G3d_DquwEeiF8vQsMi0qMg" name="Socket"/>
        <packagedElement xmi:type="uml:Artifact" xmi:id="_G3d_D6uwEeiF8vQsMi0qMg" name="Config"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_G3d_EKuwEeiF8vQsMi0qMg" name="EventObj"/>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_G3d_EauwEeiF8vQsMi0qMg">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_G3d_EquwEeiF8vQsMi0qMg" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_G3d_E6uwEeiF8vQsMi0qMg">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_G3d_FKuwEeiF8vQsMi0qMg" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_G3d_FauwEeiF8vQsMi0qMg">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_G3d_FquwEeiF8vQsMi0qMg" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_G3d_F6uwEeiF8vQsMi0qMg">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_G3d_GKuwEeiF8vQsMi0qMg" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
      </profileApplication>
    </packagedElement>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_lcu1sAggEea_md0mpENoqg">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_lcwq4AggEea_md0mpENoqg" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_0p1pUAgxEea_md0mpENoqg">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_0p1pUQgxEea_md0mpENoqg" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#_Kv8EIKFXEeS_KNX0nfvIVQ"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://PAPYRUS_ACTIONLANGUAGE_PROFILE/ActionLanguage-Profile.profile.uml#ActionLanguage"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_iMahwAifEea_md0mpENoqg">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_iMbv4AifEea_md0mpENoqg" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_iMeMIAifEea_md0mpENoqg">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_iMgBUAifEea_md0mpENoqg" source="PapyrusVersion">
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_iMgBUQifEea_md0mpENoqg" key="Version" value="0.0.11"/>
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_iMgBUgifEea_md0mpENoqg" key="Comment" value=""/>
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_iMgBUwifEea_md0mpENoqg" key="Copyright" value=""/>
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_iMgBVAifEea_md0mpENoqg" key="Date" value="2015-12-10"/>
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_iMgBVQifEea_md0mpENoqg" key="Author" value=""/>
      </eAnnotations>
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_iMeMIQifEea_md0mpENoqg" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_5AGSMAghEea_md0mpENoqg" base_Class="_4_oYIAghEea_md0mpENoqg"/>
  <UMLRealTime:Capsule xmi:id="_xCrWYAgmEea_md0mpENoqg" base_Class="_xCGHkAgmEea_md0mpENoqg"/>
  <UMLRealTime:Capsule xmi:id="_zp7FcAgmEea_md0mpENoqg" base_Class="_zpdLYAgmEea_md0mpENoqg"/>
  <UMLRealTime:Capsule xmi:id="_d9rwkAgoEea_md0mpENoqg" base_Class="_d9MBUAgoEea_md0mpENoqg"/>
  <UMLRealTime:CapsulePart xmi:id="_ljiusAgoEea_md0mpENoqg" base_Property="_ljfrYAgoEea_md0mpENoqg"/>
  <UMLRealTime:CapsulePart xmi:id="_odySQAgoEea_md0mpENoqg" base_Property="_odv2AAgoEea_md0mpENoqg"/>
  <UMLRealTime:Capsule xmi:id="_sM-g0AgoEea_md0mpENoqg" base_Class="_sMZ5EAgoEea_md0mpENoqg"/>
  <UMLRealTime:CapsulePart xmi:id="_trefIAgoEea_md0mpENoqg" base_Property="_trcC4AgoEea_md0mpENoqg"/>
  <UMLRealTime:ProtocolContainer xmi:id="_v05s8AgsEea_md0mpENoqg" base_Package="_v04e0AgsEea_md0mpENoqg"/>
  <UMLRealTime:RTMessageSet xmi:id="_v09-YAgsEea_md0mpENoqg" base_Interface="_v09XUAgsEea_md0mpENoqg"/>
  <UMLRealTime:RTMessageSet xmi:id="_v1KLoAgsEea_md0mpENoqg" base_Interface="_v1I9gAgsEea_md0mpENoqg" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_v1Q5UAgsEea_md0mpENoqg" base_Interface="_v1PrMAgsEea_md0mpENoqg" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_v1T8oAgsEea_md0mpENoqg" base_Collaboration="_v000cAgsEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_GXxLAAgvEea_md0mpENoqg" isPublish="true" isWired="false" base_Port="_GXsSgAgvEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_g3oVAAgvEea_md0mpENoqg" isWired="false" base_Port="_g3nG4AgvEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_-3NuMAgvEea_md0mpENoqg" isWired="false" base_Port="_-3KD0AgvEea_md0mpENoqg"/>
  <UMLRealTime:Capsule xmi:id="_RMf8EAgzEea_md0mpENoqg" base_Class="_RLyKYAgzEea_md0mpENoqg"/>
  <UMLRealTime:ProtocolContainer xmi:id="_nlCrYAgzEea_md0mpENoqg" base_Package="_nlBdQAgzEea_md0mpENoqg"/>
  <UMLRealTime:RTMessageSet xmi:id="_nlFHoAgzEea_md0mpENoqg" base_Interface="_nlD5gAgzEea_md0mpENoqg"/>
  <UMLRealTime:RTMessageSet xmi:id="_nlO4oAgzEea_md0mpENoqg" base_Interface="_nlL1UAgzEea_md0mpENoqg" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_nlW0cAgzEea_md0mpENoqg" base_Interface="_nlTKEAgzEea_md0mpENoqg" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_nlbF4AgzEea_md0mpENoqg" base_Collaboration="_nk_BAAgzEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_PdauoAg0Eea_md0mpENoqg" isPublish="true" isWired="false" base_Port="_PdYSYAg0Eea_md0mpENoqg"/>
  <UMLRealTime:CapsulePart xmi:id="_6qFwAAg7Eea_md0mpENoqg" base_Property="_6qCFoAg7Eea_md0mpENoqg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_l72A4AifEea_md0mpENoqg" implementationPreface="#include&lt;iostream>" base_Class="_sMZ5EAgoEea_md0mpENoqg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_ZYVLEAihEea_md0mpENoqg" implementationPreface="#include &lt;iostream>" base_Class="_RLyKYAgzEea_md0mpENoqg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_qp8qkAimEea_md0mpENoqg" implementationPreface="#include &lt;iostream>&#xA;#include &lt;fstream>&#xA;#include &lt;limits.h>&#xA;#include &lt;unistd.h>&#xA;using namespace std;" base_Class="_Y1UDYAg6Eea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_b2D_sAjLEea_md0mpENoqg" isWired="false" base_Port="_b1NrIAjLEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_wQWSkAjLEea_md0mpENoqg" isWired="false" base_Port="_wQHCAAjLEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_X4gvkAjMEea_md0mpENoqg" isWired="false" base_Port="_X4ceIAjMEea_md0mpENoqg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_6nxNAAkFEea_md0mpENoqg" implementationPreface="#include &lt;iostream>&#xA;#include &lt;cstdlib>" implementationEnding="" base_Class="_xCGHkAgmEea_md0mpENoqg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_skTr8AlKEea_md0mpENoqg" implementationPreface="#include &lt;iostream>&#xA;#include &lt;cstdlib>" base_Class="_zpdLYAgmEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_iLgtsAmuEea_md0mpENoqg" isWired="false" base_Port="_iLeRcAmuEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_oWjToAmuEea_md0mpENoqg" isWired="false" base_Port="_oWg3YAmuEea_md0mpENoqg"/>
  <UMLRealTime:RTPort xmi:id="_tQAV4AmuEea_md0mpENoqg" isWired="false" base_Port="_tP9SkAmuEea_md0mpENoqg"/>
  <UMLRealTime:ProtocolContainer xmi:id="_5AbN8AnEEeaGqPUk-4V4qQ" base_Package="_4_QwUAnEEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_5AuI4AnEEeaGqPUk-4V4qQ" base_Interface="_5AqegAnEEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_5A1doAnEEeaGqPUk-4V4qQ" base_Interface="_5AzBYAnEEeaGqPUk-4V4qQ" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_5A69MAnEEeaGqPUk-4V4qQ" base_Interface="_5A5IAAnEEeaGqPUk-4V4qQ" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_5BBq4AnEEeaGqPUk-4V4qQ" base_Collaboration="_4--ccAnEEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_fMA_QAnFEeaGqPUk-4V4qQ" base_Port="_fL3OQAnFEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_lRkBMAnFEeaGqPUk-4V4qQ" base_Port="_lRZpIAnFEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_pQ9x0AnMEeaGqPUk-4V4qQ" base_Port="_pQ6HcAnMEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_8sLrYAovEeaGqPUk-4V4qQ" isWired="false" base_Port="_8sGy4AovEeaGqPUk-4V4qQ"/>
  <UMLRealTime:ProtocolContainer xmi:id="_f22ZoApBEeaGqPUk-4V4qQ" base_Package="_f2zWUApBEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_f4CscApBEeaGqPUk-4V4qQ" base_Interface="_f39z8ApBEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_f4IMAApBEeaGqPUk-4V4qQ" base_Interface="_f4FvwApBEeaGqPUk-4V4qQ" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_f4NrkApBEeaGqPUk-4V4qQ" base_Interface="_f4L2YApBEeaGqPUk-4V4qQ" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_f4R9AApBEeaGqPUk-4V4qQ" base_Collaboration="_f2ud0ApBEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_HIz9IApCEeaGqPUk-4V4qQ" base_Port="_HIvrsApCEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_ZDu1IApDEeaGqPUk-4V4qQ" isWired="false" base_Port="_ZDrx0ApDEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_Vj4_QApFEeaGqPUk-4V4qQ" isWired="false" base_Port="_Vj1U4ApFEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_lxxyEApkEeaGqPUk-4V4qQ" isWired="false" base_Port="_lxs5kApkEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_rXbzAApkEeaGqPUk-4V4qQ" isWired="false" base_Port="_rXZWwApkEeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_8587kAs1EeaGqPUk-4V4qQ" isWired="false" base_Port="_855RMAs1EeaGqPUk-4V4qQ"/>
  <UMLRealTime:RTPort xmi:id="_mKiJYOM2EeaTpaLNj-zYpw" isWired="false" base_Port="_mKfGEOM2EeaTpaLNj-zYpw"/>
  <UMLRealTime:RTConnector xmi:id="_O1yTsOM6EeaTpaLNj-zYpw" base_Connector="_O1v3cOM6EeaTpaLNj-zYpw"/>
  <UMLRealTime:RTConnector xmi:id="_P9SuUOM6EeaTpaLNj-zYpw" base_Connector="_P9Q5IOM6EeaTpaLNj-zYpw"/>
  <UMLRealTime:RTPort xmi:id="_rmqMIOM8EeaTpaLNj-zYpw" base_Port="_rmnI0OM8EeaTpaLNj-zYpw"/>
  <UMLRealTime:RTConnector xmi:id="_zuZyguNAEeaTpaLNj-zYpw" base_Connector="_zuXWQONAEeaTpaLNj-zYpw"/>
  <UMLRealTime:RTConnector xmi:id="_0bvZoONAEeaTpaLNj-zYpw" base_Connector="_0bs9YONAEeaTpaLNj-zYpw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_71nSEPMWEeauO5SNGpOV7w" headerPreface="#include &lt;fstream>" base_Class="_4_oYIAghEea_md0mpENoqg"/>
  <RTCppProperties:AttributeProperties xmi:id="_gvmcIPMYEeauO5SNGpOV7w" type="std::ofstream" base_Property="_dCa_wPMYEeauO5SNGpOV7w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_b45wYKozEeiNHY6qjNhZ4w" base_Region="_lvCAwAlLEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_fAFjwKozEeiNHY6qjNhZ4w" base_Pseudostate="_hY-7oAlNEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_gOt6EKozEeiNHY6qjNhZ4w" base_State="_jLPjcAlNEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_hsv-UKozEeiNHY6qjNhZ4w" base_State="_UrcckAlOEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_i6NP8KozEeiNHY6qjNhZ4w" base_State="_hgSoEAlOEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_kA2H4KozEeiNHY6qjNhZ4w" base_Pseudostate="_Rrrc0AlvEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_lJDGEKozEeiNHY6qjNhZ4w" base_Pseudostate="_Pyhf8Ap5EeaGqPUk-4V4qQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_mRbDYKozEeiNHY6qjNhZ4w" base_Pseudostate="_kLngAAp5EeaGqPUk-4V4qQ"/>
  <UMLRTStateMachines:RTState xmi:id="_nsAyEKozEeiNHY6qjNhZ4w" base_State="_2g5S0ONBEeaTpaLNj-zYpw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_o4vD4KozEeiNHY6qjNhZ4w" base_Pseudostate="_M8iZcONCEeaTpaLNj-zYpw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_rpSf8KozEeiNHY6qjNhZ4w" base_Region="_ThAzEONCEeaTpaLNj-zYpw"/>
  <UMLRTStateMachines:RTState xmi:id="_tdqAkKozEeiNHY6qjNhZ4w" base_State="_Px2BIAqSEeaGqPUk-4V4qQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_ud1rMKozEeiNHY6qjNhZ4w" base_Pseudostate="_NU8OsAszEeaGqPUk-4V4qQ"/>
  <UMLRTStateMachines:RTState xmi:id="_veq2EKozEeiNHY6qjNhZ4w" base_State="_ZaK1gAlOEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_wg0PkKozEeiNHY6qjNhZ4w" base_Pseudostate="_5yefMAszEeaGqPUk-4V4qQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_xiP3YKozEeiNHY6qjNhZ4w" base_Pseudostate="_8WMAUONDEeaTpaLNj-zYpw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_0dGe8KozEeiNHY6qjNhZ4w" base_StateMachine="_lT4V0AlLEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_880dQKozEeiNHY6qjNhZ4w" base_Pseudostate="_88oQAKozEeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_88_cYKozEeiNHY6qjNhZ4w" base_Pseudostate="_887yAKozEeiNHY6qjNhZ4w"/>
  <UMLRTStateMachines:RTRegion xmi:id="_Y4mLoKo0EeiNHY6qjNhZ4w" base_Region="_Bk0GwAlKEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_bQ-_UKo0EeiNHY6qjNhZ4w" base_Pseudostate="_Oll1cAlKEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_cpwwIKo0EeiNHY6qjNhZ4w" base_State="_Q5-S4AlKEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_du4lIKo0EeiNHY6qjNhZ4w" base_State="_IjppsAlhEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_eug2IKo0EeiNHY6qjNhZ4w" base_State="_aVMuMAmtEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_f8K8EKo0EeiNHY6qjNhZ4w" base_State="_fO-gkAmtEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_g871gKo0EeiNHY6qjNhZ4w" base_State="_uScfwAmtEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_h7dTQKo0EeiNHY6qjNhZ4w" base_Pseudostate="_qr_J4AnCEeaGqPUk-4V4qQ"/>
  <UMLRTStateMachines:RTState xmi:id="_jFMigKo0EeiNHY6qjNhZ4w" base_State="_KwFHIAo0EeaGqPUk-4V4qQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_k5P6EKo0EeiNHY6qjNhZ4w" base_StateMachine="_BKT8EAlKEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_Rg85wKpiEeiNHY6qjNhZ4w" base_State="_cfbzcAg0Eea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_SuGpYKpiEeiNHY6qjNhZ4w" base_Pseudostate="_bHyrEAg0Eea_md0mpENoqg"/>
  <UMLRTStateMachines:RTRegion xmi:id="_ZzTxgKpiEeiNHY6qjNhZ4w" base_Region="_abLcsAg0Eea_md0mpENoqg"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_bJC1YKpiEeiNHY6qjNhZ4w" base_StateMachine="_WlNQsAg0Eea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_1LnmcKpiEeiNHY6qjNhZ4w" base_Pseudostate="_npsCMAgwEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_2O6PcKpiEeiNHY6qjNhZ4w" base_State="_sdehUAgwEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_3WYN0KpiEeiNHY6qjNhZ4w" base_State="__kywcAgwEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTState xmi:id="_4kr0AKpiEeiNHY6qjNhZ4w" base_State="_NvBagAgxEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_5uXY4KpiEeiNHY6qjNhZ4w" base_Pseudostate="_dWznsAgxEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTRegion xmi:id="_8Lil8KpiEeiNHY6qjNhZ4w" base_Region="_jSIzIAgwEea_md0mpENoqg"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_BsmawKpjEeiNHY6qjNhZ4w" base_StateMachine="_gU8CMAgwEea_md0mpENoqg"/>
  <UMLRealTime:Capsule xmi:id="_G3f0AKuwEeiF8vQsMi0qMg" base_Class="_G3d-4KuwEeiF8vQsMi0qMg"/>
  <UMLRealTime:ProtocolContainer xmi:id="_G3l6oKuwEeiF8vQsMi0qMg" base_Package="_G3d-06uwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTMessageSet xmi:id="_G3l6oauwEeiF8vQsMi0qMg" base_Interface="_G3d-16uwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTMessageSet xmi:id="_G3l6oquwEeiF8vQsMi0qMg" base_Interface="_G3d-2KuwEeiF8vQsMi0qMg" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_G3mhsKuwEeiF8vQsMi0qMg" base_Interface="_G3d-3auwEeiF8vQsMi0qMg" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_G3mhsauwEeiF8vQsMi0qMg" base_Collaboration="_G3d-1KuwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTPort xmi:id="_G3mhsquwEeiF8vQsMi0qMg" isNotification="true" isPublish="true" isWired="false" base_Port="_G3d-4auwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTPort xmi:id="_G3nIwKuwEeiF8vQsMi0qMg" isWired="false" base_Port="_G3d-5KuwEeiF8vQsMi0qMg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_G3nIwauwEeiF8vQsMi0qMg" base_Pseudostate="_G3d--quwEeiF8vQsMi0qMg"/>
  <UMLRTStateMachines:RTState xmi:id="_G3nv0KuwEeiF8vQsMi0qMg" base_State="_G3d--6uwEeiF8vQsMi0qMg"/>
  <UMLRTStateMachines:RTRegion xmi:id="_G3nv0auwEeiF8vQsMi0qMg" base_Region="_G3d-66uwEeiF8vQsMi0qMg"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_G3oW4KuwEeiF8vQsMi0qMg" base_StateMachine="_G3d-6quwEeiF8vQsMi0qMg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_G3o98KuwEeiF8vQsMi0qMg" headerPreface="#include &quot;Method.hh&quot;&#xA;#include &quot;Socket.hh&quot;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Text.hh&quot;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;#include &quot;Config.hh&quot;&#xA;#include &lt;deque>" base_Class="_G3d-4KuwEeiF8vQsMi0qMg" privateDeclarations="Method* method;&#xA;Serializer* serializer;&#xA;std::map&lt;std::string, size_t> capsules;&#xA;std::map&lt;std::string, std::string> capsuleTypes;&#xA;Config config;"/>
  <UMLRealTime:RTPort xmi:id="_G3plAKuwEeiF8vQsMi0qMg" isWired="false" base_Port="_G3d-5auwEeiF8vQsMi0qMg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_G3qMEKuwEeiF8vQsMi0qMg" headerPreface="#include &quot;Event.hh&quot;" implementationPreface="" base_Class="_G3d_EKuwEeiF8vQsMi0qMg" publicDeclarations="Event event;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_G3qzIKuwEeiF8vQsMi0qMg" base_Artifact="_G3d_CauwEeiF8vQsMi0qMg" includeFile="/*&#xA; * Event.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef EVENT_HH_&#xA;#define EVENT_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;iostream>&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;&#xA;class Event {&#xA;&#xA;public:&#xA;typedef enum {&#xA;&#x9;&#x9;Signal,&#xA;&#x9;&#x9;Method,&#xA;&#x9;&#x9;ActionCode,&#xA;&#x9;&#x9;Transition,&#xA;&#x9;&#x9;State,&#xA;&#x9;&#x9;Capsule,&#xA;&#x9;&#x9;Attribute,&#xA;&#x9;&#x9;Timer,&#xA;&#x9;&#x9;UnknownSource, Command&#xA;&#x9;} EventSource;&#xA;&#xA;&#x9;typedef enum {&#xA;&#x9;&#x9;SendSignal, ReceiveSignal, DeferSignal, RecallSignal, CancelSignal, // Signal events&#xA;&#x9;&#x9;MethodCall,&#xA;&#x9;&#x9;MethodCallReceive,&#xA;&#x9;&#x9;MethodStartExecute,&#xA;&#x9;&#x9;MethodReturn,&#xA;&#x9;&#x9;MethodFailed,&#xA;&#x9;&#x9;MethodReturnReceived, // Method events&#xA;&#x9;&#x9;ActionStart,&#xA;&#x9;&#x9;ActionEnd, // Action code events&#xA;&#x9;&#x9;TransitionStart,&#xA;&#x9;&#x9;TransitionEnd, // Transition events&#xA;&#x9;&#x9;StateEntryStart,&#xA;&#x9;&#x9;StateEntryEnd,&#xA;&#x9;&#x9;StateExitStart,&#xA;&#x9;&#x9;StateExitEnd,&#xA;&#x9;&#x9;StateIdleStart,&#xA;&#x9;&#x9;StateIdleEnd, // State events&#xA;&#x9;&#x9;CapsuleInstantiate,&#xA;&#x9;&#x9;CapsuleFree, // Capsule events&#xA;&#x9;&#x9;AttributeInstantiate,&#xA;&#x9;&#x9;AttributeFree,&#xA;&#x9;&#x9;AttributeChange, // Attribute events&#xA;&#x9;&#x9;TimerStart,&#xA;&#x9;&#x9;TimerSet,&#xA;&#x9;&#x9;TimerCancel,&#xA;&#x9;&#x9;TimerTimeout, // Timer events&#xA;&#x9;&#x9;UnknownKind, List, Show, Trigger&#xA;&#x9;} EventKind;&#xA;&#xA;private:&#xA;&#x9;std::string capsuleInstance;&#xA;&#x9;std::string sourceName;&#xA;&#x9;std::string eventId;&#xA;&#x9;long seconds;&#xA;&#x9;long nanoseconds;&#xA;&#x9;EventSource eventSource;&#xA;&#x9;EventKind eventKind;&#xA;&#x9;std::map&lt;std::string, std::string> params;&#xA;&#xA;public:&#xA;&#x9;Event(std::string capsuleInstance = &quot;&quot;, std::string sourceName = &quot;&quot;,&#xA;&#x9;&#x9;&#x9;EventSource eventSource = UnknownSource, EventKind eventKind =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;UnknownKind, long seconds = 0, long nanoseconds = 0);&#xA;&#x9;const std::string getCapsuleInstance() const;&#xA;&#x9;void setCapsuleInstance(const std::string capsuleInstance);&#xA;&#x9;const std::string getSourceName() const;&#xA;&#x9;void setSourceName(const std::string sourceName);&#xA;&#x9;const EventSource getEventSource() const;&#xA;&#x9;void setEventSource(const Event::EventSource source);&#xA;&#x9;const EventKind getEventKind() const;&#xA;&#x9;void setEventKind(const Event::EventKind kind);&#xA;&#x9;const long getSeconds() const;&#xA;&#x9;const long getNanoseconds() const;&#xA;&#x9;void setTimestamp();&#xA;&#x9;void setTimestamp(const long seconds, const long nanoseconds = 0);&#xA;&#x9;void setSeconds(const long seconds);&#xA;&#x9;void setNanoseconds(const long nanoseconds = 0);&#xA;&#x9;void setEventId(const std::string eventId);&#xA;&#x9;const std::string getEventId() const;&#xA;&#x9;void generateEventId();&#xA;&#x9;const std::map&lt;std::string, std::string> getParams() const;&#xA;&#x9;const std::string getParam(std::string key) const;&#xA;&#x9;void setParams(const std::map&lt;std::string, std::string> params);&#xA;&#x9;void setParam(const std::string key, const std::string value);&#xA;&#x9;void setParam(const std::string key, const int value);&#xA;&#x9;void clearParams();&#xA;};&#xA;&#xA;#endif /* EVENT_HH_ */" sourceFile="/*&#xA; * Event.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string>&#xA;#include &lt;sstream>&#xA;#include &lt;time.h>&#xA;#include &lt;sys/time.h>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;&#xA;Event::Event(std::string capsuleInstance, std::string sourceName,&#xA;&#x9;&#x9;EventSource eventSource, EventKind eventKind, long seconds,&#xA;&#x9;&#x9;long nanoseconds) {&#xA;&#xA;&#x9;this->generateEventId();&#xA;&#x9;this->setCapsuleInstance(capsuleInstance);&#xA;&#x9;this->setSourceName(sourceName);&#xA;&#x9;this->setEventSource(eventSource);&#xA;&#x9;this->setEventKind(eventKind);&#xA;}&#xA;&#xA;const std::string Event::getCapsuleInstance() const {&#xA;&#x9;return this->capsuleInstance;&#xA;}&#xA;&#xA;void Event::setCapsuleInstance(const std::string capsuleInstance) {&#xA;&#x9;this->capsuleInstance = capsuleInstance;&#xA;}&#xA;&#xA;const std::string Event::getSourceName() const {&#xA;&#x9;return this->sourceName;&#xA;}&#xA;&#xA;void Event::setSourceName(const std::string sourceName) {&#xA;&#x9;this->sourceName = sourceName;&#xA;}&#xA;&#xA;const Event::EventSource Event::getEventSource() const {&#xA;&#x9;return this->eventSource;&#xA;}&#xA;&#xA;void Event::setEventSource(const Event::EventSource source) {&#xA;&#x9;this->eventSource = source;&#xA;}&#xA;&#xA;const Event::EventKind Event::getEventKind() const {&#xA;&#x9;return this->eventKind;&#xA;}&#xA;&#xA;void Event::setEventKind(const Event::EventKind kind) {&#xA;&#x9;this->eventKind = kind;&#xA;}&#xA;&#xA;const long Event::getSeconds() const {&#xA;&#x9;return this->seconds;&#xA;}&#xA;&#xA;const long Event::getNanoseconds() const {&#xA;&#x9;return this->nanoseconds;&#xA;}&#xA;&#xA;void Event::setTimestamp() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;this->setTimestamp(seconds, nanoseconds);&#xA;&#xA;}&#xA;&#xA;void Event::setTimestamp(const long seconds, const long nanoseconds) {&#xA;&#x9;setSeconds(seconds);&#xA;&#x9;this->setNanoseconds(nanoseconds);&#xA;&#x9;this->seconds = seconds;&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;void Event::setSeconds(const long seconds) {&#xA;&#x9;this->seconds = seconds;&#xA;}&#xA;void Event::setNanoseconds(const long nanoseconds) {&#xA;&#x9;this->nanoseconds = nanoseconds;&#xA;}&#xA;&#xA;const std::string Event::getEventId() const {&#xA;&#x9;return this->eventId;&#xA;}&#xA;&#xA;void Event::setEventId(const std::string eventId) {&#xA;&#x9;this->eventId = eventId;&#xA;}&#xA;&#xA;void Event::generateEventId() {&#xA;&#xA;&#x9;long seconds, nanoseconds;&#xA;&#xA;&#x9;struct timeval tp;&#xA;&#x9;gettimeofday(&amp;tp, NULL);&#xA;&#xA;&#x9;seconds = tp.tv_sec;&#xA;&#x9;nanoseconds = tp.tv_usec * 1000;&#xA;&#xA;&#x9;std::stringstream ss;&#xA;&#x9;int r;&#xA;&#x9;r = random();&#xA;&#xA;&#x9;ss &lt;&lt; seconds &lt;&lt; nanoseconds &lt;&lt; r;&#xA;&#x9;this->eventId = ss.str();&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Event::getParams() const {&#xA;&#x9;return params;&#xA;}&#xA;&#xA;const std::string Event::getParam(std::string key) const {&#xA;&#x9;bool n = this->params.count(key);&#xA;&#x9;return (n) ? this->params.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;void Event::setParams(const std::map&lt;std::string, std::string> params) {&#xA;&#x9;this->params = params;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const std::string value) {&#xA;&#x9;if (key.length() >= 1)&#xA;&#x9;&#x9;this->params[key] = value;&#xA;}&#xA;&#xA;void Event::setParam(const std::string key, const int value) {&#xA;&#x9;std::stringstream v;&#xA;&#x9;v &lt;&lt; value;&#xA;&#x9;this->setParam(key, v.str());&#xA;}&#xA;&#xA;void Event::clearParams() {&#xA;&#x9;this->params.clear();&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_G3tPYKuwEeiF8vQsMi0qMg" base_Artifact="_G3d_CquwEeiF8vQsMi0qMg" includeFile="/*&#xA; * CLIUtils.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CLIUTILS_HH_&#xA;#define CLIUTILS_HH_&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str);&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd);&#xA;&#xA;}&#xA;&#xA;&#xA;&#xA;#endif /* CLIUTILS_HH_ */" sourceFile="/*&#xA; * CLIUtils.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;CLIUtils.hh&quot;&#xA;&#xA;#include&lt;string>&#xA;#include&lt;vector>&#xA;&#xA;namespace CLIUtils {&#xA;&#xA;std::string trim(std::string str) {&#xA;&#x9;size_t strBegin = str.find_first_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;if (strBegin == std::string::npos)&#xA;&#x9;&#x9;return &quot;&quot;; // no content&#xA;&#xA;&#x9;size_t strEnd = str.find_last_not_of(&quot; \n\r\t&quot;);&#xA;&#x9;size_t strRange = strEnd - strBegin + 1;&#xA;&#x9;return str.substr(strBegin, strRange);&#xA;}&#xA;&#xA;std::vector&lt;std::string> tokenizeCommand(const std::string cmd) {&#xA;&#x9;std::vector&lt;std::string> cmdTokens;&#xA;&#xA;&#x9;std::string command = trim(cmd);&#xA;&#xA;&#x9;if (command.length() == 0)&#xA;&#x9;&#x9;return cmdTokens;&#xA;&#xA;&#x9;std::string tempS = &quot;&quot;;&#xA;&#x9;bool newVar = false;&#xA;&#x9;bool quotation = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; command.length(); i++) {&#xA;&#xA;&#x9;&#x9;char c = command[i];&#xA;&#x9;&#x9;bool isSpaceOrEOL = (c == ' ' || c == '\n');&#xA;&#xA;&#x9;&#x9;if (isSpaceOrEOL) {&#xA;&#xA;&#x9;&#x9;&#x9;if (!newVar)&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else if (c == '&quot;') {&#xA;&#x9;&#x9;&#x9;if (!quotation) {&#xA;&#x9;&#x9;&#x9;&#x9;// open a quotation&#xA;&#x9;&#x9;&#x9;&#x9;quotation = true;&#xA;&#x9;&#x9;&#x9;&#x9;if (newVar) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;quotation = false;&#xA;&#x9;&#x9;&#x9;&#x9;newVar = false;&#xA;&#x9;&#x9;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#x9;&#x9;&#x9;&#x9;tempS = &quot;&quot;;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;newVar = true;&#xA;&#x9;&#x9;&#x9;tempS = tempS + c;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newVar)&#xA;&#x9;&#x9;cmdTokens.push_back(trim(tempS));&#xA;&#xA;&#x9;return cmdTokens;&#xA;}&#xA;&#xA;}&#xA;"/>
  <RTCppProperties:ArtifactProperties xmi:id="_G3udgKuwEeiF8vQsMi0qMg" base_Artifact="_G3d_C6uwEeiF8vQsMi0qMg" includeFile="/*&#xA; * Serializer.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SERIALIZER_HH_&#xA;#define SERIALIZER_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;class Serializer {&#xA;&#xA;public:&#xA;&#x9;Serializer();&#xA;&#x9;virtual ~Serializer();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const std::string serialize(const Event event) const = 0;&#xA;&#x9;virtual Event parse(const std::string data) const = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* SERIALIZER_HH_ */" sourceFile="/*&#xA; * Serializer.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;&#xA;Serializer::Serializer() {&#xA;}&#xA;&#xA;Serializer::~Serializer() {&#xA;}&#xA;&#xA;const std::string Serializer::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_G3vEkKuwEeiF8vQsMi0qMg" base_Artifact="_G3d_DKuwEeiF8vQsMi0qMg" includeFile="/*&#xA; * Method.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef METHOD_HH_&#xA;#define METHOD_HH_&#xA;&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Method {&#xA;&#xA;public:&#xA;&#x9;Method();&#xA;&#x9;virtual ~Method();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList) = 0;&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect() = 0;&#xA;&#x9;virtual void disconnect() = 0;&#xA;&#x9;virtual std::string read() = 0;&#xA;&#x9;virtual void sendData(std::string) = 0;&#xA;&#x9;virtual const std::string getConfig(&#xA;&#x9;&#x9;&#x9;std::map&lt;std::string, std::string> configList,&#xA;&#x9;&#x9;&#x9;std::string key) const;&#xA;};&#xA;&#xA;#endif /* METHOD_HH_ */&#xA;" sourceFile="/*&#xA; * Method.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;stdio.h>&#xA;&#xA;Method::Method() {&#xA;}&#xA;&#xA;Method::~Method() {&#xA;}&#xA;&#xA;const bool Method::canConnect() const {&#xA;&#x9;return false;&#xA;}&#xA;&#xA;const std::string Method::getConfig(&#xA;&#x9;&#x9;std::map&lt;std::string, std::string> configList, std::string key) const {&#xA;&#x9;bool n = configList.count(key);&#xA;&#x9;return (n) ? configList.at(key) : &quot;&quot;;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_G3vEkauwEeiF8vQsMi0qMg" base_Artifact="_G3d_DauwEeiF8vQsMi0qMg" includeFile="/*&#xA; * Text.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef TEXT_HH_&#xA;#define TEXT_HH_&#xA;&#xA;#include &quot;Serializer.hh&quot;&#xA;#include &quot;Event.hh&quot;&#xA;#include &lt;string>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;unistd.h>&#xA;&#xA;class Text: public Serializer {&#xA;&#xA;private:&#xA;&#x9;std::string format;&#xA;&#xA;&#x9;// separators&#xA;&#x9;char separator;&#xA;&#x9;char paramSeparator;&#xA;&#x9;char keyValueSeparator;&#xA;&#xA;&#x9;std::vector&lt;std::string> fields;&#xA;&#x9;unsigned int fieldNumber;&#xA;&#x9;const std::vector&lt;std::string> split(const std::string data,&#xA;&#x9;&#x9;&#x9;const char separator) const;&#xA;&#xA;protected:&#xA;&#x9;const std::string getField(const std::string field,&#xA;&#x9;&#x9;&#x9;const Event&amp; event) const;&#xA;&#x9;void setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;&#x9;Event&amp; event) const;&#xA;&#xA;public:&#xA;&#x9;Text();&#xA;&#x9;virtual ~Text();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const std::string serialize(const Event event) const;&#xA;&#x9;const std::string serializeParams(const Event event) const;&#xA;&#x9;virtual Event parse(const std::string data) const;&#xA;&#x9;void parseParameters(Event&amp; event, const std::string data) const;&#xA;&#x9;void setFormat(const std::string format);&#xA;&#x9;const std::string getFormat() const;&#xA;&#x9;void setSeparator(const char separator);&#xA;&#x9;void setParamSeparator(const char paramSeparator);&#xA;&#x9;void setKeyValueSeparator(const char keyValueSeparator);&#xA;};&#xA;&#xA;#endif /* TEXT_HH_ */" sourceFile="/*&#xA; * Text.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Text.hh&quot;&#xA;&#xA;#include &quot;Event.hh&quot;&#xA;&#xA;#include &lt;string.h>&#xA;#include &lt;sstream>&#xA;#include &lt;iostream>&#xA;#include &lt;sstream>&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;vector>&#xA;#include &lt;algorithm>&#xA;&#xA;Text::Text() :&#xA;&#x9;&#x9;Serializer() {&#xA;&#x9;this->setSeparator('|');&#xA;&#x9;this->setParamSeparator(';');&#xA;&#x9;this->setKeyValueSeparator(':');&#xA;&#x9;this->setFormat(&#xA;&#x9;&#x9;&#x9;&quot;eventId|sourceName|capsuleInstance|eventSource|eventKind|seconds|nanoseconds|params&quot;);&#xA;}&#xA;&#xA;Text::~Text() {&#xA;}&#xA;&#xA;void Text::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#x9;std::string separator, paramSeparator, keyValueSeparator, format;&#xA;&#xA;&#x9;separator = this->getConfig(configList, &quot;text.separator&quot;);&#xA;&#x9;paramSeparator = this->getConfig(configList, &quot;text.paramSeparator&quot;);&#xA;&#x9;keyValueSeparator = this->getConfig(configList, &quot;text.keyValueSeparator&quot;);&#xA;&#x9;format = this->getConfig(configList, &quot;text.format&quot;);&#xA;&#xA;&#x9;if (!separator.empty())&#xA;&#x9;&#x9;this->setSeparator(separator[0]);&#xA;&#xA;&#x9;if (!paramSeparator.empty())&#xA;&#x9;&#x9;this->setParamSeparator(paramSeparator[0]);&#xA;&#xA;&#x9;if (!keyValueSeparator.empty())&#xA;&#x9;&#x9;this->setKeyValueSeparator(keyValueSeparator[0]);&#xA;&#xA;&#x9;if (!format.empty())&#xA;&#x9;&#x9;this->setFormat(format);&#xA;&#xA;}&#xA;&#xA;void Text::setFormat(const std::string format) {&#xA;&#x9;this->format = format;&#xA;&#x9;std::vector&lt;std::string> v = this->split(format, this->separator);&#xA;&#xA;&#x9;if (!v.size())&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;this->fields.clear();&#xA;&#x9;this->fields = v;&#xA;&#x9;this->fieldNumber = this->fields.size();&#xA;}&#xA;&#xA;const std::string Text::getFormat() const {&#xA;&#x9;return this->format;&#xA;}&#xA;&#xA;void Text::setSeparator(const char separator) {&#xA;&#x9;this->separator = separator;&#xA;}&#xA;&#xA;void Text::setParamSeparator(const char paramSeparator) {&#xA;&#x9;this->paramSeparator = paramSeparator;&#xA;}&#xA;&#xA;void Text::setKeyValueSeparator(const char keyValueSeparator) {&#xA;&#x9;this->keyValueSeparator = keyValueSeparator;&#xA;}&#xA;&#xA;const std::string Text::serialize(Event event) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it1;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#xA;&#x9;for (it1 = v.begin(); it1 != v.end(); ++it1) {&#xA;&#x9;&#x9;std::string field = *it1;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;out &lt;&lt; this->getField(field, event) &lt;&lt; fieldSeparator;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;const std::string Text::serializeParams(Event event) const {&#xA;&#xA;// results&#xA;&#x9;std::stringstream out;&#xA;&#xA;// params&#xA;&#x9;std::map&lt;std::string, std::string>::const_iterator it2;&#xA;&#x9;std::map&lt;std::string, std::string> params = event.getParams();&#xA;&#xA;&#x9;if (params.empty())&#xA;&#x9;&#x9;return out.str();&#xA;&#xA;&#x9;it2 = params.begin();&#xA;&#x9;out &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator &lt;&lt; it2->second;&#xA;&#x9;++it2;&#xA;&#xA;&#x9;for (; it2 != params.end(); ++it2) {&#xA;&#x9;&#x9;out &lt;&lt; this->paramSeparator &lt;&lt; it2->first &lt;&lt; this->keyValueSeparator&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; it2->second;&#xA;&#x9;}&#xA;&#xA;&#x9;return out.str();&#xA;}&#xA;&#xA;Event Text::parse(const std::string data) const {&#xA;&#xA;&#x9;char fieldSeparator = this->separator;&#xA;&#xA;&#x9;std::vector&lt;std::string> values = this->split(data, fieldSeparator);&#xA;&#x9;Event event;&#xA;&#xA;&#x9;if (values.size() &lt; fieldNumber) {&#xA;&#x9;&#x9;std::cout &lt;&lt; &quot;Error in parsing event stream, only &quot; &lt;&lt; values.size()&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; &quot; are parsed \n&quot;;&#xA;&#x9;&#x9;return event;&#xA;&#x9;}&#xA;&#xA;&#x9;std::vector&lt;std::string>::iterator it;&#xA;&#x9;std::vector&lt;std::string> v = this->fields;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;for (it = v.begin(); it != v.end(); ++it) {&#xA;&#x9;&#x9;std::string field = *it;&#xA;&#x9;&#x9;std::transform(field.begin(), field.end(), field.begin(), ::tolower);&#xA;&#x9;&#x9;this->setField(field, values[i], event);&#xA;&#x9;&#x9;i++;&#xA;&#x9;}&#xA;&#xA;&#x9;return event;&#xA;}&#xA;&#xA;void Text::parseParameters(Event&amp; event, const std::string data) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v = this->split(data, this->paramSeparator);&#xA;&#x9;std::string temp;&#xA;&#xA;&#x9;if (v.size() == 0)&#xA;&#x9;&#x9;return;&#xA;&#xA;&#x9;event.clearParams();&#xA;&#xA;&#x9;for (unsigned i = 0; i &lt; v.size(); i++) {&#xA;&#xA;&#x9;&#x9;std::string::size_type sepIndex = 0;&#xA;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;temp = v[i];&#xA;&#xA;&#x9;&#x9;sepIndex = temp.find(this->keyValueSeparator, 0);&#xA;&#x9;&#x9;key = temp.substr(0, sepIndex);&#xA;&#x9;&#x9;value = temp.substr(sepIndex + 1, temp.length());&#xA;&#xA;&#x9;&#x9;event.setParam(key, value);&#xA;&#xA;&#x9;}&#xA;}&#xA;&#xA;const std::vector&lt;std::string> Text::split(const std::string data,&#xA;&#x9;&#x9;const char separator) const {&#xA;&#xA;&#x9;std::vector&lt;std::string> v;&#xA;&#x9;std::string temp = &quot;&quot;;&#xA;&#x9;bool newField = false;&#xA;&#xA;&#x9;for (unsigned int i = 0; i &lt; data.length(); i++) {&#xA;&#x9;&#x9;if (data[i] == separator) {&#xA;&#x9;&#x9;&#x9;newField = false;&#xA;&#x9;&#x9;&#x9;v.push_back(temp);&#xA;&#x9;&#x9;&#x9;temp = &quot;&quot;;&#xA;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;temp = temp + (data[i]);&#xA;&#x9;&#x9;&#x9;newField = true;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;if (newField)&#xA;&#x9;&#x9;v.push_back(temp);&#xA;&#xA;&#x9;return v;&#xA;}&#xA;&#xA;// The functions below have to be overriden when extending the observer&#xA;const std::string Text::getField(const std::string field,&#xA;&#x9;&#x9;const Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;return event.getEventId();&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;return event.getSourceName();&#xA;&#x9;else if (field == &quot;capsuleinstance&quot;)&#xA;&#x9;&#x9;return event.getCapsuleInstance();&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventSource();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getEventKind();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getSeconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;ss &lt;&lt; event.getNanoseconds();&#xA;&#x9;&#x9;return ss.str();&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;return this->serializeParams(event);&#xA;&#x9;}&#xA;&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Text::setField(const std::string field, const std::string value,&#xA;&#x9;&#x9;Event&amp; event) const {&#xA;&#xA;&#x9;std::stringstream ss; // for conversion purpose&#xA;&#xA;&#x9;if (field == &quot;eventid&quot;)&#xA;&#x9;&#x9;event.setEventId(value);&#xA;&#x9;else if (field == &quot;sourcename&quot;)&#xA;&#x9;&#x9;event.setSourceName(value);&#xA;        else if (field == &quot;capsuleinstance&quot;)&#xA;                event.setCapsuleInstance(value);&#xA;&#x9;else if (field == &quot;eventsource&quot;) {&#xA;&#x9;&#x9;event.setEventSource((Event::EventSource) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;eventkind&quot;) {&#xA;&#x9;&#x9;event.setEventKind((Event::EventKind) (atoi(value.c_str())));&#xA;&#x9;} else if (field == &quot;seconds&quot;) {&#xA;&#x9;&#x9;event.setSeconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;nanoseconds&quot;) {&#xA;&#x9;&#x9;event.setNanoseconds(atol(value.c_str()));&#xA;&#x9;} else if (field == &quot;params&quot;) {&#xA;&#x9;&#x9;this->parseParameters(event, value);&#xA;&#x9;}&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_G3vEkquwEeiF8vQsMi0qMg" base_Artifact="_G3d_DquwEeiF8vQsMi0qMg" includeFile="/*&#xA; * Socket.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef SOCKET_HH_&#xA;#define SOCKET_HH_&#xA;&#xA;#include &lt;arpa/inet.h>&#xA;#include &quot;Method.hh&quot;&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;sys/select.h>&#xA;#include &lt;map>&#xA;#include &lt;string>&#xA;&#xA;class Socket: public Method {&#xA;&#xA;private:&#xA;&#x9;int port;&#xA;&#x9;std::string address;&#xA;&#xA;&#x9;fd_set master;    // master file descriptor list&#xA;&#x9;fd_set read_fds;  // temp file descriptor list for select()&#xA;&#x9;int fdmax;        // maximum file descriptor number&#xA;&#xA;&#x9;int listener;     // listening socket descriptor&#xA;&#x9;struct sockaddr_storage remoteaddr; // client address&#xA;&#x9;socklen_t addrlen;&#xA;&#xA;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;struct timeval tv;&#xA;&#xA;public:&#xA;&#x9;Socket();&#xA;&#x9;virtual ~Socket();&#xA;&#x9;virtual void configure(std::map&lt;std::string, std::string> configList);&#xA;&#x9;virtual const bool canConnect() const;&#xA;&#x9;virtual int connect();&#xA;&#x9;virtual void disconnect();&#xA;&#x9;virtual std::string read();&#xA;&#x9;virtual void sendData(std::string data);&#xA;&#xA;&#x9;const int getPort() const;&#xA;&#x9;void setPort(const int port);&#xA;&#xA;&#x9;const std::string getAddress() const;&#xA;&#x9;void setAddress(const std::string address);&#xA;};&#xA;&#xA;#endif /* SOCKET_HH_ */" sourceFile="/*&#xA; * Socket.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Socket.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;stdlib.h>&#xA;#include &lt;string.h>&#xA;#include &lt;unistd.h>&#xA;#include &lt;sys/types.h>&#xA;#include &lt;sys/socket.h>&#xA;#include &lt;netinet/in.h>&#xA;#include &lt;arpa/inet.h>&#xA;#include &lt;netdb.h>&#xA;#include &lt;sstream>&#xA;&#xA;// get sockaddr, IPv4 or IPv6:&#xA;void *get_in_addr(struct sockaddr *sa) {&#xA;&#x9;if (sa->sa_family == AF_INET) {&#xA;&#x9;&#x9;return &amp;(((struct sockaddr_in*) sa)->sin_addr);&#xA;&#x9;}&#xA;&#xA;&#x9;return &amp;(((struct sockaddr_in6*) sa)->sin6_addr);&#xA;}&#xA;&#xA;Socket::Socket() :&#xA;&#x9;&#x9;Method() {&#xA;&#x9;this->setPort(8080);&#xA;&#x9;this->setAddress(&quot;localhost&quot;);&#xA;}&#xA;&#xA;Socket::~Socket() {&#xA;}&#xA;&#xA;void Socket::configure(std::map&lt;std::string, std::string> configList) {&#xA;&#xA;&#x9;std::string port, address;&#xA;&#x9;port = this->getConfig(configList, &quot;port&quot;);&#xA;&#x9;address = this->getConfig(configList, &quot;address&quot;);&#xA;&#xA;&#x9;if (!port.empty())&#xA;&#x9;&#x9;this->setPort(atoi(port.c_str()));&#xA;&#xA;&#x9;if (!address.empty())&#xA;&#x9;&#x9;this->setAddress(address);&#xA;&#xA;&#x9;printf(&quot;address: %s, port: %d\n&quot;, getAddress().c_str(), getPort());&#xA;}&#xA;&#xA;const bool Socket::canConnect() const {&#xA;&#x9;return true;&#xA;}&#xA;&#xA;int Socket::connect() {&#xA;&#xA;&#x9;int rv, result = -1;&#xA;&#x9;struct addrinfo hints, *ai, *p;&#xA;&#x9;int yes = 1;   // for setsockopt&#xA;&#xA;&#x9;std::stringstream port;&#xA;&#x9;port &lt;&lt; this->getPort();&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;FD_ZERO(&amp;master);    // clear the master and temp sets&#xA;&#x9;FD_ZERO(&amp;read_fds);&#xA;&#xA;&#x9;// get us a socket and bind it&#xA;&#x9;memset(&amp;hints, 0, sizeof hints);&#xA;&#x9;hints.ai_family = AF_UNSPEC;&#xA;&#x9;hints.ai_socktype = SOCK_STREAM;&#xA;&#x9;hints.ai_flags = AI_PASSIVE;&#xA;&#x9;if ((rv = getaddrinfo(NULL, port.str().c_str(), &amp;hints, &amp;ai)) != 0) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: %s\n&quot;, gai_strerror(rv));&#xA;&#x9;&#x9;exit(1);&#xA;&#x9;}&#xA;&#xA;&#x9;for (p = ai; p != NULL; p = p->ai_next) {&#xA;&#x9;&#x9;listener = socket(p->ai_family, p->ai_socktype, p->ai_protocol);&#xA;&#x9;&#x9;if (listener &lt; 0) {&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;// lose the pesky &quot;address already in use&quot; error message&#xA;&#x9;&#x9;setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &amp;yes, sizeof(int));&#xA;&#xA;&#x9;&#x9;if (bind(listener, p->ai_addr, p->ai_addrlen) &lt; 0) {&#xA;&#x9;&#x9;&#x9;close(listener);&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;break;&#xA;&#x9;}&#xA;&#xA;&#x9;&#x9;// if we got here, it means we didn't get bound&#xA;&#x9;if (p == NULL) {&#xA;&#x9;&#x9;fprintf(stderr, &quot;selectserver: failed to bind\n&quot;);&#xA;&#x9;&#x9;exit(2);&#xA;&#x9;}&#xA;&#xA;&#x9;freeaddrinfo(ai); // all done with this&#xA;&#xA;&#x9;// listen&#xA;&#x9;if (listen(listener, 10) == -1) {&#xA;&#x9;&#x9;perror(&quot;listen&quot;);&#xA;&#x9;&#x9;exit(3);&#xA;&#x9;}&#xA;&#xA;&#x9;// add the listener to the master set&#xA;&#x9;FD_SET(listener, &amp;master);&#xA;&#xA;&#x9;// keep track of the biggest file descriptor&#xA;&#x9;fdmax = listener; // so far, it's this one&#xA;&#xA;&#x9;return result;&#xA;&#xA;}&#xA;&#xA;void Socket::disconnect() {&#xA;}&#xA;&#xA;std::string Socket::read() {&#xA;&#xA;&#x9;// main loop&#xA;&#x9;read_fds = master; // copy it&#xA;&#x9;int rc = select(fdmax + 1, &amp;read_fds, NULL, NULL, &amp;tv);&#xA;&#x9;if (rc == -1) {&#xA;&#x9;&#x9;perror(&quot;select&quot;);&#xA;&#x9;&#x9;exit(4);&#xA;&#x9;}&#xA;&#xA;&#x9;tv.tv_sec = 0;&#xA;&#x9;tv.tv_usec = 0;&#xA;&#xA;&#x9;if (rc == 0) {&#xA;&#x9;&#x9;//   printf(&quot;timeout\n&quot;);&#xA;&#x9;&#x9;return &quot;&quot;;&#xA;&#x9;}&#xA;&#xA;&#x9;int i = 0;&#xA;&#xA;&#x9;// run through the existing connections looking for data to read&#xA;&#x9;for (i = 0; i &lt;= fdmax; i++) {&#xA;&#x9;&#x9;if (FD_ISSET(i, &amp;read_fds)) { // we got one!!&#xA;&#x9;&#x9;&#x9;if (i == listener) {&#xA;&#x9;&#x9;&#x9;&#x9;// handle new connections&#xA;&#x9;&#x9;&#x9;&#x9;addrlen = sizeof remoteaddr;&#xA;&#x9;&#x9;&#x9;&#x9;int newfd = accept(listener, (struct sockaddr *) &amp;remoteaddr,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&amp;addrlen);&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;char remoteIP[INET6_ADDRSTRLEN];&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;if (newfd == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;accept&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_SET(newfd, &amp;master); // add to master set&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (newfd > fdmax) {    // keep track of the max&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;fdmax = newfd;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;new connection from %s on &quot;&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&quot;socket %d\n&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;inet_ntop(remoteaddr.ss_family,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;get_in_addr((struct sockaddr*) &amp;remoteaddr),&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;remoteIP, INET6_ADDRSTRLEN), newfd);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;char buf[256];    // buffer for client data&#xA;&#x9;&#x9;&#x9;&#x9;int nbytes;&#xA;&#x9;&#x9;&#x9;&#x9;// handle data from a client&#xA;&#x9;&#x9;&#x9;&#x9;if ((nbytes = recv(i, buf, sizeof buf, 0)) &lt;= 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;// got error or connection closed by client&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;if (nbytes == 0) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;// connection closed&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;printf(&quot;socket %d hung up\n&quot;, i);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;perror(&quot;recv&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;close(i); // bye!&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;FD_CLR(i, &amp;master); // remove from master set&#xA;&#x9;&#x9;&#x9;&#x9;} else {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;std::string str(buf, buf + nbytes - 2);&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;return str;&#xA;//    printf(&quot;new data: %s\n&quot;, buf);&#xA;//    // we got some data from a client&#xA;//    int j = 0;&#xA;//    for(j = 0; j &lt;= fdmax; j++) {&#xA;//        // send to everyone!&#xA;//        if (FD_ISSET(j, &amp;master)) {&#xA;//            // except the listener and ourselves&#xA;//            if (j != listener &amp;&amp; j != i) {&#xA;//                if (send(j, buf, nbytes, 0) == -1) {&#xA;//                    perror(&quot;send&quot;);&#xA;//                }&#xA;//            }&#xA;//        }&#xA;//    }&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;} // END handle data from client&#xA;&#x9;&#x9;} // END got new incoming connection&#xA;&#x9;} // END looping through file descriptors&#xA;&#x9;return &quot;&quot;;&#xA;}&#xA;&#xA;void Socket::sendData(std::string data) {&#xA;&#x9;int j = 0;&#xA;&#x9;for (j = 0; j &lt;= fdmax; j++) {&#xA;&#x9;&#x9;// send to everyone&#xA;&#x9;&#x9;if (FD_ISSET(j, &amp;master)) {&#xA;&#x9;&#x9;&#x9;// no exception&#xA;&#x9;&#x9;&#x9;if (j != listener) {&#xA;&#x9;&#x9;&#x9;&#x9;if (write(j, data.c_str(), data.length()) == -1) {&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;//    perror(&quot;does not work\n&quot;);&#xA;&#x9;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;const int Socket::getPort() const {&#xA;&#x9;return this->port;&#xA;}&#xA;&#xA;void Socket::setPort(const int port) {&#xA;&#x9;this->port = port;&#xA;}&#xA;&#xA;const std::string Socket::getAddress() const {&#xA;&#x9;return this->address;&#xA;}&#xA;&#xA;void Socket::setAddress(const std::string address) {&#xA;&#x9;this->address = address;&#xA;}"/>
  <RTCppProperties:ArtifactProperties xmi:id="_G3vEk6uwEeiF8vQsMi0qMg" base_Artifact="_G3d_D6uwEeiF8vQsMi0qMg" includeFile="/*&#xA; * Config.hh&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#ifndef CONFIG_HH_&#xA;#define CONFIG_HH_&#xA;&#xA;#include &lt;string>&#xA;#include &lt;map>&#xA;&#xA;class Config {&#xA;&#xA;private:&#xA;&#x9;std::string configFileName;&#xA;&#x9;std::string fieldSeparator;&#xA;&#x9;std::string commentStr;&#xA;&#x9;std::string getConfigPath();&#xA;&#x9;std::map&lt;std::string, std::string> configList;&#xA;&#xA;public:&#xA;&#x9;Config();&#xA;&#x9;~Config();&#xA;&#x9;int load();&#xA;&#x9;void append(std::string key, std::string value);&#xA;&#x9;std::string get(std::string key);&#xA;&#x9;void setConfigFileName(const std::string configFileName);&#xA;&#x9;const std::string getConfigFileName() const;&#xA;&#xA;&#x9;void setFieldSeparator(const std::string fieldSeparator);&#xA;&#x9;const std::string getFieldSeparator() const;&#xA;&#xA;&#x9;void setCommentStr(const std::string commentStr);&#xA;&#x9;const std::string getCommentStr() const;&#xA;&#xA;&#x9;const std::map&lt;std::string, std::string> getConfigList() const;&#xA;};&#xA;&#xA;#endif /* CONFIG_HH_ */" sourceFile="/*&#xA; * Config.cc&#xA; *&#xA; *  Created on: Jun 29, 2017&#xA; *      Author: nicolas&#xA; */&#xA;&#xA;#include &quot;Config.hh&quot;&#xA;&#xA;#include &lt;stdio.h>&#xA;#include &lt;fstream>&#xA;#include &lt;iostream>&#xA;#include &lt;unistd.h>&#xA;&#xA;using namespace std;&#xA;&#xA;Config::Config() {&#xA;&#x9;this->setConfigFileName(&quot;config&quot;);&#xA;&#x9;this->setFieldSeparator(&quot;=&quot;);&#xA;&#x9;this->setCommentStr(&quot;#&quot;);&#xA;}&#xA;&#xA;Config::~Config() {&#xA;}&#xA;&#xA;int Config::load() {&#xA;&#xA;&#x9;int result = 0;&#xA;&#x9;std::string prefix = &quot;&quot;;&#xA;&#x9;std::string configPath = this->getConfigPath();&#xA;&#x9;std::ifstream configFile(configPath.c_str());&#xA;&#x9;std::string line;&#xA;&#xA;&#x9;if (configFile.is_open()) {&#xA;&#x9;&#x9;while (std::getline(configFile, line)) {&#xA;&#xA;&#x9;&#x9;&#x9;std::string key, value;&#xA;&#xA;&#x9;&#x9;&#x9;// skip the space and comment line&#xA;&#x9;&#x9;&#x9;std::string::size_type nonSpaceCharIndex = line.find_first_not_of(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;if (nonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // line is empty, skp it&#xA;&#xA;&#x9;&#x9;&#x9;if (this->commentStr.find(line[nonSpaceCharIndex])&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;!= std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // skip the line , it is a comment line&#xA;&#xA;&#x9;&#x9;&#x9;// Check if it is a definition of a specific rule&#xA;&#x9;&#x9;&#x9;std::string::size_type prefixIndex = line.find(&quot;[&quot;,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (prefixIndex != std::string::npos) {&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, prefixIndex + 1);&#xA;&#x9;&#x9;&#x9;&#x9;std::string p = line.substr(valueNonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;));&#xA;&#x9;&#x9;&#x9;&#x9;p.erase(p.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#x9;&#x9;&#x9;&#x9;prefix = p;&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;// extract key value&#xA;&#x9;&#x9;&#x9;std::string::size_type sepIndex = line.find(&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;this->getFieldSeparator(), nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;if (sepIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the line doesn't contain the seperator&#xA;&#xA;&#x9;&#x9;&#x9;key = line.substr(nonSpaceCharIndex, sepIndex - nonSpaceCharIndex);&#xA;&#x9;&#x9;&#x9;key.erase(key.find_last_not_of(&quot; \f\t\v&quot;) + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (key.empty())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // the kwy should have value&#xA;&#xA;&#x9;&#x9;&#x9;if (sepIndex + 1 == line.length())&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;/// extract the value&#xA;&#x9;&#x9;&#x9;std::string::size_type valueNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_first_not_of(&quot; \f\t\v&quot;, sepIndex + 1);&#xA;&#xA;&#x9;&#x9;&#x9;if (valueNonSpaceCharIndex == std::string::npos)&#xA;&#x9;&#x9;&#x9;&#x9;continue; // there is no value&#xA;&#xA;&#x9;&#x9;&#x9;std::string::size_type valueLastNonSpaceCharIndex =&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;line.find_last_not_of(&quot; \f\t\v&quot;);&#xA;&#x9;&#x9;&#x9;value = line.substr(valueNonSpaceCharIndex,&#xA;&#x9;&#x9;&#x9;&#x9;&#x9;valueLastNonSpaceCharIndex - valueNonSpaceCharIndex + 1);&#xA;&#x9;&#x9;&#x9;if (!prefix.empty())&#xA;&#x9;&#x9;&#x9;&#x9;key = prefix + &quot;.&quot; + key;&#xA;&#x9;&#x9;&#x9;this->append(key, value);&#xA;&#x9;&#x9;&#x9;printf(&quot;%s=%s\n&quot;, key.c_str(), value.c_str());&#xA;&#x9;&#x9;&#x9;result = result + 1;&#xA;&#x9;&#x9;}&#xA;&#x9;} else {&#xA;&#x9;&#x9;std::cerr &lt;&lt; &quot;Error in reading configuration file from &quot; &lt;&lt; configPath&#xA;&#x9;&#x9;&#x9;&#x9;&lt;&lt; std::endl;&#xA;&#x9;&#x9;result = -1;&#xA;&#x9;}&#xA;&#x9;configFile.close();&#xA;&#x9;return result;&#xA;}&#xA;&#xA;void Config::append(std::string key, std::string value) {&#xA;&#x9;if (!key.empty())&#xA;&#x9;&#x9;this->configList[key] = value;&#xA;}&#xA;&#xA;std::string Config::get(std::string key) {&#xA;&#x9;bool n = this->configList.count(key);&#xA;&#x9;return (n) ? this->configList.at(key) : &quot;&quot;;&#xA;}&#xA;&#xA;/**&#xA; * Resolve the full path from the exec path&#xA; */&#xA;std::string Config::getConfigPath() {&#xA;&#xA;&#x9;char result[255];&#xA;&#x9;std::string path;&#xA;&#xA;&#x9;ssize_t len = ::readlink(&quot;/proc/self/exe&quot;, result, sizeof(result));&#xA;&#x9;if (len != -1) {&#xA;&#x9;&#x9;path = std::string(result);&#xA;&#x9;}&#xA;&#xA;// find the last &quot;/&quot; position&#xA;&#x9;size_t n = path.rfind('/');&#xA;&#xA;// remove the last fragment of the path&#xA;&#x9;path = (n > 0) ? path.substr(0, n) : &quot;&quot;;&#xA;&#xA;// return the full path&#xA;&#x9;return (path != &quot;&quot;) ?&#xA;&#x9;&#x9;&#x9;path + &quot;/&quot; + this->configFileName : this->configFileName;&#xA;}&#xA;&#xA;void Config::setConfigFileName(const std::string configFileName) {&#xA;&#x9;this->configFileName = configFileName;&#xA;}&#xA;&#xA;const std::string Config::getConfigFileName() const {&#xA;&#x9;return this->configFileName;&#xA;}&#xA;&#xA;void Config::setFieldSeparator(const std::string fieldSeparator) {&#xA;&#x9;this->fieldSeparator = fieldSeparator;&#xA;}&#xA;&#xA;const std::string Config::getFieldSeparator() const {&#xA;&#x9;return this->fieldSeparator;&#xA;}&#xA;&#xA;void Config::setCommentStr(const std::string commentStr) {&#xA;&#x9;this->commentStr = commentStr;&#xA;}&#xA;&#xA;const std::string Config::getCommentStr() const {&#xA;&#x9;return this->commentStr;&#xA;}&#xA;&#xA;const std::map&lt;std::string, std::string> Config::getConfigList() const {&#xA;&#x9;return this->configList;&#xA;}"/>
  <RTCppProperties:AttributeProperties xmi:id="_G3vroKuwEeiF8vQsMi0qMg" type="std::deque&lt;std::string>" base_Property="_G3d-5quwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTPort xmi:id="_G3vroauwEeiF8vQsMi0qMg" isWired="false" base_Port="_G3d-56uwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G3wSsKuwEeiF8vQsMi0qMg" type="Event" base_Parameter="_G3d_AKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G3wSsauwEeiF8vQsMi0qMg" type="Event" base_Parameter="_G3d_AauwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G3wSsquwEeiF8vQsMi0qMg" type="Event" base_Parameter="_G3d_A6uwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G3w5wKuwEeiF8vQsMi0qMg" type="Event" base_Parameter="_G3d_BKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G3w5wauwEeiF8vQsMi0qMg" type="std::string" base_Parameter="_G3d_BquwEeiF8vQsMi0qMg"/>
  <UMLRealTime:CapsulePart xmi:id="_G4mnQKuwEeiF8vQsMi0qMg" base_Property="_G4Yk0KuwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTPort xmi:id="_G43tAKuwEeiF8vQsMi0qMg" isNotification="true" isWired="false" base_Port="_G4qRoKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G5RVoKuwEeiF8vQsMi0qMg" type="Event::EventSource" base_Parameter="_G5OSUKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G5tagKuwEeiF8vQsMi0qMg" type="Event::EventKind" base_Parameter="_G5qXMKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G6AVcKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G5_HUKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G6caUKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G6bMMKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G6onkKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G6myYKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G64fMKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G634IKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G7DeUKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G7CQMKuwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTPort xmi:id="_G9XygKuwEeiF8vQsMi0qMg" isNotification="true" isWired="false" base_Port="_G9XLcKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G9a10KuwEeiF8vQsMi0qMg" type="Event::EventSource" base_Parameter="_G9aOwKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G9r7kKuwEeiF8vQsMi0qMg" type="Event::EventKind" base_Parameter="_G9qtcKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G926sKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G91skKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G-HZYKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G-FkMKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G-cwkKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G-cJgKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G-udYKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G-tPQKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G-3nUKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_G-3AQKuwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTPort xmi:id="_G_3F0KuwEeiF8vQsMi0qMg" isNotification="true" isWired="false" base_Port="_G_2ewKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_G_8lYKuwEeiF8vQsMi0qMg" type="Event::EventSource" base_Parameter="_G_7-UKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HAG9cKuwEeiF8vQsMi0qMg" type="Event::EventKind" base_Parameter="_HAFvUKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HAQHYKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HAPgUKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HAeJ0KuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HAdiwKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HAsMQKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HAq-IKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HA5noKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HA5AkKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HBHDAKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HBGb8KuwEeiF8vQsMi0qMg"/>
  <UMLRealTime:RTPort xmi:id="_HBh5wKuwEeiF8vQsMi0qMg" isNotification="true" isWired="false" base_Port="_HBhSsKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HBmyQKuwEeiF8vQsMi0qMg" type="Event::EventSource" base_Parameter="_HBlkIKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HByYcKuwEeiF8vQsMi0qMg" type="Event::EventKind" base_Parameter="_HBxxYKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HB8wgKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HB8JcKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HCIWsKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HCHvoKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HCY1YKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HCYOUKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HCkbkKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HCj0gKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HCuMkKuwEeiF8vQsMi0qMg" type="const char *" base_Parameter="_HCtlgKuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HEzQMKuwEeiF8vQsMi0qMg" type="Event" base_Parameter="_HEnC8KuwEeiF8vQsMi0qMg"/>
  <RTCppProperties:ParameterProperties xmi:id="_HEz3QKuwEeiF8vQsMi0qMg" type="std::string" base_Parameter="_HExbAKuwEeiF8vQsMi0qMg"/>
</xmi:XMI>
