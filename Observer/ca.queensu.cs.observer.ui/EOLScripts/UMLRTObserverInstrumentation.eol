/*
    
    Developers:
    Mojtaba Bagherzadeh(mojtaba@cs.queensu.ca): Initial development

*/

import "UMLRTQuery.eol";
import "UMLRTCodeReflection.eol";
import "UMLRTCodeGenUtil.eol";
import "UMLRTProfilesOperations.eol";
import "UMLRTElementOperation.eol";
import "DetailTracing.eol";

var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
var ecoreUtil = emfTool.ecoreUtil;

//-----------------------------intialize variables........................................//

//
var uniqueId:Integer=0; // manages the generation of unique id for the name of the elements
var instrumentPrefix:String="Observation__"; // use as a prefix for the  generated variables' name
var generationPrefix="__Generated__";  // used for consistent naming
var endLine:String="\n";  // end of line character
var uniqueID:Integer=1; // we need to name the added state and transition uniquely
var Observarion:String="Observation"; 
var ObserverProtocalName:String="Observation";
var traceType:String="Observation"; // type of tracing 
var debugLevel:Integer=0; // 0= info , 1= debug at frist level functions 2= debug at second level and 3= debug at thirth level 
var currentCapsuleName:String=""; // refers the the the capsule that passed for instrumentation
var ObserverCapsuleName:String="Observer";
var eventClassName:String="Event";
var steeringEventName="steer";
var steeringEvent;
var rtsBaseCommProtocol;
var activePorts:Set;
var observationPortName="observation";
var observationPort;
var observationProtocol;
var eventSignalName:String="event"; // used for code generation;
var eventClassName:String="event";


//-----------------------------loading user models, gateway model, debug protocol........................................//

// Load the standard UML primitive types library (work in standalone)
// See https://www.eclipse.org/forums/index.php/t/1074243/
var libURI = UMLRTModel.resource.uri.createURI("platform:/plugin/org.eclipse.uml2.uml.resources/libraries/UMLPrimitiveTypes.library.uml");
var libResource = UMLRTModel.resource.resourceSet.createResource(libURI);
libResource.load(null);
UMLRTModel.resource.resourceSet.resources.add(libResource);


var observerURI; 

if (observerPath.isDefined()) {
	observerURI = UMLRTModel.resource.uri.createURI(observerPath);
}
else {
	observerURI = UMLRTModel.resource.uri.createURI("platform:/ca.queensu.cs.observer/libraries/observer.uml");
}
var observerResource = UMLRTModel.resource.resourceSet.createResource(observerURI);
observerResource.load(null);
//UMLRTModel.resource.resourceSet.resources.add(observerResource);

var UMLPrimitiveTypes=UMLRTModel!Package.all.select(c|c.name="PrimitiveTypes").first();
//var UMLRTSLIB=UMLRTModel!Package.all.select(c|c.name="UMLRT-RTS").first();
var modelroot:Model=UMLRTModel!Package.all.select(c|c.type.name="Model").first();


//observationProtocol=modelroot.getAllNestedPackage().selectOne(p|p.name=ObserverProtocalName); // load the debugging protocol



//steeringEvent=observationProtocol.packagedElement.first().selectOne(e|e.type.name="CallEvent" and e.`operation`.name=steeringEventName);
//"Instrumentaion is Started on model:".println("Debug Level 0: ");
//modelroot.println("Debug Level 0: ");
 

/// extract all state machine and classes

var allStateMachines:Set=modelroot.getAllStateMachines().select(s|s.owner.name<>ObserverCapsuleName);
var allClasses=modelroot.getAllOwnedClasses().select(c|c.name<>ObserverCapsuleName);
allClasses.size().println("number of capsules: ");
allStateMachines.getAllRegions().getAllStates().size().println("number of states: ");

//----------------------------main loop of the transformation........................................//
transaction{

	/* Load observer */	
	var copiedContents = ecoreUtil.copyAll(observerResource.getContents());
	modelroot.eResource().getContents().addAll(copiedContents);
	modelroot.packagedElement.add(copiedContents.get(0));
	var observerPackage = copiedContents.get(0);
	var observerCapsule  = observerPackage.packagedElement->selectOne(c | c.name == "Observer" );
	var observerProtocol = observerPackage.packagedElement->selectOne(c | c.name == "Observation").packagedElement.first();
	
	/* Get top capsule */
	var topCapsuleAnnotation = modelroot.eAnnotations.selectOne(e | e.source="UMLRT_Default_top");
	var topCapsule: Class;
	
	if (topCapsuleAnnotation.isDefined()) {
		topCapsule = allClasses->selectOne(c | c.name == topCapsuleAnnotation.details.first().value);
	}
	else {
		topCapsule = allClasses->selectOne(c | c.name == "Top");
	}
	
	if (not topCapsule.isDefined()) {
		"No top capsule defined".println();
		return;
	}
	
	/* Add the Observer capsule part */
	var observerProperty = new UMLRTModel!Property();
	observerProperty.type = observerCapsule;
	observerProperty.name = observerCapsule.name.toLowerCase();
	topCapsule.ownedAttributes.add(observerProperty);
	observerProperty.applyUMLRTStereotype(modelroot);
	
	/* Add Observer port to all observable capsules */
	for (capsule in allClasses) {
		capsule.addPortToCapsules("observation",observerProtocol, false, 1, 1, "SAP");
	}
		
	
	for (SM in allStateMachines){
	
		var capsule = SM.owner;
		
		// The capsule is observable
		if (not(capsule.isObservable())) {
			continue;
		}
		
	    currentCapsuleName = capsule.name;
		
		currentCapsuleName.println("Instrumentation of capsule: ");
		
	    observationPort = capsule.getObservablePort();	   

		capsule.refineStructure();
	    
		var allStates = SM.getAllRegions()
							.getAllStates()
							->select(s | s.stateType() == "Composite" or s.stateType() == "State");
							
		var allTransitions = SM.getAllRegions()
							.getAllTransitions();
							
		/// instrument States
		for (s in allStates){
			s.addTrace(traceType);
		}
		
	    /// instrument Transitions
	    for (t in allTransitions){
	    		if (t.source.name==null)
	    			t.source.assignName();
	    		if (t.target.name==null)
	    			t.target.assignName();
			t.addTrace(traceType);
			// add trigger for steering
			if (t.transType()=="StoP" or t.transType()=="StoS" or  t.transType()=="StoC" or t.transType()=="CtoC"){
//				t.createTrigger(instrumentPrefix.concat("MSG"), observationPort, steeringEvent);
				}
		}
	}
//return modelroot;
//abort;
	} 

/**
 * Whether a capsule is observable or not.
 */	
operation Class isObservable () : Boolean {
	return self.ownedAttributes->exists( a | a.name = observationPortName);
}

/**
 * Return the observation port of a capsule.
 */	
operation Class getObservablePort () : Port {
	return self.ownedAttributes
				->selectOne( a | a.name = observationPortName);
}
	
//----------------------------defined main functions for transformation........................................//
/// refine state machine for stop and resume operation


operation  Class refineStructure() {
	/// add debug port to all capsules
	//"refineStructure is started".println();
	//var gateWayRoot=modelroot!Package.all.select(c|c.type.name=ObserverCapsuleName).first();
	//var gateWayCapsule=gateWayRoot.getAllOwnedClasses().selectOne(c|c.name="GateWay");
	//observeProtocol=gateWayRoot.getAllNestedPackage().selectOne(p|p.name="ExtInterface").packagedElement.first();
	//allClasses.addPortToCapsules(debugPortName,observeProtocol,true,1,1,"SAP");
//	for (c in allClasses)
		//c.getUMLRTCapsuleProperties().println();
//		if (c.getStateMachine().isDefined()){
		    //  add method to handle recalling messages
		    //activePorts=c.getStateMachine().getAllRegions().getAllTransitions().getActivePorts();
		    //c.addRecallAllMsgMethod(activePorts);
			//c.println("capsule:");
			//c.addPortToCapsules(debugPortName,observeProtocol,true,1,1,"SAP");
			//"Add method to view attributes: ".concat(c.name).println("refineStructure: ");
			//c.addVarWatchMethod();
			//"Add method to change attributes: ".concat(c.name).println("refineStructure: ");
			//c.addVarChangeMethod();
			//"Add required attributes: ".concat(c.name).println("refineStructure: ");
			//c.addRequiredAttributes();
			//111--
			//// add deatil tracing method and apply it on all states and transtions
			//c.addTracingRequiredHeader();
			self.addSendEventMethod();
			//// add if guard to all stable state
			//// generate the code for checking the condition in entry and exit
			//// 
			
//		}
	
}