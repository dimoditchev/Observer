/*
    
    Developers:
    Mojtaba Bagherzadeh(mojtaba@cs.queensu.ca): Initial development
	Nicolas Hili (hili@cs.queensu.ca): General improvement

*/

import "UMLRTQuery.eol";
import "UMLRTCodeReflection.eol";
import "UMLRTCodeGenUtil.eol";
import "UMLRTProfilesOperations.eol";
import "UMLRTElementOperation.eol";
import "DetailTracing.eol";

var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
var ecoreUtil = emfTool.ecoreUtil;

//-----------------------------intialize variables........................................//

//
var uniqueId:Integer=0; // manages the generation of unique id for the name of the elements
var instrumentPrefix:String="Observation__"; // use as a prefix for the  generated variables' name
var generationPrefix="__Generated__";  // used for consistent naming
var endLine:String="\n";  // end of line character
var uniqueID:Integer=1; // we need to name the added state and transition uniquely
var Observarion:String="Observation"; 
var ObserverProtocalName:String="Observation";
var traceType:String="Observation"; // type of tracing 
var debugLevel:Integer=0; // 0= info , 1= debug at frist level functions 2= debug at second level and 3= debug at thirth level 
var currentCapsuleName:String=""; // refers the the the capsule that passed for instrumentation
var ObserverCapsuleName:String="Observer";
var eventClassName:String="Event";
var steeringEventName="steer";
var steeringEvent;
var rtsBaseCommProtocol;
var activePorts:Set;
var observationPortName="observation";
var observationPort;
var observationProtocol;
var eventSignalName:String="event"; // used for code generation;
var eventClassName:String="event";


//-----------------------------loading user models, gateway model, debug protocol........................................//

// Load the standard UML primitive types library (work in standalone)
// See https://www.eclipse.org/forums/index.php/t/1074243/
var libURI = UMLRTModel.resource.uri.createURI("platform:/plugin/org.eclipse.uml2.uml.resources/libraries/UMLPrimitiveTypes.library.uml");
var libResource = UMLRTModel.resource.resourceSet.createResource(libURI);
libResource.load(null);
UMLRTModel.resource.resourceSet.resources.add(libResource);


var observerURI; 
var observerCapsule: UMLRTModel!Class;
var observerProtocol: UMLRTModel!Collaboration;

if (observerPath.isDefined()) {
	observerURI = UMLRTModel.resource.uri.createURI(observerPath);
}
else {
	observerURI = UMLRTModel.resource.uri.createURI("platform:/ca.queensu.cs.observer/libraries/observer.uml");
}

var observerResource = UMLRTModel.resource.resourceSet.createResource(observerURI);
observerResource.load(null);
UMLRTModel.resource.resourceSet.resources.add(observerResource);

var UMLPrimitiveTypes=UMLRTModel!Package.all.select(c|c.name="PrimitiveTypes").first();
//var UMLRTSLIB=UMLRTModel!Package.all.select(c|c.name="UMLRT-RTS").first();
var modelroot:Model=UMLRTModel!Package.all.select(c|c.type.name="Model").first();

/// extract all state machine and capsules
var allStateMachines: Set	= modelroot.getAllStateMachines()
									   ->select(s | s.owner.name <> ObserverCapsuleName);
									   
var allClasses: Set			= modelroot.getAllOwnedClasses()
									   ->select(c | c.name <> ObserverCapsuleName and c.name <> "EventObj");

/// Get top capsule
var topCapsuleAnnotation = modelroot.eAnnotations.selectOne(e | e.source="UMLRT_Default_top");
var topCapsule: Class;

if (topCapsuleAnnotation.isDefined()) {
	topCapsule = allClasses->selectOne(c | c.name == topCapsuleAnnotation.details.first().value);
}
else {
	topCapsule = allClasses->selectOne(c | c.name == "Top");
}

if (not topCapsule.isDefined()) {
	"No top capsule defined".println();
	return;
}

allClasses.size().println("Number of capsules: ");
allStateMachines.getAllRegions().getAllStates().size().println("Number of states: ");
"".println();



//----------------------------main loop of the transformation........................................//
transaction{

	var observerPackage = modelroot.packagedElement->selectOne(c | c.name == "Observation");
	if (observerPackage.isDefined()) {
		"--\nObserver has already been loaded. Start cleaning...".println();
		
		observerCapsule  = observerPackage.packagedElement->selectOne(c | c.name == "Observer" );
		observerProtocol = observerPackage.packagedElement->selectOne(c | c.name == "Observation").packagedElement.first();
		var observerProtocolPackage = observerPackage.packagedElement->selectOne(c | c.name == "Observation");
		
		"-> Deletion of the Observer capsule part in Top".println();
		delete topCapsule.ownedAttributes->selectOne(p | p.name == observerCapsule.name.toLowerCase());
		
		// Un-instumenting the capsule	
		for (capsule in allClasses) {
		
			var stateMachine : UMLRTModel!StateMachine = capsule
								.ownedBehavior
								->selectOne(b | b.type.name = "StateMachine");
								
			if (not stateMachine.isDefined()) {
				// No state machine, we do not instrument
				continue;
			}
	
			capsule.name.println("-> Un-instrumentation of capsule: ");	
			capsule.uninstrumentStateMachine(stateMachine);
			capsule.uninstrumentStructure();
			
		}
		
		"-> Deletion of the Observer package".println();
		delete modelroot.packagedElement->selectOne(pe | pe.name == "Observation");
		
		"Done.\n".println();
	}	
	
	"--\nStart (re-)building".println();
	
	
	"-> Load observer".println();
	var copied = ecoreUtil.copyAll(observerResource.getContents());
	for(iterator in copied) {
		if(iterator.eClass().name=="Package") {
			modelroot.packagedElement.add(iterator);
		}
		else {
			modelroot.eResource().getContents().add(iterator);
		}
	}
	var observerPackage = modelroot.packagedElement->selectOne(c | c.name == "Observation");

	observerCapsule  = observerPackage.packagedElement->selectOne(c | c.name == "Observer" );
	observerProtocol = observerPackage.packagedElement->selectOne(c | c.name == "Observation").packagedElement.first();
	var observerProtocolPackage = observerPackage.packagedElement->selectOne(c | c.name == "Observation");
	
	/* Hack for fixing the model after copying*/
	var observerInterface: UMLRTModel!Interface = observerProtocol.getAllImplementedInterfaces().get(0);
	
	var collaborationInterface = observerProtocol.getInterfaceRealizations().get(0).contract;
	var collaborationInterfaceIO = observerProtocol.getInterfaceRealizations().get(1).contract;
	observerProtocol.getInterfaceRealizations().clear();
	
	var collaborationInterfaceRealization:		UMLRTModel!InterfaceRealization		= new UMLRTModel!InterfaceRealization;
	var collaborationInterfaceRealizationIO:	UMLRTModel!InterfaceRealization 	= new UMLRTModel!InterfaceRealization;
	
	collaborationInterfaceRealization.contract		= collaborationInterface;
	collaborationInterfaceRealizationIO.contract	= collaborationInterfaceIO;
	observerProtocol.getInterfaceRealizations().add(collaborationInterfaceRealization);
	observerProtocol.getInterfaceRealizations().add(collaborationInterfaceRealizationIO);
	
	"-> Add the Observer capsule part".println();
	var observerProperty = new UMLRTModel!Property();
	observerProperty.type = observerCapsule;
	observerProperty.name = observerCapsule.name.toLowerCase();
	topCapsule.ownedAttributes.add(observerProperty);
	observerProperty.aggregation = (UMLRTModel!AggregationKind#composite);
	observerProperty.applyUMLRTStereotype(modelroot);
	

	// Instrument capsules	
	for (capsule in allClasses) {
	
		var stateMachine : UMLRTModel!StateMachine = capsule
							.ownedBehavior
							->selectOne(b | b.type.name = "StateMachine");
							
		if (not stateMachine.isDefined()) {
			// No state machine, we do not instrument
			continue;
		}

		capsule.name.println("-> Instrumentation of capsule: ");	
		capsule.refineStructure();
		capsule.refineStateMachine(stateMachine);
		
	}

	"-> Instrumentation of the Observer capsule".println();
	observerCapsule.instrumentObserver();

	"Done.\n--".println();
} 

/**
 * Return the observation port of a capsule.
 */	
operation Class getObservablePort() : Port {
	return self.ownedAttributes
				->selectOne( a | a.name = observationPortName);
}

operation  Class uninstrumentStructure() {

	/* Remove Observer port from all observable capsules */
	self.removePort(observationPortName);
	
	/* Remove sendEventMethod */
	self.removeSendEventMethod();
}

operation  Class refineStructure() {

	/* Add Observer port to all observable capsules */
	self.addPortToCapsules(observationPortName, observerProtocol, false, 1, 1, "SAP");
		
	/* Add sendEvent method */
	self.addSendEventMethod();
	
}

operation  Class uninstrumentStateMachine(sm : UMLRTModel!StateMachine) {
	
	var allStates = sm.getAllRegions()
						.getAllStates()
						->select(s | s.stateType() == "Composite" or s.stateType() == "State");
							
	var allTransitions = sm.getAllRegions()
						.getAllTransitions();
							
	/// instrument States
	for (s in allStates){
		s.cleanTraceBody("");
	}
		
	/// instrument Transitions
	for (t in allTransitions){
		t.cleanTraceBody("");
		
		// add trigger for steering
		if (t.transType()=="StoP" or t.transType()=="StoS" or  t.transType()=="StoC" or t.transType()=="CtoC") {	
			var existingTrigger : UMLRTModel!Trigger = t.trigger.first();
			var prefix : String = self.name + "_" + existingTrigger.port.first().name + "_";		
			t.removeTrigger(self.getObservablePort());
		}
	}
}

operation  Class refineStateMachine(sm : UMLRTModel!StateMachine) {

	var allStates = sm.getAllRegions()
						.getAllStates()
						->select(s | s.stateType() == "Composite" or s.stateType() == "State");
							
	var allTransitions = sm.getAllRegions()
						.getAllTransitions();
							
	/// instrument States
	for (s in allStates){
		s.addTrace(traceType);
	}
		
	/// instrument Transitions
	for (t in allTransitions){
		if (t.source.name==null)
	    	t.source.assignName();
	    if (t.target.name==null)
	    	t.target.assignName();
	    	
		t.addTrace(traceType);
		
		// add trigger for steering
		if (t.transType()=="StoP" or t.transType()=="StoS" or  t.transType()=="StoC" or t.transType()=="CtoC") {	
			var existingTrigger : UMLRTModel!Trigger = t.trigger.first();
			var prefix : String = self.name + "_" + existingTrigger.port.first().name + "_";		
			t.createTrigger(prefix, existingTrigger, self.getObservablePort());
		}
	}
}

operation UMLRTModel!Class instrumentObserver () {
	// FIXME: should be called listCapsuleMessages instead of listCapsuleMessage
	var listCapsuleMessageOperation : UMLRTModel!Operation = self.ownedOperation->selectOne(op | op.name == "listCapsuleMessage");
	var behavior : UMLRTModel!OpaqueBehavior = listCapsuleMessageOperation.method->first();
	behavior.body->clear();
	var body : String = "std::string sourceName = evt.getSourceName();\n";
	for (sm in allStateMachines) { 
		// for all capsule:
		body += "if (sourceName == \""+sm.owner.name+"\") {\n";
		
		var allTransitions = sm.getAllRegions()
						.getAllTransitions();
						
		var i: Integer = 0;
		var opNames = allTransitions->select(t | t.trigger->exists(tr | tr.port->exists(p | p.name == "observation")))
									 ->collect(t | t.trigger->first())
									 ->collect(tr | tr.event.`operation`)
									 ->collect(op | op.name)
									 ->asSet();

		for (opName in opNames) { 
				body += "\tevt.setParam(\""+i+"\", \""+opName+"\");\n";
				i++;
		}
		body += "}\n";
	}
	body += "return evt;";
	behavior.body.add(body);
}